{{/*
Globe Poly Shortcode - Simple polygon on an interactive globe

Parameters:
  - points: List of (lat, lng) tuples like [(90, 0), (20, 10), ...]
  - rotate: Center point [lat, lng, tilt] (default: polygon centroid)
  - arrowStep: Show direction arrows every N edges; 0 = no arrows (default: 0)

Usage:
  { {< globe_poly points="[(90, 0), (0, 0), (0, 90)]" >} }
  { {< globe_poly points="[(0, 0), (0, 10), (10, 10), (10, 0)]" arrowStep="1" >} }
*/}}
{{- $id := .Get "id" | default (printf "gp%x" .Ordinal) -}}
{{- $pointsStr := .Get "points" -}}
{{- $rotate := .Get "rotate" -}}
{{- $arrowStep := .Get "arrowStep" | default "0" | int -}}

<div class="globe-container" id="globe-{{ $id }}" style="max-width: 600px; width: 100%; aspect-ratio: 1; margin: 2em auto;"></div>

<script type="module">
  import * as Plot from 'https://cdn.jsdelivr.net/npm/@observablehq/plot@0.6/+esm';
  import * as d3 from 'https://cdn.jsdelivr.net/npm/d3@7/+esm';
  import { feature } from 'https://cdn.jsdelivr.net/npm/topojson-client@3/+esm';

  (async function() {
    // Parse points from "[(lat, lng), (lat, lng), ...]" format, convert to [lng, lat] for GeoJSON
    const pointsStr = "{{ $pointsStr }}";
    const ring = [...pointsStr.matchAll(/\(\s*(-?[\d.]+)\s*,\s*(-?[\d.]+)\s*\)/g)]
      .map(m => [parseFloat(m[2]), parseFloat(m[1])]); // swap to [lng, lat]
    // Close the ring if not already closed
    if (ring.length > 0 && (ring[0][0] !== ring[ring.length-1][0] || ring[0][1] !== ring[ring.length-1][1])) {
      ring.push([...ring[0]]);
    }
    // Reverse for D3 winding convention
    const coords = [ring.slice().reverse()];
    const arrowStep = {{ $arrowStep }};
    const poly = {
      type: 'Feature',
      properties: { name: 'Polygon' },
      geometry: { type: 'Polygon', coordinates: coords }
    };

    // Extract edge midpoint segments for arrow markers
    function getEdgeArrows(ring, step = 10) {
      const arrows = [];
      for (let i = 0; i < ring.length - 1; i += step) {
        const p1 = ring[i];
        const p2 = ring[i + 1];
        const interpolate = d3.geoInterpolate(p1, p2);
        arrows.push([interpolate(0.4), interpolate(0.6)]);
      }
      return arrows;
    }
    const edgeArrows = arrowStep > 0 ? getEdgeArrows(ring, arrowStep) : [];

    const container = document.getElementById('globe-{{ $id }}');
    const getSize = () => {
      const width = container.offsetWidth || container.clientWidth;
      return width > 0 ? Math.min(600, width) : 600;
    };

    // inputRotate is [lat, lng, tilt], centroid is [lng, lat]
    const inputRotate = {{ if $rotate }}{{ $rotate | safeJS }}{{ else }}null{{ end }};
    const centroid = d3.geoCentroid({ type: 'MultiPoint', coordinates: ring });
    const centerRotate = inputRotate
      ? [-inputRotate[1], -inputRotate[0], inputRotate[2] ?? 0]  // swap lat/lng to lng/lat, then negate
      : [-centroid[0], -centroid[1], 0];
    const state = { rotate: centerRotate, width: getSize(), height: getSize() };

    if (!window.globeLandData) {
      const landTopo = await (await fetch('https://cdn.jsdelivr.net/npm/world-atlas@2/land-110m.json')).json();
      window.globeLandData = feature(landTopo, landTopo.objects.land);
    }
    const land = window.globeLandData;

    function preview(geometryOrFeature, rotate) {
      const marks = [
        Plot.geo(land, { stroke: '#88b', fill: 'none', strokeWidth: 0.8, strokeOpacity: 0.8 }),
        Plot.geo(geometryOrFeature, { fill: 'red', fillOpacity: 0.45, stroke: 'red', strokeOpacity: 0.7 }),
        Plot.graticule({ strokeOpacity: 0.06 }),
        Plot.sphere({ strokeWidth: 2 })
      ];

      if (arrowStep > 0) {
        edgeArrows.forEach(segment => {
          marks.push(Plot.line(segment, {
            x: d => d[0],
            y: d => d[1],
            markerEnd: 'arrow',
            stroke: 'darkred',
            strokeWidth: 1.5
          }));
        });
      }

      return Plot.plot({
        width: state.width,
        height: state.height,
        projection: { type: 'orthographic', rotate, inset: 1 },
        marks
      });
    }

    let frame = null;

    function render() {
      if (frame) return;
      frame = requestAnimationFrame(() => {
        frame = null;
        state.width = getSize();
        state.height = getSize();
        container.innerHTML = '';
        const svg = preview(poly, state.rotate);
        container.appendChild(svg);
        attachDrag(svg);
      });
    }

    window.addEventListener('resize', render);

    function attachDrag(svg) {
      const drag = d3.drag()
        .on('start', (event) => {
          drag.startX = event.x;
          drag.startY = event.y;
          drag.startRotate = state.rotate.slice();
        })
        .on('drag', (event) => {
          const dx = event.x - drag.startX;
          const dy = event.y - drag.startY;
          const k = 0.25;
          // Account for tilt when computing drag direction
          const tilt = drag.startRotate[2] * Math.PI / 180;
          const cos_t = Math.cos(tilt);
          const sin_t = Math.sin(tilt);
          const rotatedDx = -(dx * cos_t + dy * sin_t);
          const rotatedDy = -dx * sin_t + dy * cos_t;
          state.rotate = [
            drag.startRotate[0] + rotatedDx * k,
            drag.startRotate[1] - rotatedDy * k,
            drag.startRotate[2]
          ];
          render();
        });
      d3.select(svg).call(drag);
      d3.select(svg).on('dblclick', () => {
        state.rotate = centerRotate.slice();
        render();
      });
    }

    render();
  })();
</script>
