{{- $id := .Get "id" -}}
{{- $dataFile := .Get "data" -}}
{{- $coords := .Get "coords" -}}
{{- $rotate := .Get "rotate" | default "[100, -40, 0]" -}}
{{- $arrowStep := .Get "arrowStep" | default "0" | int -}}

{{- if $dataFile -}}
  {{- /* Try to load from page bundle first, fall back to global data */ -}}
  {{- $resource := .Page.Resources.GetMatch (printf "data/%s.json" $dataFile) -}}
  {{- if $resource -}}
    {{- $coords = transform.Unmarshal $resource -}}
  {{- else -}}
    {{- $coords = index .Site.Data.globe_coords $dataFile -}}
  {{- end -}}
{{- end -}}

<div class="globe-container" id="globe-{{ $id }}" style="max-width: 600px; width: 100%; aspect-ratio: 1; margin: 2em auto;"></div>

<script type="module">
  import * as Plot from 'https://cdn.jsdelivr.net/npm/@observablehq/plot@0.6/+esm';
  import * as d3 from 'https://cdn.jsdelivr.net/npm/d3@7/+esm';
  import { feature } from 'https://cdn.jsdelivr.net/npm/topojson-client@3/+esm';

  (async function() {
    const coords = {{ $coords }};
    const arrowStep = {{ $arrowStep }};
    const poly = {
      type: 'Feature',
      properties: { name: 'Polygon' },
      geometry: { type: 'MultiPolygon', coordinates: coords }
    };

    // Extract edge midpoint segments for arrow markers using great circle interpolation
    function getEdgeArrows(ring, step = 10) {
      const arrows = [];
      for (let i = 0; i < ring.length - 1; i += step) {
        const p1 = ring[i];
        const p2 = ring[i + 1];
        const interpolate = d3.geoInterpolate(p1, p2);
        // Create a short segment around the midpoint (40% to 60% along edge)
        arrows.push([interpolate(0.6), interpolate(0.4)]);
      }
      return arrows;
    }
    const edgeArrows = coords.flatMap(polygon =>
      polygon.flatMap(ring => getEdgeArrows(ring, arrowStep))
    );

    const container = document.getElementById('globe-{{ $id }}');
    const getSize = () => {
      const width = container.offsetWidth || container.clientWidth;
      return width > 0 ? Math.min(600, width) : 600;
    };
    const state = { rotate: {{ $rotate | safeJS }}, width: getSize(), height: getSize() };

    if (!window.globeLandData) {
      const landTopo = await (await fetch('https://cdn.jsdelivr.net/npm/world-atlas@2/land-110m.json')).json();
      window.globeLandData = feature(landTopo, landTopo.objects.land);
    }
    const land = window.globeLandData;

    function preview(geometryOrFeature, rotate) {
      const marks = [
        Plot.geo(land, { stroke: '#88b', fill: 'none', strokeWidth: 0.8, strokeOpacity: 0.8 }),
        Plot.geo(geometryOrFeature, { fill: 'red', fillOpacity: 0.45, stroke: 'red', strokeOpacity: 0.7 }),
        Plot.graticule({ strokeOpacity: 0.06 }),
        Plot.sphere({ strokeWidth: 2 })
      ];

      if (arrowStep > 0) {
        edgeArrows.forEach(segment => {
          marks.push(Plot.line(segment, {
            x: d => d[0],
            y: d => d[1],
            markerEnd: 'arrow',
            stroke: 'darkred',
            strokeWidth: 1.5
          }));
        });
      }

      return Plot.plot({
        width: state.width,
        height: state.height,
        projection: { type: 'orthographic', rotate, inset: 1 },
        marks
      });
    }

    let frame = null;

    function render() {
      if (frame) return;
      frame = requestAnimationFrame(() => {
        frame = null;
        state.width = getSize();
        state.height = getSize();
        container.innerHTML = '';
        const svg = preview(poly, state.rotate);
        container.appendChild(svg);
        attachDrag(svg);
      });
    }

    window.addEventListener('resize', render);

    function attachDrag(svg) {
      const drag = d3.drag()
        .on('start', (event) => {
          drag.startX = event.x;
          drag.startY = event.y;
          drag.startRotate = state.rotate.slice();
        })
        .on('drag', (event) => {
          const dx = event.x - drag.startX;
          const dy = event.y - drag.startY;
          const k = 0.25;
          state.rotate = [
            drag.startRotate[0] + dx * k,
            drag.startRotate[1] - dy * k,
            0
          ];
          render();
        });
      d3.select(svg).call(drag);
      d3.select(svg).on('dblclick', () => {
        state.rotate = {{ $rotate | safeJS }};
        render();
      });
    }

    render();
  })();
</script>
