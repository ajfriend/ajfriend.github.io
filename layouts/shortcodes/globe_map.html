{{/*
Globe Map Shortcode - Render a GeoJSON FeatureCollection with styled features on a globe or map

Parameters:
  - data: Path to JSON file in page bundle (e.g., "data/my_map.json")
  - rotate: Center point [lng, lat, tilt] (default: centroid of features)
  - projection: Map projection type (default: "orthographic")
      Common options: orthographic, mercator, equirectangular, equal-earth
      Other D3 projections are also available.
  - width: Max width in pixels (default: 600)

Data format (GeoJSON FeatureCollection):
  {
    "type": "FeatureCollection",
    "features": [
      {
        "type": "Feature",
        "properties": {
          "fill": "blue",
          "fillOpacity": 0.3,
          "stroke": "darkblue",
          "strokeWidth": 2,
          "r": 5,
          "arrow": true
        },
        "geometry": { ... }
      }
    ]
  }

Note: LineString features are automatically rendered as great circle arcs (geodesics)
by Plot.geo(), not as straight lines in screen space.

Usage:
  { {< globe_map data="data/my_map.json" >} }
  { {< globe_map data="data/my_map.json" projection="mercator" width="800" >} }
*/}}
{{- $id := .Get "id" | default (printf "gm%x" .Ordinal) -}}
{{- $dataFile := .Get "data" -}}
{{- $rotate := .Get "rotate" -}}
{{- $projection := .Get "projection" | default "orthographic" -}}
{{- $width := .Get "width" | default "600" | int -}}

{{- /* Load data from page bundle */ -}}
{{- $resource := .Page.Resources.GetMatch $dataFile -}}
{{- $data := "" -}}
{{- if $resource -}}
  {{- $data = transform.Unmarshal $resource -}}
{{- end -}}

{{- $isGlobe := eq $projection "orthographic" -}}
<div class="globe-container" id="globe-{{ $id }}" style="max-width: {{ $width }}px; width: 100%; aspect-ratio: {{ if $isGlobe }}1{{ else }}2{{ end }}; margin: 2em auto;"></div>

<script type="module">
  import * as Plot from 'https://cdn.jsdelivr.net/npm/@observablehq/plot@0.6/+esm';
  import * as d3 from 'https://cdn.jsdelivr.net/npm/d3@7/+esm';
  import { feature } from 'https://cdn.jsdelivr.net/npm/topojson-client@3/+esm';

  (async function() {
    const rawData = {{ $data }};

    if (!rawData || !rawData.features) {
      console.error('globe_map: Invalid or missing data');
      return;
    }

    // D3 expects opposite winding from GeoJSON, so reverse polygon rings
    const featureCollection = {
      type: rawData.type,
      features: rawData.features.map(f => {
        if (f.geometry.type === 'Polygon') {
          return {
            ...f,
            geometry: {
              ...f.geometry,
              coordinates: f.geometry.coordinates.map(ring => ring.slice().reverse())
            }
          };
        } else if (f.geometry.type === 'MultiPolygon') {
          return {
            ...f,
            geometry: {
              ...f.geometry,
              coordinates: f.geometry.coordinates.map(polygon =>
                polygon.map(ring => ring.slice().reverse())
              )
            }
          };
        }
        return f;
      })
    };

    const projection = "{{ $projection }}";
    const isGlobe = projection === "orthographic";
    const maxWidth = {{ $width }};

    const container = document.getElementById('globe-{{ $id }}');
    const getSize = () => {
      const width = container.offsetWidth || container.clientWidth;
      const w = width > 0 ? Math.min(maxWidth, width) : maxWidth;
      return { width: w, height: isGlobe ? w : w / 2 };
    };

    // Compute centroid from all geometries (use original data before reversal)
    const inputRotate = {{ if $rotate }}{{ $rotate | safeJS }}{{ else }}null{{ end }};
    const allPoints = [];
    rawData.features.forEach(f => {
      if (f.geometry.type === 'Point') {
        allPoints.push(f.geometry.coordinates);
      } else if (f.geometry.type === 'LineString') {
        allPoints.push(...f.geometry.coordinates);
      } else if (f.geometry.type === 'Polygon') {
        f.geometry.coordinates.forEach(ring => allPoints.push(...ring));
      } else if (f.geometry.type === 'MultiPolygon') {
        f.geometry.coordinates.forEach(polygon =>
          polygon.forEach(ring => allPoints.push(...ring))
        );
      }
    });
    const centroid = allPoints.length > 0
      ? d3.geoCentroid({ type: 'MultiPoint', coordinates: allPoints })
      : [0, 0];
    const centerRotate = inputRotate
      ? [-inputRotate[0], -inputRotate[1], inputRotate[2] ?? 0]
      : [-centroid[0], -centroid[1], 0];
    const size = getSize();
    const state = { rotate: centerRotate, width: size.width, height: size.height };

    if (!window.globeLandData) {
      const landTopo = await (await fetch('https://cdn.jsdelivr.net/npm/world-atlas@2/land-110m.json')).json();
      window.globeLandData = feature(landTopo, landTopo.objects.land);
    }
    const land = window.globeLandData;

    function render() {
      const size = getSize();
      state.width = size.width;
      state.height = size.height;

      const marks = [
        Plot.geo(land, { stroke: '#88b', fill: 'none', strokeWidth: 0.8, strokeOpacity: 0.8 }),
        Plot.graticule({ strokeOpacity: 0.06 })
      ];

      if (isGlobe) {
        marks.push(Plot.sphere({ strokeWidth: 2 }));
      } else {
        marks.push(Plot.frame({ strokeWidth: 1 }));
      }

      // Separate features by type
      const polygons = {
        type: 'FeatureCollection',
        features: featureCollection.features.filter(f =>
          f.geometry.type === 'Polygon' || f.geometry.type === 'MultiPolygon'
        )
      };
      const lines = {
        type: 'FeatureCollection',
        features: featureCollection.features.filter(f => f.geometry.type === 'LineString')
      };
      const points = {
        type: 'FeatureCollection',
        features: featureCollection.features.filter(f => f.geometry.type === 'Point')
      };

      // Render polygons with per-feature styling
      if (polygons.features.length > 0) {
        marks.push(Plot.geo(polygons, {
          fill: d => d.properties?.fill || 'red',
          fillOpacity: d => d.properties?.fillOpacity ?? 0.45,
          stroke: d => d.properties?.stroke || d.properties?.fill || 'red',
          strokeWidth: d => d.properties?.strokeWidth ?? 1,
          strokeOpacity: d => d.properties?.strokeOpacity ?? 0.7
        }));
      }

      // Render lines with per-feature styling
      if (lines.features.length > 0) {
        marks.push(Plot.geo(lines, {
          stroke: d => d.properties?.stroke || 'red',
          strokeWidth: d => d.properties?.strokeWidth ?? 2.5,
          strokeOpacity: d => d.properties?.strokeOpacity ?? 0.9
        }));

        // Add arrows on each segment of lines that request them
        lines.features.forEach(f => {
          if (f.properties?.arrow) {
            const coords = f.geometry.coordinates;
            for (let i = 0; i < coords.length - 1; i++) {
              const interpolate = d3.geoInterpolate(coords[i], coords[i + 1]);
              marks.push(Plot.line([interpolate(0.45), interpolate(0.55)], {
                x: d => d[0],
                y: d => d[1],
                markerEnd: 'arrow',
                stroke: f.properties?.stroke || 'darkred',
                strokeWidth: f.properties?.strokeWidth ?? 2
              }));
            }
          }
        });
      }

      // Render points individually to avoid auto-scaling of r
      points.features.forEach(f => {
        marks.push(Plot.geo(f, {
          fill: f.properties?.fill || 'red',
          stroke: f.properties?.stroke || 'darkred',
          strokeWidth: f.properties?.strokeWidth ?? 1,
          r: f.properties?.r ?? 5
        }));
      });

      const projectionConfig = isGlobe
        ? { type: projection, rotate: state.rotate, inset: 1 }
        : { type: projection };

      const svg = Plot.plot({
        width: state.width,
        height: state.height,
        projection: projectionConfig,
        marks
      });

      container.innerHTML = '';
      container.appendChild(svg);
      if (isGlobe) {
        attachDrag(svg);
      }
    }

    window.addEventListener('resize', render);

    // Versor math for proper 3D globe rotation
    const versor = {
      cartesian: function(e) {
        const l = e[0] * Math.PI / 180, p = e[1] * Math.PI / 180, cp = Math.cos(p);
        return [cp * Math.cos(l), cp * Math.sin(l), Math.sin(p)];
      },
      rotation: function(q) {
        return [
          Math.atan2(2 * (q[0] * q[1] + q[2] * q[3]), 1 - 2 * (q[1] * q[1] + q[2] * q[2])) * 180 / Math.PI,
          Math.asin(Math.max(-1, Math.min(1, 2 * (q[0] * q[2] - q[3] * q[1])))) * 180 / Math.PI,
          Math.atan2(2 * (q[0] * q[3] + q[1] * q[2]), 1 - 2 * (q[2] * q[2] + q[3] * q[3])) * 180 / Math.PI
        ];
      },
      delta: function(v0, v1) {
        const w = this.cross(v0, v1), l = Math.sqrt(this.dot(w, w));
        if (!l) return [1, 0, 0, 0];
        const t = Math.acos(Math.max(-1, Math.min(1, this.dot(v0, v1)))) / 2, s = Math.sin(t);
        return [Math.cos(t), w[2] / l * s, -w[1] / l * s, w[0] / l * s];
      },
      multiply: function(a, b) {
        return [
          a[0] * b[0] - a[1] * b[1] - a[2] * b[2] - a[3] * b[3],
          a[0] * b[1] + a[1] * b[0] + a[2] * b[3] - a[3] * b[2],
          a[0] * b[2] - a[1] * b[3] + a[2] * b[0] + a[3] * b[1],
          a[0] * b[3] + a[1] * b[2] - a[2] * b[1] + a[3] * b[0]
        ];
      },
      from: function(r) {
        const l = r[0] / 2 * Math.PI / 180, p = r[1] / 2 * Math.PI / 180, g = r[2] / 2 * Math.PI / 180;
        const sl = Math.sin(l), cl = Math.cos(l);
        const sp = Math.sin(p), cp = Math.cos(p);
        const sg = Math.sin(g), cg = Math.cos(g);
        return [
          cl * cp * cg + sl * sp * sg,
          sl * cp * cg - cl * sp * sg,
          cl * sp * cg + sl * cp * sg,
          cl * cp * sg - sl * sp * cg
        ];
      },
      cross: function(a, b) { return [a[1]*b[2] - a[2]*b[1], a[2]*b[0] - a[0]*b[2], a[0]*b[1] - a[1]*b[0]]; },
      dot: function(a, b) { return a[0]*b[0] + a[1]*b[1] + a[2]*b[2]; }
    };

    function attachDrag(svg) {
      const projection = d3.geoOrthographic()
        .rotate(state.rotate)
        .translate([state.width / 2, state.height / 2])
        .scale(Math.min(state.width, state.height) / 2 - 1);

      let v0, q0, r0;

      const drag = d3.drag()
        .on('start', (event) => {
          projection.rotate(state.rotate).translate([state.width / 2, state.height / 2]).scale(Math.min(state.width, state.height) / 2 - 1);
          const inv = projection.invert([event.x, event.y]);
          if (inv) {
            v0 = versor.cartesian(inv);
            r0 = state.rotate;
            q0 = versor.from(r0);
          }
        })
        .on('drag', (event) => {
          if (!v0) return;
          projection.rotate(r0);
          const inv = projection.invert([event.x, event.y]);
          if (!inv) return;
          const v1 = versor.cartesian(inv);
          const delta = versor.delta(v0, v1);
          const q1 = versor.multiply(q0, delta);
          state.rotate = versor.rotation(q1);
          render();
        });

      d3.select(svg).call(drag);
      d3.select(svg).on('dblclick', () => {
        state.rotate = centerRotate.slice();
        render();
      });
    }

    render();
  })();
</script>
