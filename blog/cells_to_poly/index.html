<!doctype html><html lang=en-us><head><meta http-equiv=X-Clacks-Overhead content="GNU Terry Pratchett"><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>[WIP] Making H3's cells-to-polygon faster | AJ Friend</title><meta name=title content="[WIP] Making H3's cells-to-polygon faster"><meta name=description content="Note: This post is currently a quick-and-dirty attempt at explaining the algorithm
behind cellsToMultiPolygon core algorithm #1113 · uber/h3. My plan is to grow this into a
proper blog post with more context, background, etc.
TODO: note the python implementation

  #Goal: H3 cells to spherical polygons
A collection of H3 cells describes a subset of the globe,
and a common operation is to translate that set of cells into spherical polygons
(e.g., a GeoJSON MultiPolygon) outlining the same region."><meta name=keywords content><meta property="og:url" content="https://ajfriend.com/blog/cells_to_poly/"><meta property="og:site_name" content="AJ Friend"><meta property="og:title" content="[WIP] Making H3's cells-to-polygon faster"><meta property="og:description" content="Note: This post is currently a quick-and-dirty attempt at explaining the algorithm behind cellsToMultiPolygon core algorithm #1113 · uber/h3. My plan is to grow this into a proper blog post with more context, background, etc.
TODO: note the python implementation
#Goal: H3 cells to spherical polygons A collection of H3 cells describes a subset of the globe, and a common operation is to translate that set of cells into spherical polygons (e.g., a GeoJSON MultiPolygon) outlining the same region."><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="blog"><meta property="article:published_time" content="2026-01-09T00:00:00+00:00"><meta property="article:modified_time" content="2026-01-09T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="[WIP] Making H3's cells-to-polygon faster"><meta name=twitter:description content="Note: This post is currently a quick-and-dirty attempt at explaining the algorithm behind cellsToMultiPolygon core algorithm #1113 · uber/h3. My plan is to grow this into a proper blog post with more context, background, etc.
TODO: note the python implementation
#Goal: H3 cells to spherical polygons A collection of H3 cells describes a subset of the globe, and a common operation is to translate that set of cells into spherical polygons (e.g., a GeoJSON MultiPolygon) outlining the same region."><meta itemprop=name content="[WIP] Making H3's cells-to-polygon faster"><meta itemprop=description content="Note: This post is currently a quick-and-dirty attempt at explaining the algorithm behind cellsToMultiPolygon core algorithm #1113 · uber/h3. My plan is to grow this into a proper blog post with more context, background, etc.
TODO: note the python implementation
#Goal: H3 cells to spherical polygons A collection of H3 cells describes a subset of the globe, and a common operation is to translate that set of cells into spherical polygons (e.g., a GeoJSON MultiPolygon) outlining the same region."><meta itemprop=datePublished content="2026-01-09T00:00:00+00:00"><meta itemprop=dateModified content="2026-01-09T00:00:00+00:00"><meta itemprop=wordCount content="2656"><meta name=referrer content="no-referrer-when-downgrade"><style>:root{--width:720px;--font-main:Verdana, sans-serif;--font-secondary:Verdana, sans-serif;--font-scale:1em;--background-color:#fff;--heading-color:#222;--text-color:#444;--link-color:#3273dc;--visited-color:#8b6fcb;--blockquote-color:#222}@media(prefers-color-scheme:dark){:root{--background-color:#01242e;--heading-color:#eee;--text-color:#ddd;--link-color:#8cc2dd;--visited-color:#8b6fcb;--blockquote-color:#ccc}}body{font-family:var(--font-secondary);font-size:var(--font-scale);margin:auto;padding:20px;max-width:var(--width);text-align:left;background-color:var(--background-color);word-wrap:break-word;overflow-wrap:break-word;line-height:1.5;color:var(--text-color)}h1,h2,h3,h4,h5,h6{font-family:var(--font-main);color:var(--heading-color)}a{color:var(--link-color);cursor:pointer;text-decoration:none}a:hover{text-decoration:underline}nav a{margin-right:8px}strong,b{color:var(--heading-color)}button{margin:0;cursor:pointer}time{font-family:monospace;font-style:normal;font-size:15px}main{line-height:1.6}table{width:100%}hr{border:0;border-top:1px dashed}img{max-width:100%}code{font-family:monospace;padding:2px;border-radius:3px}blockquote{border-left:1px solid #999;color:var(--blockquote-color);padding-left:20px;font-style:italic}footer{padding:25px 0;text-align:center}.title:hover{text-decoration:none}.title h1{font-size:1.5em}.inline{width:auto!important}.highlight,.code{border-radius:3px;margin-block-start:1em;margin-block-end:1em;overflow-x:auto}ul.blog-posts{list-style-type:none;padding:unset}ul.blog-posts li{display:flex}ul.blog-posts li span{flex:0 0 130px}ul.blog-posts li a:visited{color:var(--visited-color)}</style><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.css integrity=sha384-nB0miv6/jRmo5UMMR1wu3Gz6NLsoTkbqJghGIsx//Rlm+ZU03BU6SQNC66uf4l5+ crossorigin=anonymous><style>:root{--width:900px}p.caption{text-align:center;font-size:small;font-style:italic;margin-top:-1rem}h1.page-title{font-size:2.2rem;color:#111;margin-bottom:.2rem;border-bottom:2px solid #3273dc;padding-bottom:.3rem}main h1,main h2,main h3,main h4,main h5,main h6{font-weight:600;margin-top:2rem;margin-bottom:1rem}main h1{font-size:1.8rem}main h2{font-size:1.4rem}main h3{font-size:1.2rem}nav.toc{background:#f8f8f8;padding:1rem 1.5rem;margin-bottom:2rem;border-radius:4px}nav.toc h2{margin-top:0;font-size:1.1rem}nav.toc ul{margin:0;padding-left:1.5rem}nav.toc li{margin:.3rem 0}nav.toc a{text-decoration:none}nav.toc a:hover{text-decoration:underline}.highlight{background:#f6f8fa;border:1px solid #e1e4e8;border-radius:6px;margin:1.5rem 0;overflow-x:auto}.highlight pre{margin:0;padding:.1rem 1rem;background:0 0}.highlight code{font-size:.9rem;line-height:1.5;font-family:sf mono,Consolas,liberation mono,Menlo,monospace}.highlight .ln{color:#999;margin-right:1rem;user-select:none}code:not(.highlight code){background:#f0f0f0;padding:.15rem .4rem;border-radius:3px;font-size:.88em;font-family:sf mono,Consolas,liberation mono,Menlo,monospace}@media(prefers-color-scheme:dark){:root{--background-color:#fff;--heading-color:#222;--text-color:#444;--link-color:#3273dc;--visited-color:#8b6fcb;--blockquote-color:#222}}.anchor-link{text-decoration:none;color:#999;margin-right:.5em}.anchor-link:hover{color:#333;text-decoration:underline}</style></head><body><header><a href=/ class=title><h2>AJ Friend</h2></a><nav><a href=/>Home</a>
<a href=/blog>Blog</a>
<a href=/software>Software</a>
<a href=/notes>Notes</a></nav></header><main><h1 class=page-title>[WIP] Making H3's cells-to-polygon faster</h1><p><i><time datetime=2026-01-09>2026-01-09</time></i></p><nav class=toc><h2>Contents</h2><nav id=TableOfContents><ul><li><a href=#goal-h3-cells-to-spherical-polygons>Goal: H3 cells to spherical polygons</a></li><li><a href=#h3-cells-and-edges>H3 cells and edges</a><ul><li><a href=#directed-edge-preliminaries>Directed edge preliminaries</a></li></ul></li><li><a href=#general-idea-remove-symmetric-pairs>General idea: remove symmetric pairs</a><ul><li><a href=#example-one-hole>Example: one hole</a></li><li><a href=#implementation-notes-hash-table>Implementation notes: hash table</a><ul><li><a href=#python>Python</a></li><li><a href=#c>C</a></li></ul></li></ul></li><li><a href=#loops-of-edges>Loops of edges</a><ul><li><a href=#loop-surgery>Loop surgery</a><ul><li><a href=#example-four-cells>Example: four cells</a></li><li><a href=#example-disk>Example: disk</a></li><li><a href=#example-hole>Example: hole</a></li></ul></li><li><a href=#implementation-notes-doubly-linked-loops>Implementation notes: doubly-linked loops</a></li></ul></li><li><a href=#connected-components-partition-loops-into-polygons>Connected components partition loops into polygons</a><ul><li><a href=#implementation-notes-union-find>Implementation notes: union-find</a></li></ul></li><li><a href=#which-loop-is-outside>Which loop is &ldquo;outside&rdquo;?</a></li><li><a href=#code-overview>Code overview</a></li><li><a href=#notes>Notes</a></li></ul></nav></nav><content><p><strong>Note</strong>: This post is currently a quick-and-dirty attempt at explaining the algorithm
behind <a href=https://github.com/uber/h3/pull/1113>cellsToMultiPolygon core algorithm #1113 · uber/h3</a>. My plan is to grow this into a
proper blog post with more context, background, etc.</p><p>TODO: note the python implementation</p><h1 id=goal-h3-cells-to-spherical-polygons><a href=#goal-h3-cells-to-spherical-polygons class=anchor-link>#</a>Goal: H3 cells to spherical polygons</h1><p>A collection of <a href=https://h3geo.org/>H3 cells</a> describes a subset of the globe,
and a common operation is to translate that set of cells into spherical polygons
(e.g., a <a href=https://geojson.org/>GeoJSON</a> <code>MultiPolygon</code>) outlining the same region.</p><div style=display:flex;flex-wrap:wrap;justify-content:center;align-items:center;gap:1rem><div class=globe-container id=globe-gm0 style="max-width:400px;width:100%;aspect-ratio:1;margin:2em auto"></div><script type=module>
  import * as Plot from 'https://cdn.jsdelivr.net/npm/@observablehq/plot@0.6/+esm';
  import * as d3 from 'https://cdn.jsdelivr.net/npm/d3@7/+esm';
  import { feature } from 'https://cdn.jsdelivr.net/npm/topojson-client@3/+esm';

  (async function() {
    const rawData = {"features":[{"geometry":{"coordinates":[[[[-164.45647827941468,26.67326523622734],[-166.75703720202299,28.616915453971142],[-167.88337203384341,29.62550789823012],[-172.64626329548403,28.20896181794974],[-173.6703874763115,23.782822700979136],[-171.3530255445717,21.94669609285208],[-170.26790510748518,20.964113606206052],[-165.75801721847134,22.310289219453917],[-164.45647827941468,26.67326523622734]]],[[[-178.22376950605553,22.092681232201556],[-178.95063664056067,17.74333218723816],[-175.4582711140254,15.28573031248396],[-171.35903250000365,16.594714504739436],[-170.26790510748518,20.964113606206052],[-171.3530255445717,21.946696092852083],[-173.6703874763115,23.782822700979136],[-178.22376950605553,22.092681232201556]]],[[[-168.1728875957565,13.44560433788435],[-171.35903250000365,16.594714504739436],[-175.45827111402537,15.285730312483953],[-176.35806599111405,11.05195584369349],[-173.38014762578527,7.9727938308414075],[-169.2931299839693,9.060308038526603],[-168.1728875957565,13.44560433788435]]],[[[-156.08998858841755,24.696711258039056],[-159.5659720311805,27.919872272760344],[-164.45647827941468,26.67326523622734],[-165.75801721847134,22.310289219453917],[-162.39694129463984,19.114485874069658],[-157.6068486027842,20.259691594705036],[-156.08998858841755,24.696711258039056]]],[[[178.4754053347224,29.376139351007172],[177.84694371159145,24.75690942135447],[-178.22376950605553,22.092681232201556],[-173.6703874763115,23.782822700979136],[-172.64626329548403,28.20896181794974],[-176.54267313535857,31.148162090824524],[178.4754053347224,29.376139351007172]]],[[[179.77693144202632,9.615942399155198],[179.2171608248945,5.88992175431389],[-178.02519665249852,2.9040374505798114],[-174.31673738369324,3.8210244943304374],[-173.38014762578527,7.9727938308414075],[-176.35806599111405,11.05195584369349],[-178.23815999124182,10.46324037683843],[179.77693144202632,9.615942399155198]]],[[[179.77693144202632,9.615942399155198],[176.28993210653294,11.794175727566111],[172.29426677728955,9.978189493251357],[172.03418236939353,6.172978893164637],[175.46041201203371,4.248592317017825],[179.21716082489448,5.889921754313911],[179.77693144202632,9.615942399155198]]],[[[168.65279280829242,16.286127926718756],[172.88878640797157,18.30669067889132],[173.23062212965775,22.777763428069576],[168.91929058653923,25.257056432213375],[164.45727251367725,23.004725058862295],[164.53519134064652,18.52280839538614],[168.65279280829242,16.286127926718756]]],[[[178.4754053347224,29.376139351007172],[174.02804175387834,32.1119243692579],[169.07436240121478,29.9547386287809],[168.91929058653923,25.257056432213375],[173.23062212965775,22.777763428069576],[177.84694371159145,24.75690942135447],[178.4754053347224,29.376139351007172]]],[[[164.67056230846524,10.175448079467838],[168.53745793093609,12.10200548276957],[168.65279280829242,16.286127926718756],[164.53519134064652,18.52280839538614],[160.52670878987635,16.340968799924067],[160.7733897026288,12.194726726168003],[164.67056230846524,10.175448079467838]]],[[[164.67056230846524,10.175448079467838],[164.7007803629394,8.237083943199265],[164.93539603741021,6.119591258608642],[168.3352524578736,4.467031609784524],[172.03418236939353,6.172978893164637],[172.29426677728955,9.978189493251357],[168.53745793093609,12.10200548276957],[164.67056230846524,10.175448079467838]]],[[[-167.31261713417402,1.5147974903819574],[-166.16940101623453,5.767146686378417],[-169.2931299839693,9.060308038526603],[-173.38014762578527,7.9727938308414075],[-174.31673738369324,3.8210244943304374],[-171.37544324872502,0.649870565576401],[-167.31261713417402,1.5147974903819574]]],[[[-167.31261713417402,1.5147974903819574],[-164.25615857265893,-1.7743965588128086],[-159.93112334382027,-0.9446533902388665],[-158.59967491814012,3.335734857517349],[-161.77338167921764,6.766536253596436],[-166.16940101623453,5.767146686378417],[-167.31261713417402,1.5147974903819574]]],[[[-175.56432922504848,35.741206971176496],[179.9534193241767,38.728779390762334],[174.49688633843544,36.85680682151307],[174.02804175387834,32.1119243692579],[178.4754053347224,29.376139351007172],[-176.54267313535857,31.148162090824524],[-175.56432922504848,35.741206971176496]]],[[[-168.8876761772056,41.53861492567143],[-170.27191812997154,37.14623592274974],[-166.5289282511271,33.96535450751626],[-161.64707805135708,34.994006697107615],[-159.94762734735153,39.09941640444715],[-163.39292691687498,42.461841701752746],[-168.8876761772056,41.53861492567143]]],[[[-166.5289282511271,33.96535450751626],[-167.88337203384341,29.62550789823012],[-166.75703720202299,28.616915453971142],[-164.45647827941468,26.67326523622734],[-159.5659720311805,27.919872272760344],[-158.04649474959947,32.12156651323389],[-161.64707805135708,34.9940066971076],[-166.5289282511271,33.96535450751626]]],[[[-168.8876761772056,41.53861492567143],[-173.2513616288856,44.74985555511408],[-179.170112546831,43.33462463706695],[179.9534193241767,38.728779390762334],[-175.56432922504848,35.741206971176496],[-170.27191812997154,37.14623592274974],[-168.8876761772056,41.53861492567143]]],[[[-156.08998858841755,24.696711258039056],[-151.04796662686522,25.669243623986258],[-149.34707529879068,29.89183008460252],[-152.85043045733752,33.12732053866678],[-158.04649474959947,32.12156651323389],[-159.5659720311805,27.919872272760344],[-156.08998858841755,24.696711258039056]]],[[[-151.04796662686522,25.669243623986258],[-147.69594788211106,22.16693900740581],[-142.7188705783351,22.885971422359724],[-140.91889130500928,27.061192038819836],[-144.17342232410294,30.569950882968854],[-149.34707529879068,29.89183008460252],[-151.04796662686522,25.669243623986258]]],[[[-140.91889130500928,27.061192038819836],[-142.7188705783351,22.885971422359724],[-139.6214919325493,19.2239309458196],[-134.89965579269537,19.7532105149965],[-133.08381598345164,23.820431161854447],[-135.98689147817444,27.469138609544558],[-140.91889130500928,27.061192038819836]]],[[[-133.89520751564908,11.884131145297399],[-132.14080471892913,16.072271835802038],[-134.89965579269537,19.7532105149965],[-139.6214919325493,19.2239309458196],[-141.37151007296615,14.881959131410003],[-138.42043748614526,11.22287623237951],[-133.89520751564908,11.884131145297399]]],[[[-133.89520751564908,11.884131145297399],[-138.42043748614526,11.22287623237951],[-140.12125038010964,6.870649308036964],[-137.3063271216714,3.372828505596593],[-132.96499017492758,4.158942627265325],[-131.26895225504,8.320295172124068],[-133.89520751564908,11.884131145297399]]],[[[-159.93112334382027,-0.9446533902388665],[-156.8531091350144,-4.259065522271725],[-152.3980821982831,-3.4345808068957697],[-150.91862197114955,0.7969950664894166],[-154.0294052002189,4.260374459536214],[-158.59967491814012,3.335734857517349],[-159.93112334382027,-0.9446533902388665]]],[[[-143.3961790952625,-1.706579969821454],[-138.95903110794228,-0.8353130739527114],[-137.3063271216714,3.372828505596593],[-140.12125038010964,6.870649308036964],[-144.72979242136543,6.045591181415267],[-146.33638072286848,1.6772949381945044],[-143.3961790952625,-1.706579969821454]]],[[[-144.9683236097968,-5.820413131280587],[-143.3961790952625,-1.706579969821454],[-146.33638072286848,1.6772949381945044],[-150.91862197114955,0.7969950664894166],[-152.3980821982831,-3.4345808068957697],[-149.4028814909321,-6.672537737437516],[-144.9683236097968,-5.820413131280587]]],[[[-155.7634836482284,12.265823643881989],[-152.5335322367957,8.71898308656318],[-147.80006555587835,9.62874721795654],[-146.16007687374923,14.110797540904425],[-149.3676428224656,17.73753035354521],[-154.25484084592026,16.797013674901503],[-155.7634836482284,12.265823643881989]]],[[[-153.03739182353243,43.44325276436556],[-154.78487065089823,39.9092677035244],[-151.12386440058128,37.032961967755135],[-145.74636904346727,37.68759229063255],[-143.8463112012841,41.20828589932378],[-147.45009391663316,44.09362423911828],[-153.03739182353243,43.44325276436556]]],[[[-142.3232078622538,34.454167617014946],[-137.16670054747664,34.7661254517022],[-136.19839496396796,36.53790229001989],[-135.31985086435014,38.551076772095065],[-138.45029122366302,41.45713981733577],[-143.8463112012841,41.20828589932378],[-145.74636904346727,37.68759229063255],[-142.3232078622538,34.454167617014946]]],[[[-168.1728875957565,13.44560433788435],[-163.71455965998953,14.623074892227512],[-162.39694129463984,19.114485874069658],[-165.75801721847134,22.310289219453917],[-170.26790510748518,20.964113606206052],[-171.35903250000365,16.594714504739436],[-168.1728875957565,13.44560433788435]]],[[[-168.1728875957565,13.44560433788435],[-169.2931299839693,9.060308038526603],[-166.16940101623453,5.767146686378417],[-161.77338167921764,6.766536253596436],[-160.44607430026895,11.231115019630433],[-163.71455965998953,14.623074892227512],[-168.1728875957565,13.44560433788435]]]],"type":"MultiPolygon"},"properties":{"fill":"#3273dc","fillOpacity":0.3,"stroke":"#3273dc","strokeWidth":2},"type":"Feature"}],"type":"FeatureCollection"};

    if (!rawData || !rawData.features) {
      console.error('globe_map: Invalid or missing data');
      return;
    }

    
    const featureCollection = {
      type: rawData.type,
      features: rawData.features.map(f => {
        if (f.geometry.type === 'Polygon') {
          return {
            ...f,
            geometry: {
              ...f.geometry,
              coordinates: f.geometry.coordinates.map(ring => ring.slice().reverse())
            }
          };
        } else if (f.geometry.type === 'MultiPolygon') {
          return {
            ...f,
            geometry: {
              ...f.geometry,
              coordinates: f.geometry.coordinates.map(polygon =>
                polygon.map(ring => ring.slice().reverse())
              )
            }
          };
        }
        return f;
      })
    };

    const projection = "orthographic";
    const isGlobe = projection === "orthographic";
    const maxWidth =  400 ;
    const arrowStep =  0 ;

    const container = document.getElementById('globe-gm0');
    const getSize = () => {
      const width = container.offsetWidth || container.clientWidth;
      const w = width > 0 ? Math.min(maxWidth, width) : maxWidth;
      return { width: w, height: isGlobe ? w : w / 2 };
    };

    
    const inputRotate = null;
    const allPoints = [];
    rawData.features.forEach(f => {
      if (f.geometry.type === 'Point') {
        allPoints.push(f.geometry.coordinates);
      } else if (f.geometry.type === 'LineString') {
        allPoints.push(...f.geometry.coordinates);
      } else if (f.geometry.type === 'Polygon') {
        f.geometry.coordinates.forEach(ring => allPoints.push(...ring));
      } else if (f.geometry.type === 'MultiPolygon') {
        f.geometry.coordinates.forEach(polygon =>
          polygon.forEach(ring => allPoints.push(...ring))
        );
      }
    });
    const centroid = allPoints.length > 0
      ? d3.geoCentroid({ type: 'MultiPoint', coordinates: allPoints })
      : [0, 0];
    const centerRotate = inputRotate
      ? [-inputRotate[0], -inputRotate[1], inputRotate[2] ?? 0]
      : [-centroid[0], -centroid[1], 0];
    const size = getSize();
    const localState = { width: size.width, height: size.height };

    
    if (!window.globeMapSync) {
      window.globeMapSync = {
        rotate: centerRotate,
        centerRotate: centerRotate,
        renders: []
      };
    }
    const sync = window.globeMapSync;

    
    if (sync.renders.length === 0) {
      sync.rotate = centerRotate;
      sync.centerRotate = centerRotate;
    }

    if (!window.globeLandData) {
      const landTopo = await (await fetch('https://cdn.jsdelivr.net/npm/world-atlas@2/land-110m.json')).json();
      window.globeLandData = feature(landTopo, landTopo.objects.land);
    }
    const land = window.globeLandData;

    function render() {
      const size = getSize();
      localState.width = size.width;
      localState.height = size.height;

      const marks = [
        Plot.geo(land, { stroke: '#88b', fill: 'none', strokeWidth: 0.8, strokeOpacity: 0.8 }),
        Plot.graticule({ strokeOpacity: 0.06 })
      ];

      if (isGlobe) {
        marks.push(Plot.sphere({ strokeWidth: 2 }));
      } else {
        marks.push(Plot.frame({ strokeWidth: 1 }));
      }

      
      const polygons = {
        type: 'FeatureCollection',
        features: featureCollection.features.filter(f =>
          f.geometry.type === 'Polygon' || f.geometry.type === 'MultiPolygon'
        )
      };
      const lines = {
        type: 'FeatureCollection',
        features: featureCollection.features.filter(f => f.geometry.type === 'LineString')
      };
      const points = {
        type: 'FeatureCollection',
        features: featureCollection.features.filter(f => f.geometry.type === 'Point')
      };

      
      if (polygons.features.length > 0) {
        marks.push(Plot.geo(polygons, {
          fill: d => d.properties?.fill || 'red',
          fillOpacity: d => d.properties?.fillOpacity ?? 0.45,
          stroke: d => d.properties?.stroke || d.properties?.fill || 'red',
          strokeWidth: d => d.properties?.strokeWidth ?? 1,
          strokeOpacity: d => d.properties?.strokeOpacity ?? 0.7
        }));

        
        if (arrowStep > 0) {
          let edgeIndex = 0;
          
          rawData.features.forEach(f => {
            if (f.geometry.type !== 'Polygon' && f.geometry.type !== 'MultiPolygon') return;
            const stroke = f.properties?.stroke || f.properties?.fill || 'red';
            const strokeWidth = f.properties?.strokeWidth ?? 1;
            const rings = f.geometry.type === 'Polygon'
              ? f.geometry.coordinates
              : f.geometry.coordinates.flat();
            rings.forEach(ring => {
              for (let i = 0; i < ring.length - 1; i++) {
                if (edgeIndex % arrowStep === 0) {
                  const interpolate = d3.geoInterpolate(ring[i], ring[i + 1]);
                  marks.push(Plot.line([interpolate(0.45), interpolate(0.55)], {
                    x: d => d[0],
                    y: d => d[1],
                    markerEnd: 'arrow',
                    stroke: 'darkred',
                    strokeWidth: 1.5
                  }));
                }
                edgeIndex++;
              }
            });
          });
        }
      }

      
      if (lines.features.length > 0) {
        marks.push(Plot.geo(lines, {
          stroke: d => d.properties?.stroke || 'red',
          strokeWidth: d => d.properties?.strokeWidth ?? 2.5,
          strokeOpacity: d => d.properties?.strokeOpacity ?? 0.9
        }));

        
        lines.features.forEach(f => {
          if (f.properties?.arrow) {
            const coords = f.geometry.coordinates;
            for (let i = 0; i < coords.length - 1; i++) {
              const interpolate = d3.geoInterpolate(coords[i], coords[i + 1]);
              marks.push(Plot.line([interpolate(0.45), interpolate(0.55)], {
                x: d => d[0],
                y: d => d[1],
                markerEnd: 'arrow',
                stroke: f.properties?.stroke || 'darkred',
                strokeWidth: f.properties?.strokeWidth ?? 2
              }));
            }
          }
        });
      }

      
      points.features.forEach(f => {
        marks.push(Plot.geo(f, {
          fill: f.properties?.fill || 'red',
          stroke: f.properties?.stroke || 'darkred',
          strokeWidth: f.properties?.strokeWidth ?? 1,
          r: f.properties?.r ?? 5
        }));
      });

      const projectionConfig = isGlobe
        ? { type: projection, rotate: sync.rotate, inset: 1 }
        : { type: projection };

      const svg = Plot.plot({
        width: localState.width,
        height: localState.height,
        projection: projectionConfig,
        marks
      });

      container.innerHTML = '';
      container.appendChild(svg);
      if (isGlobe) {
        attachDrag(svg);
      }
    }

    window.addEventListener('resize', render);

    
    const versor = {
      cartesian: function(e) {
        const l = e[0] * Math.PI / 180, p = e[1] * Math.PI / 180, cp = Math.cos(p);
        return [cp * Math.cos(l), cp * Math.sin(l), Math.sin(p)];
      },
      rotation: function(q) {
        return [
          Math.atan2(2 * (q[0] * q[1] + q[2] * q[3]), 1 - 2 * (q[1] * q[1] + q[2] * q[2])) * 180 / Math.PI,
          Math.asin(Math.max(-1, Math.min(1, 2 * (q[0] * q[2] - q[3] * q[1])))) * 180 / Math.PI,
          Math.atan2(2 * (q[0] * q[3] + q[1] * q[2]), 1 - 2 * (q[2] * q[2] + q[3] * q[3])) * 180 / Math.PI
        ];
      },
      delta: function(v0, v1) {
        const w = this.cross(v0, v1), l = Math.sqrt(this.dot(w, w));
        if (!l) return [1, 0, 0, 0];
        const t = Math.acos(Math.max(-1, Math.min(1, this.dot(v0, v1)))) / 2, s = Math.sin(t);
        return [Math.cos(t), w[2] / l * s, -w[1] / l * s, w[0] / l * s];
      },
      multiply: function(a, b) {
        return [
          a[0] * b[0] - a[1] * b[1] - a[2] * b[2] - a[3] * b[3],
          a[0] * b[1] + a[1] * b[0] + a[2] * b[3] - a[3] * b[2],
          a[0] * b[2] - a[1] * b[3] + a[2] * b[0] + a[3] * b[1],
          a[0] * b[3] + a[1] * b[2] - a[2] * b[1] + a[3] * b[0]
        ];
      },
      from: function(r) {
        const l = r[0] / 2 * Math.PI / 180, p = r[1] / 2 * Math.PI / 180, g = r[2] / 2 * Math.PI / 180;
        const sl = Math.sin(l), cl = Math.cos(l);
        const sp = Math.sin(p), cp = Math.cos(p);
        const sg = Math.sin(g), cg = Math.cos(g);
        return [
          cl * cp * cg + sl * sp * sg,
          sl * cp * cg - cl * sp * sg,
          cl * sp * cg + sl * cp * sg,
          cl * cp * sg - sl * sp * cg
        ];
      },
      cross: function(a, b) { return [a[1]*b[2] - a[2]*b[1], a[2]*b[0] - a[0]*b[2], a[0]*b[1] - a[1]*b[0]]; },
      dot: function(a, b) { return a[0]*b[0] + a[1]*b[1] + a[2]*b[2]; }
    };

    function attachDrag(svg) {
      const projection = d3.geoOrthographic()
        .rotate(sync.rotate)
        .translate([localState.width / 2, localState.height / 2])
        .scale(Math.min(localState.width, localState.height) / 2 - 1);

      let v0, q0, r0;

      const drag = d3.drag()
        .on('start', (event) => {
          projection.rotate(sync.rotate).translate([localState.width / 2, localState.height / 2]).scale(Math.min(localState.width, localState.height) / 2 - 1);
          const inv = projection.invert([event.x, event.y]);
          if (inv) {
            v0 = versor.cartesian(inv);
            r0 = sync.rotate;
            q0 = versor.from(r0);
          }
        })
        .on('drag', (event) => {
          if (!v0) return;
          projection.rotate(r0);
          const inv = projection.invert([event.x, event.y]);
          if (!inv) return;
          const v1 = versor.cartesian(inv);
          const delta = versor.delta(v0, v1);
          const q1 = versor.multiply(q0, delta);
          sync.rotate = versor.rotation(q1);
          
          sync.renders.forEach(r => r());
        });

      d3.select(svg).call(drag);
      d3.select(svg).on('dblclick', () => {
        sync.rotate = sync.centerRotate.slice();
        sync.renders.forEach(r => r());
      });
    }

    
    sync.renders.push(render);

    render();
  })();
</script><span style=font-size:2rem>→</span><div class=globe-container id=globe-gm1 style="max-width:400px;width:100%;aspect-ratio:1;margin:2em auto"></div><script type=module>
  import * as Plot from 'https://cdn.jsdelivr.net/npm/@observablehq/plot@0.6/+esm';
  import * as d3 from 'https://cdn.jsdelivr.net/npm/d3@7/+esm';
  import { feature } from 'https://cdn.jsdelivr.net/npm/topojson-client@3/+esm';

  (async function() {
    const rawData = {"features":[{"geometry":{"coordinates":[[[[-179.170112546831,43.33462463706695],[179.9534193241767,38.728779390762334],[174.49688633843544,36.85680682151307],[174.02804175387834,32.1119243692579],[169.07436240121478,29.9547386287809],[168.91929058653923,25.257056432213375],[164.45727251367725,23.004725058862295],[164.53519134064652,18.52280839538614],[160.52670878987635,16.340968799924067],[160.7733897026288,12.194726726168003],[164.67056230846524,10.175448079467838],[164.7007803629394,8.237083943199265],[164.93539603741021,6.119591258608642],[168.3352524578736,4.467031609784524],[172.03418236939353,6.172978893164637],[175.46041201203371,4.248592317017825],[179.2171608248945,5.88992175431389],[-178.02519665249852,2.9040374505798114],[-174.31673738369324,3.8210244943304374],[-171.37544324872502,0.649870565576401],[-167.31261713417402,1.5147974903819574],[-164.25615857265893,-1.7743965588128086],[-159.93112334382027,-0.9446533902388665],[-156.8531091350144,-4.259065522271725],[-152.3980821982831,-3.4345808068957697],[-149.4028814909321,-6.672537737437516],[-144.9683236097968,-5.820413131280587],[-143.3961790952625,-1.706579969821454],[-138.95903110794228,-0.8353130739527114],[-137.3063271216714,3.372828505596593],[-132.96499017492758,4.158942627265325],[-131.26895225504,8.320295172124068],[-133.89520751564908,11.884131145297399],[-132.14080471892913,16.072271835802038],[-134.89965579269537,19.7532105149965],[-133.08381598345164,23.820431161854447],[-135.98689147817444,27.469138609544558],[-140.91889130500928,27.061192038819836],[-144.17342232410294,30.569950882968854],[-149.34707529879068,29.89183008460252],[-152.85043045733752,33.12732053866678],[-158.04649474959947,32.12156651323389],[-161.64707805135708,34.994006697107615],[-159.94762734735153,39.09941640444715],[-163.39292691687498,42.461841701752746],[-168.8876761772056,41.53861492567143],[-173.2513616288856,44.74985555511408],[-179.170112546831,43.33462463706695]],[[-157.6068486027842,20.259691594705036],[-156.08998858841755,24.696711258039056],[-151.04796662686522,25.669243623986258],[-147.69594788211106,22.16693900740581],[-142.7188705783351,22.885971422359724],[-139.6214919325493,19.2239309458196],[-141.37151007296615,14.881959131410003],[-138.42043748614526,11.22287623237951],[-140.12125038010964,6.870649308036964],[-144.72979242136543,6.045591181415267],[-146.33638072286848,1.6772949381945044],[-150.91862197114955,0.7969950664894166],[-154.0294052002189,4.260374459536214],[-158.59967491814012,3.335734857517349],[-161.77338167921764,6.766536253596436],[-160.44607430026895,11.231115019630433],[-163.71455965998953,14.623074892227512],[-162.39694129463984,19.114485874069658],[-157.6068486027842,20.259691594705036]],[[-178.95063664056067,17.74333218723816],[-175.45827111402537,15.285730312483953],[-176.35806599111405,11.05195584369349],[-178.23815999124182,10.46324037683843],[179.77693144202632,9.615942399155198],[176.28993210653294,11.794175727566111],[172.29426677728955,9.978189493251357],[168.53745793093609,12.10200548276957],[168.65279280829242,16.286127926718756],[172.88878640797157,18.30669067889132],[173.23062212965775,22.777763428069576],[177.84694371159145,24.75690942135447],[-178.22376950605553,22.092681232201556],[-178.95063664056067,17.74333218723816]],[[-175.56432922504848,35.741206971176496],[-170.27191812997154,37.14623592274974],[-166.5289282511271,33.96535450751626],[-167.88337203384341,29.62550789823012],[-172.64626329548403,28.20896181794974],[-176.54267313535857,31.148162090824524],[-175.56432922504848,35.741206971176496]]],[[[-137.16670054747664,34.7661254517022],[-136.19839496396796,36.53790229001989],[-135.31985086435014,38.551076772095065],[-138.45029122366302,41.45713981733577],[-143.8463112012841,41.20828589932378],[-147.45009391663316,44.09362423911828],[-153.03739182353243,43.44325276436556],[-154.78487065089823,39.9092677035244],[-151.12386440058128,37.032961967755135],[-145.74636904346727,37.68759229063255],[-142.3232078622538,34.454167617014946],[-137.16670054747664,34.7661254517022]]],[[[-147.80006555587835,9.62874721795654],[-146.16007687374923,14.110797540904425],[-149.3676428224656,17.73753035354521],[-154.25484084592026,16.797013674901503],[-155.7634836482284,12.265823643881989],[-152.5335322367957,8.71898308656318],[-147.80006555587835,9.62874721795654]]]],"type":"MultiPolygon"},"properties":{"fill":"#dc3545","fillOpacity":0.3,"stroke":"#dc3545","strokeWidth":2},"type":"Feature"}],"type":"FeatureCollection"};

    if (!rawData || !rawData.features) {
      console.error('globe_map: Invalid or missing data');
      return;
    }

    
    const featureCollection = {
      type: rawData.type,
      features: rawData.features.map(f => {
        if (f.geometry.type === 'Polygon') {
          return {
            ...f,
            geometry: {
              ...f.geometry,
              coordinates: f.geometry.coordinates.map(ring => ring.slice().reverse())
            }
          };
        } else if (f.geometry.type === 'MultiPolygon') {
          return {
            ...f,
            geometry: {
              ...f.geometry,
              coordinates: f.geometry.coordinates.map(polygon =>
                polygon.map(ring => ring.slice().reverse())
              )
            }
          };
        }
        return f;
      })
    };

    const projection = "orthographic";
    const isGlobe = projection === "orthographic";
    const maxWidth =  400 ;
    const arrowStep =  3 ;

    const container = document.getElementById('globe-gm1');
    const getSize = () => {
      const width = container.offsetWidth || container.clientWidth;
      const w = width > 0 ? Math.min(maxWidth, width) : maxWidth;
      return { width: w, height: isGlobe ? w : w / 2 };
    };

    
    const inputRotate = null;
    const allPoints = [];
    rawData.features.forEach(f => {
      if (f.geometry.type === 'Point') {
        allPoints.push(f.geometry.coordinates);
      } else if (f.geometry.type === 'LineString') {
        allPoints.push(...f.geometry.coordinates);
      } else if (f.geometry.type === 'Polygon') {
        f.geometry.coordinates.forEach(ring => allPoints.push(...ring));
      } else if (f.geometry.type === 'MultiPolygon') {
        f.geometry.coordinates.forEach(polygon =>
          polygon.forEach(ring => allPoints.push(...ring))
        );
      }
    });
    const centroid = allPoints.length > 0
      ? d3.geoCentroid({ type: 'MultiPoint', coordinates: allPoints })
      : [0, 0];
    const centerRotate = inputRotate
      ? [-inputRotate[0], -inputRotate[1], inputRotate[2] ?? 0]
      : [-centroid[0], -centroid[1], 0];
    const size = getSize();
    const localState = { width: size.width, height: size.height };

    
    if (!window.globeMapSync) {
      window.globeMapSync = {
        rotate: centerRotate,
        centerRotate: centerRotate,
        renders: []
      };
    }
    const sync = window.globeMapSync;

    
    if (sync.renders.length === 0) {
      sync.rotate = centerRotate;
      sync.centerRotate = centerRotate;
    }

    if (!window.globeLandData) {
      const landTopo = await (await fetch('https://cdn.jsdelivr.net/npm/world-atlas@2/land-110m.json')).json();
      window.globeLandData = feature(landTopo, landTopo.objects.land);
    }
    const land = window.globeLandData;

    function render() {
      const size = getSize();
      localState.width = size.width;
      localState.height = size.height;

      const marks = [
        Plot.geo(land, { stroke: '#88b', fill: 'none', strokeWidth: 0.8, strokeOpacity: 0.8 }),
        Plot.graticule({ strokeOpacity: 0.06 })
      ];

      if (isGlobe) {
        marks.push(Plot.sphere({ strokeWidth: 2 }));
      } else {
        marks.push(Plot.frame({ strokeWidth: 1 }));
      }

      
      const polygons = {
        type: 'FeatureCollection',
        features: featureCollection.features.filter(f =>
          f.geometry.type === 'Polygon' || f.geometry.type === 'MultiPolygon'
        )
      };
      const lines = {
        type: 'FeatureCollection',
        features: featureCollection.features.filter(f => f.geometry.type === 'LineString')
      };
      const points = {
        type: 'FeatureCollection',
        features: featureCollection.features.filter(f => f.geometry.type === 'Point')
      };

      
      if (polygons.features.length > 0) {
        marks.push(Plot.geo(polygons, {
          fill: d => d.properties?.fill || 'red',
          fillOpacity: d => d.properties?.fillOpacity ?? 0.45,
          stroke: d => d.properties?.stroke || d.properties?.fill || 'red',
          strokeWidth: d => d.properties?.strokeWidth ?? 1,
          strokeOpacity: d => d.properties?.strokeOpacity ?? 0.7
        }));

        
        if (arrowStep > 0) {
          let edgeIndex = 0;
          
          rawData.features.forEach(f => {
            if (f.geometry.type !== 'Polygon' && f.geometry.type !== 'MultiPolygon') return;
            const stroke = f.properties?.stroke || f.properties?.fill || 'red';
            const strokeWidth = f.properties?.strokeWidth ?? 1;
            const rings = f.geometry.type === 'Polygon'
              ? f.geometry.coordinates
              : f.geometry.coordinates.flat();
            rings.forEach(ring => {
              for (let i = 0; i < ring.length - 1; i++) {
                if (edgeIndex % arrowStep === 0) {
                  const interpolate = d3.geoInterpolate(ring[i], ring[i + 1]);
                  marks.push(Plot.line([interpolate(0.45), interpolate(0.55)], {
                    x: d => d[0],
                    y: d => d[1],
                    markerEnd: 'arrow',
                    stroke: 'darkred',
                    strokeWidth: 1.5
                  }));
                }
                edgeIndex++;
              }
            });
          });
        }
      }

      
      if (lines.features.length > 0) {
        marks.push(Plot.geo(lines, {
          stroke: d => d.properties?.stroke || 'red',
          strokeWidth: d => d.properties?.strokeWidth ?? 2.5,
          strokeOpacity: d => d.properties?.strokeOpacity ?? 0.9
        }));

        
        lines.features.forEach(f => {
          if (f.properties?.arrow) {
            const coords = f.geometry.coordinates;
            for (let i = 0; i < coords.length - 1; i++) {
              const interpolate = d3.geoInterpolate(coords[i], coords[i + 1]);
              marks.push(Plot.line([interpolate(0.45), interpolate(0.55)], {
                x: d => d[0],
                y: d => d[1],
                markerEnd: 'arrow',
                stroke: f.properties?.stroke || 'darkred',
                strokeWidth: f.properties?.strokeWidth ?? 2
              }));
            }
          }
        });
      }

      
      points.features.forEach(f => {
        marks.push(Plot.geo(f, {
          fill: f.properties?.fill || 'red',
          stroke: f.properties?.stroke || 'darkred',
          strokeWidth: f.properties?.strokeWidth ?? 1,
          r: f.properties?.r ?? 5
        }));
      });

      const projectionConfig = isGlobe
        ? { type: projection, rotate: sync.rotate, inset: 1 }
        : { type: projection };

      const svg = Plot.plot({
        width: localState.width,
        height: localState.height,
        projection: projectionConfig,
        marks
      });

      container.innerHTML = '';
      container.appendChild(svg);
      if (isGlobe) {
        attachDrag(svg);
      }
    }

    window.addEventListener('resize', render);

    
    const versor = {
      cartesian: function(e) {
        const l = e[0] * Math.PI / 180, p = e[1] * Math.PI / 180, cp = Math.cos(p);
        return [cp * Math.cos(l), cp * Math.sin(l), Math.sin(p)];
      },
      rotation: function(q) {
        return [
          Math.atan2(2 * (q[0] * q[1] + q[2] * q[3]), 1 - 2 * (q[1] * q[1] + q[2] * q[2])) * 180 / Math.PI,
          Math.asin(Math.max(-1, Math.min(1, 2 * (q[0] * q[2] - q[3] * q[1])))) * 180 / Math.PI,
          Math.atan2(2 * (q[0] * q[3] + q[1] * q[2]), 1 - 2 * (q[2] * q[2] + q[3] * q[3])) * 180 / Math.PI
        ];
      },
      delta: function(v0, v1) {
        const w = this.cross(v0, v1), l = Math.sqrt(this.dot(w, w));
        if (!l) return [1, 0, 0, 0];
        const t = Math.acos(Math.max(-1, Math.min(1, this.dot(v0, v1)))) / 2, s = Math.sin(t);
        return [Math.cos(t), w[2] / l * s, -w[1] / l * s, w[0] / l * s];
      },
      multiply: function(a, b) {
        return [
          a[0] * b[0] - a[1] * b[1] - a[2] * b[2] - a[3] * b[3],
          a[0] * b[1] + a[1] * b[0] + a[2] * b[3] - a[3] * b[2],
          a[0] * b[2] - a[1] * b[3] + a[2] * b[0] + a[3] * b[1],
          a[0] * b[3] + a[1] * b[2] - a[2] * b[1] + a[3] * b[0]
        ];
      },
      from: function(r) {
        const l = r[0] / 2 * Math.PI / 180, p = r[1] / 2 * Math.PI / 180, g = r[2] / 2 * Math.PI / 180;
        const sl = Math.sin(l), cl = Math.cos(l);
        const sp = Math.sin(p), cp = Math.cos(p);
        const sg = Math.sin(g), cg = Math.cos(g);
        return [
          cl * cp * cg + sl * sp * sg,
          sl * cp * cg - cl * sp * sg,
          cl * sp * cg + sl * cp * sg,
          cl * cp * sg - sl * sp * cg
        ];
      },
      cross: function(a, b) { return [a[1]*b[2] - a[2]*b[1], a[2]*b[0] - a[0]*b[2], a[0]*b[1] - a[1]*b[0]]; },
      dot: function(a, b) { return a[0]*b[0] + a[1]*b[1] + a[2]*b[2]; }
    };

    function attachDrag(svg) {
      const projection = d3.geoOrthographic()
        .rotate(sync.rotate)
        .translate([localState.width / 2, localState.height / 2])
        .scale(Math.min(localState.width, localState.height) / 2 - 1);

      let v0, q0, r0;

      const drag = d3.drag()
        .on('start', (event) => {
          projection.rotate(sync.rotate).translate([localState.width / 2, localState.height / 2]).scale(Math.min(localState.width, localState.height) / 2 - 1);
          const inv = projection.invert([event.x, event.y]);
          if (inv) {
            v0 = versor.cartesian(inv);
            r0 = sync.rotate;
            q0 = versor.from(r0);
          }
        })
        .on('drag', (event) => {
          if (!v0) return;
          projection.rotate(r0);
          const inv = projection.invert([event.x, event.y]);
          if (!inv) return;
          const v1 = versor.cartesian(inv);
          const delta = versor.delta(v0, v1);
          const q1 = versor.multiply(q0, delta);
          sync.rotate = versor.rotation(q1);
          
          sync.renders.forEach(r => r());
        });

      d3.select(svg).call(drag);
      d3.select(svg).on('dblclick', () => {
        sync.rotate = sync.centerRotate.slice();
        sync.renders.forEach(r => r());
      });
    }

    
    sync.renders.push(render);

    render();
  })();
</script></div><p class=caption>A set of H3 cells maps to three polygons; two with no holes, and one with three holes. Drag the globe to rotate; double click to reset.</p><p>Alternatively, in code, the translation might look like:</p><div style=display:flex;flex-wrap:wrap;justify-content:center;align-items:center;gap:2rem><div><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>cells <span style=color:#666>=</span> [
</span></span><span style=display:flex><span>  <span style=color:#4070a0>&#39;81463ffffffffff&#39;</span>,
</span></span><span style=display:flex><span>  <span style=color:#4070a0>&#39;8146bffffffffff&#39;</span>,
</span></span><span style=display:flex><span>  <span style=color:#4070a0>&#39;81713ffffffffff&#39;</span>,
</span></span><span style=display:flex><span>  <span style=color:#4070a0>&#39;81467ffffffffff&#39;</span>,
</span></span><span style=display:flex><span>  <span style=color:#4070a0>&#39;8147bffffffffff&#39;</span>,
</span></span><span style=display:flex><span>  <span style=color:#666>...</span>
</span></span><span style=display:flex><span>]
</span></span></code></pre></div></div><span style=font-size:2rem>→</span><div><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#062873;font-weight:700>&#34;type&#34;</span>: <span style=color:#4070a0>&#34;MultiPolygon&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#062873;font-weight:700>&#34;coordinates&#34;</span>: [
</span></span><span style=display:flex><span>    [[[<span style=color:#40a070>-179.1</span>, <span style=color:#40a070>43.3</span>], <span>...</span>]],
</span></span><span style=display:flex><span>    [[[<span style=color:#40a070>-137.1</span>, <span style=color:#40a070>34.7</span>], <span>...</span>]],
</span></span><span style=display:flex><span>    [[[<span style=color:#40a070>-147.8</span>, <span style=color:#40a070>9.6</span>], <span>...</span>]]
</span></span><span style=display:flex><span>  ]
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></div></div><p>GeoJSON is just one format we can use for describing spherical polygons,
but the algorithm we cover here is applicable
to any similar format, and its easy to translate between them.
I wrote up my thoughts on <a href=/blog/sphere_poly/>&ldquo;ideal&rdquo; spherical polygons in another post</a>, but to summarize, we want to output spherical polygons such that:</p><ul><li>polygons consist of ordered loops of points on a sphere (lon/lat points)</li><li>polygons have one &ldquo;outer&rdquo; loop, with points oriented in counter-clockwise order, and zero or more &ldquo;inner&rdquo; loops, with points going clockwise (see the image above)</li><li>we can handle &ldquo;large&rdquo; cell sets, where resulting polygons may cross the antimeridian, enclose the poles, or be larger than a hemisphere</li></ul><h1 id=h3-cells-and-edges><a href=#h3-cells-and-edges class=anchor-link>#</a>H3 cells and edges</h1><p>How do we do this translation? Let&rsquo;s start by considering components of
H3 cells and what we can do with them.</p><p>For any H3 cell, we can get the simple polygon of lat/lng points that describe it. In the H3 C library or in the bindings, you can get those points
with the <a href=https://h3geo.org/docs/api/indexing#celltoboundary><code>cellToBoundary()</code></a> function. We <em>could</em> operate on those points, gathering them for each cell, and using them to construct the MultiPolygon boundary, but this <strong>continuous</strong> approach would involve floating point comparisons and error tolerances.
As an alternative, we might look for a <strong>discrete</strong> approach, with discrete objects that are either present or not, can be hashed, and compared for exact, unambiguous equality. The <strong>directed edges</strong> that make up the H3 cell boundary are a great candidate.</p><h2 id=directed-edge-preliminaries><a href=#directed-edge-preliminaries class=anchor-link>##</a>Directed edge preliminaries</h2><p>In H3, a directed edge can be thought of as the boundary between two adjacent cells. Each edge has an <strong>origin</strong> cell and a <strong>destination</strong> cell, which we can
provide to <a href=https://h3geo.org/docs/api/uniedge#cellstodirectededge><code>cellsToDirectedEdge()</code></a> to get the edge index.
We can form the <strong>opposite</strong> or <strong>reversed</strong> edge by swapping the origin and destination cells, or by calling <a href=https://github.com/uber/h3/pull/1098><code>reverseDirectedEdge()</code></a>.</p><p>The convention we&rsquo;ll use in this post will be to plot an arrow along the edge,
with the origin cell on the left (from the arrow&rsquo;s perspective.)</p><p><figure style=text-align:center><img src=code/figs/directed_edge.svg alt style=max-width:400px></figure><p class=caption>An H3 directed edge and its reverse edge. Note the orientation of the arrow with respect to the origin cell.</p></p><p>Also, we can get the lat/lng points that make up the edge from <a href=https://h3geo.org/docs/api/uniedge#directededgetoboundary><code>directedEdgeToBoundary()</code></a>, and they&rsquo;re returned in the order that aligns with the arrow: first point at the tail of the arrow, and last point at the tip. (Note that due to icosahedron distortions, some H3 edges have a &ldquo;kink&rdquo; in them, and thus have three points instead of just two.)</p><p>Plotting the edges for a single H3 hexagon, we see that these components align with <a href=https://gis.stackexchange.com/questions/259944/polygons-and-multipolygons-should-follow-the-right-hand-rule>the right-hand rule for spherical polygons
that GeoJSON conforms to</a>. That is,
if we take the edges in order and extract their lat/lng points, we get a sequence
of points in counter-clockwise order around the cell. Note that the last
point of an edge is the first point of the following edge.</p><figure style=text-align:center><img src=code/figs/single_cell_directed_edges.svg alt style=max-width:400px></figure><p>Note that this almost acheives our goal (at least for a single cell): we can recover a list of lat/lng points in counter-clockwise order denoting the outer
loop of a spherical polygon.</p><p>However, the order of the edges is important. Note that
<a href=https://h3geo.org/docs/api/uniedge#origintodirectededges><code>originToDirectedEdges()</code></a> doesn&rsquo;t automatically return directed edges
in counter-clockwise order, but we can permute them so that that&rsquo;s the case&mdash;and the same permutation works for every H3 cell. We&rsquo;ll get into using
the ordering later on, but for now I&rsquo;ll just note that we hard code the permutation in the PR with something like</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#007020;font-weight:700>static</span> <span style=color:#007020;font-weight:700>const</span> <span style=color:#902000>uint8_t</span> idxh[<span style=color:#40a070>6</span>] <span style=color:#666>=</span> {<span style=color:#40a070>0</span>, <span style=color:#40a070>4</span>, <span style=color:#40a070>3</span>, <span style=color:#40a070>5</span>, <span style=color:#40a070>1</span>, <span style=color:#40a070>2</span>};  <span style=color:#60a0b0;font-style:italic>// hexagons
</span></span></span><span style=display:flex><span><span style=color:#007020;font-weight:700>static</span> <span style=color:#007020;font-weight:700>const</span> <span style=color:#902000>uint8_t</span> idxp[<span style=color:#40a070>5</span>] <span style=color:#666>=</span> {<span style=color:#40a070>0</span>, <span style=color:#40a070>1</span>, <span style=color:#40a070>3</span>, <span style=color:#40a070>2</span>, <span style=color:#40a070>4</span>};     <span style=color:#60a0b0;font-style:italic>// pentagons
</span></span></span></code></pre></div><p>Whenever we&rsquo;re plotting more than one cell, edges will overlap with their opposites. To visually distinguish them in most of the plots below, we&rsquo;ll
shrink the directed edges towards the center of their origin cell:</p><p><figure style=text-align:center><img src=code/figs/two_cells_edges.svg alt style=max-width:400px></figure><p class=caption>Two cells (blue) with their associated directed edges (black/red) shrunk towards the centers to avoid overlaps. Note the symmetric pair of opposite edges (red).</p></p><p>We&rsquo;ll refer to an edge and its reversed edge a <strong>symmetric pair</strong>.</p><h1 id=general-idea-remove-symmetric-pairs><a href=#general-idea-remove-symmetric-pairs class=anchor-link>#</a>General idea: remove symmetric pairs</h1><p>That last image suggest an idea: for a set of cells
<span class=katex><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.6833em></span><span class="mord mathnormal" style=margin-right:.07153em>C</span></span></span></span>, if we get the set of all
of the directed edges with origins belonging to
<span class=katex><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.6833em></span><span class="mord mathnormal" style=margin-right:.07153em>C</span></span></span></span>, we can then remove all
the symmetric pairs (i.e., remove all the &ldquo;internal&rdquo; edges), and what we end up with is the set of directed edges making up the boundary of the polygon we&rsquo;re looking for.</p><div style=display:flex;flex-wrap:wrap;justify-content:center;align-items:center;gap:0><figure style=text-align:center><img src=code/figs/disk_0.svg alt style=max-width:300px></figure><span style=font-size:2rem>→</span><figure style=text-align:center><img src=code/figs/disk_2.svg alt style=max-width:300px></figure></div><p class=caption>Eliminating symmetric pairs of edges leaves us with the set of edges on the boundary.</p><p>Note that, so far, we&rsquo;ve just described how to get the <strong>set</strong> of boundary edges.
There&rsquo;s no notion yet of how we make sure the lat/lng points in the outer boundary are in counter-clockwise order, how we handle holes, or how we figure
out which edges are part of which loop or polygon. We&rsquo;ll get to that below,
but first we&rsquo;ll discuss the cancellation logic. (But do notice that if the edges <em>were</em> put in the correct order, we would have our desired counter-clockwise loop
for this polygon&rsquo;s outer looop.)</p><h2 id=example-one-hole><a href=#example-one-hole class=anchor-link>##</a>Example: one hole</h2><p>Here&rsquo;s the symmetric pair cancellation procedure on another example.
We start with 6 cells, with a center cell missing, and consider the full set of
their edges:<figure style=text-align:center><img src=code/figs/ring_0.svg alt style=max-width:400px></figure><p class=caption>Initial set of edges from six cells, with a central cell missing. Loops initially all counter-clockwise.</p></p><p>Eliminating all symmetric pairs but one leaves us with a single loop in
counter-clockwise order. (This figure doesn&rsquo;t represent the actual locations of the edge endpoints since we&rsquo;ve shrunk them, so it&rsquo;s true that this loop is degenerate in the sense that the symmetric pair of edges exactly overlap one another, but we&rsquo;re OK with that for this intermediate state, since they&rsquo;re about to be removed anyway.)<figure style=text-align:center><img src=code/figs/ring_1.svg alt style=max-width:400px></figure><p class=caption>A (geometrically) degenerate, but intermediate counter-clockwise loop.</p></p><p>When the final symmetric pair is removed, we&rsquo;re left with two rings of edges: one outer loop in counter-clockwise order and one inner loop in clockwise order, denoting the hole missing from the polygon:<figure style=text-align:center><img src=code/figs/ring_2.svg alt style=max-width:400px></figure><p class=caption>An outer loop (counter-clockwise) and one hole loop (clockwise).</p></p><p>The next major sections describe how we recover the additional information
we need (beyond just the unordered set of edges) to describe the polygon.</p><h2 id=implementation-notes-hash-table><a href=#implementation-notes-hash-table class=anchor-link>##</a>Implementation notes: hash table</h2><h3 id=python><a href=#python class=anchor-link>###</a>Python</h3><p>In Python, just getting the set of cells and canceling out the symmetric
pairs is pretty trivial. I would look something like:</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#007020;font-weight:700>import</span> <span style=color:#0e84b5;font-weight:700>h3</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>edges <span style=color:#666>=</span> {
</span></span><span style=display:flex><span>    e
</span></span><span style=display:flex><span>    <span style=color:#007020;font-weight:700>for</span> h <span style=color:#007020;font-weight:700>in</span> cells
</span></span><span style=display:flex><span>    <span style=color:#007020;font-weight:700>for</span> e <span style=color:#007020;font-weight:700>in</span> h3<span style=color:#666>.</span>origin_to_directed_edges(h)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>reversed_edges <span style=color:#666>=</span> {
</span></span><span style=display:flex><span>    h3<span style=color:#666>.</span>reverse_directed_edge(e)
</span></span><span style=display:flex><span>    <span style=color:#007020;font-weight:700>for</span> e <span style=color:#007020;font-weight:700>in</span> edges
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>boundary_edges <span style=color:#666>=</span> edges <span style=color:#666>-</span> reversed_edges
</span></span></code></pre></div><h3 id=c><a href=#c class=anchor-link>###</a>C</h3><p>In <a href=https://github.com/uber/h3/pull/1113>uber/h3 #1113</a>, we need to do a
little more work to set up the hashing we&rsquo;ll use to find the symmetric pairs, and we also need to set up the data structures we&rsquo;ll use to keep track of the
additional information we&rsquo;ll need to create well-formed polygons.</p><p>For each edge, we create an <code>Arc</code> struct to capture all the relevant information
for an edge. We&rsquo;ll only focus on the parts we need for symmetric pair cancellation in this section.</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#007020;font-weight:700>typedef</span> <span style=color:#007020;font-weight:700>struct</span> Arc {
</span></span><span style=display:flex><span>    H3Index id;  <span style=color:#60a0b0;font-style:italic>// directed edge index
</span></span></span><span style=display:flex><span>    <span style=color:#60a0b0;font-style:italic>// ...
</span></span></span><span style=display:flex><span>} Arc;
</span></span></code></pre></div><p>For each cell in the input set, we create its 5 or 6 <code>Arc</code>s and store
them in an <code>ArcSet</code>, so that we can iterate through the <code>Arc</code>/edges later on by
looping through an array.</p><p>In addition to iterating through the <code>Arc</code>s, we&rsquo;ll want to be able to quickly
look them up by their H3 index so that we can remove symmetric pairs.
For this, we create a simple hash table,
corresponding to <code>buckets</code> and <code>numBuckets</code> in <code>ArcSet</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#007020;font-weight:700>typedef</span> <span style=color:#007020;font-weight:700>struct</span> {
</span></span><span style=display:flex><span>    <span style=color:#902000>int64_t</span> numArcs;
</span></span><span style=display:flex><span>    Arc <span style=color:#666>*</span>arcs;
</span></span><span style=display:flex><span>    <span style=color:#902000>int64_t</span> numBuckets;  <span style=color:#60a0b0;font-style:italic>// = 10 * numArcs
</span></span></span><span style=display:flex><span>    Arc <span style=color:#666>**</span>buckets;
</span></span><span style=display:flex><span>} ArcSet;
</span></span></code></pre></div><p>The <code>createArcSet()</code> function initializes the <code>Arc</code>s from an array of H3 cells,
and hashes all the edges for quick random lookup.</p><p>For some <code>Arc</code> called <code>a</code>, we can get a pointer to its reverse edge (if it exists in the set) using <code>findArc</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#06287e>H3_EXPORT</span>(reverseDirectedEdge)(a<span style=color:#666>-&gt;</span>id, <span style=color:#666>&amp;</span>reversedEdge);
</span></span><span style=display:flex><span>Arc <span style=color:#666>*</span>b <span style=color:#666>=</span> <span style=color:#06287e>findArc</span>(arcset, reversedEdge);
</span></span></code></pre></div><p>We use a simple linear probing scheme with <code>numBuckets = 10 * numArcs</code> to keep collisions low. In the future, an improved algorithm could use less memory without sacrificing lookup speed. (Suggestions welcome!)</p><p>After initializing the <code>ArcSet</code>, we can perform the edge cancellation with the C function <code>cancelArcPairs()</code>, which roughly follows the pseudocode:</p><ol><li>loop through the <code>Arc</code>s (that haven&rsquo;t been removed yet) via the <code>ArcSet.arcs</code> array</li><li>for each <code>Arc</code>, <code>a</code>, compute its reversed edge like <code>e_b = reverseDirectedEdge(a.id)</code></li><li>find the corresponding <code>Arc</code> via the hash table with <code>Arc *b = findArc(arcset, e_b)</code></li><li>with both <code>Arc</code>s in hand, we can mark both as removed:<div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>a<span style=color:#666>-&gt;</span>isRemoved <span style=color:#666>=</span> <span style=color:#007020>true</span>;
</span></span><span style=display:flex><span>b<span style=color:#666>-&gt;</span>isRemoved <span style=color:#666>=</span> <span style=color:#007020>true</span>;
</span></span></code></pre></div></li><li>Note that we do some additional work around loops and connected components, but we&rsquo;ll cover that in the upcoming sections.</li></ol><p>The edges remaining afer cancellation (those with <code>isRemoved = false</code>) are the
ones that make up the polygon boundaries.
But note that this logic just amounts to keeping track of the <strong>set</strong> of
boundary edges. Next, we&rsquo;ll discuss the additional structure we need
to keep track of to form the polygons.</p><h1 id=loops-of-edges><a href=#loops-of-edges class=anchor-link>#</a>Loops of edges</h1><p>Above, we found the <strong>set</strong> of edges that make up the polygon boundary.
But how do we construct or maintain the ordering of edges so that we can construct the ordered loops of lat/lng points that make up polygon outer loops
and holes?</p><p>Recall from <a href=#directed-edge-preliminaries>&ldquo;Directed edge preliminaries&rdquo;</a> that we can order the edges of individual cells so that they are in counter-clockwise order:</p><figure style=text-align:center><img src=code/figs/single_cell.svg alt style=max-width:400px></figure><p>To keep track of this ordering each <code>Arc</code> maintains <code>prev</code> and <code>next</code> pointers,
which we use to construct doubly-linked lists of <code>Arc</code>s:</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#007020;font-weight:700>typedef</span> <span style=color:#007020;font-weight:700>struct</span> Arc {
</span></span><span style=display:flex><span>    H3Index id;       <span style=color:#60a0b0;font-style:italic>// directed edge index
</span></span></span><span style=display:flex><span>    <span style=color:#007020;font-weight:700>struct</span> Arc <span style=color:#666>*</span>next;
</span></span><span style=display:flex><span>    <span style=color:#007020;font-weight:700>struct</span> Arc <span style=color:#666>*</span>prev;
</span></span><span style=display:flex><span>    <span style=color:#60a0b0;font-style:italic>// ...
</span></span></span><span style=display:flex><span>} Arc;
</span></span></code></pre></div><p>When we initialize the <code>ArcSet</code> in <code>createArcSet()</code>, we assign the pointers
so that each individual cell corresponds to a separate doubly-linked loop
of edges/<code>Arcs</code>.</p><p>Now, <code>ArcSet</code> starts in a state where we have a set of valid doubly-linked loops.
The big idea is, with each edge pair cancellation, to <strong>maintain that valid
state of linked loops</strong>.</p><p>For example, if we were to start with two neighboring cells, with two disjoint loops, the <code>ArcSet</code> would initially correspond to this picture:</p><figure style=text-align:center><img src=code/figs/two_cells_before.svg alt style=max-width:400px><p class=caption>Initial state of edges for two cells.</p></figure><p>After canceling the pair of edges, the <code>ArcSet</code> would look like this:</p><figure style=text-align:center><img src=code/figs/two_cells_after.svg alt style=max-width:600px><p class=caption>After canceling pairs of edges.</p></figure><p>Note that the edges stay in a counter-clockwise loop. But how do we update the
doubly-linked loops?</p><h2 id=loop-surgery><a href=#loop-surgery class=anchor-link>##</a>Loop surgery</h2><p>When canceling a symmetric pair of edges <code>a</code> and <code>b</code>, we splice them out by reconnecting their neighbors.</p><p>The edges in the loops are initially chained like:</p><span class=katex-display><span class=katex><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:3em;vertical-align:-1.25em></span><span class=mord><span class=mtable><span class=col-align-r><span class="vlist-t vlist-t2"><span class=vlist-r><span class=vlist style=height:1.75em><span style=top:-3.91em><span class=pstrut style=height:3em></span><span class=mord><span class=mord><span class="mord mathnormal">a</span><span class=msupsub><span class=vlist-t><span class=vlist-r><span class=vlist style=height:.8213em><span style=top:-3.113em;margin-right:.05em><span class=pstrut style=height:2.7em></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">−</span></span></span></span></span></span></span></span></span></span><span style=top:-2.41em><span class=pstrut style=height:3em></span><span class=mord><span class=mord><span class="mord mathnormal">b</span><span class=msupsub><span class=vlist-t><span class=vlist-r><span class=vlist style=height:.8213em><span style=top:-3.113em;margin-right:.05em><span class=pstrut style=height:2.7em></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">−</span></span></span></span></span></span></span></span></span></span></span><span class=vlist-s>​</span></span><span class=vlist-r><span class=vlist style=height:1.25em><span></span></span></span></span></span><span class=col-align-l><span class="vlist-t vlist-t2"><span class=vlist-r><span class=vlist style=height:1.75em><span style=top:-3.91em><span class=pstrut style=height:3em></span><span class=mord><span class=mord></span><span class=mspace style=margin-right:.2778em></span><span class=mrel>→</span><span class=mspace style=margin-right:.2778em></span><span class="mord mathnormal">a</span><span class=mspace style=margin-right:.2778em></span><span class=mrel>→</span><span class=mspace style=margin-right:.2778em></span><span class=mord><span class="mord mathnormal">a</span><span class=msupsub><span class=vlist-t><span class=vlist-r><span class=vlist style=height:.8213em><span style=top:-3.113em;margin-right:.05em><span class=pstrut style=height:2.7em></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">+</span></span></span></span></span></span></span></span></span></span><span style=top:-2.41em><span class=pstrut style=height:3em></span><span class=mord><span class=mord></span><span class=mspace style=margin-right:.2778em></span><span class=mrel>→</span><span class=mspace style=margin-right:.2778em></span><span class="mord mathnormal">b</span><span class=mspace style=margin-right:.2778em></span><span class=mrel>→</span><span class=mspace style=margin-right:.2778em></span><span class=mord><span class="mord mathnormal">b</span><span class=msupsub><span class=vlist-t><span class=vlist-r><span class=vlist style=height:.8213em><span style=top:-3.113em;margin-right:.05em><span class=pstrut style=height:2.7em></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">+</span></span></span></span></span></span></span></span></span></span></span><span class=vlist-s>​</span></span><span class=vlist-r><span class=vlist style=height:1.25em><span></span></span></span></span></span></span></span></span></span></span></span><p>which we can also see in the two cell diagram:</p><p><figure style=text-align:center><img src=code/figs/two_cells_before_labels.svg alt style=max-width:400px></figure><p class=caption>Two loops and the relevant edges before surgery.</p></p><p>After removing edges <code>a</code> and <code>b</code>, we recconect their surrounding edges like
the following, which merges the two loops into one counter-clockwise loop,
updating the doubly-linked list appropriately.</p><span class=katex-display><span class=katex><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:3em;vertical-align:-1.25em></span><span class=mord><span class=mtable><span class=col-align-r><span class="vlist-t vlist-t2"><span class=vlist-r><span class=vlist style=height:1.75em><span style=top:-3.91em><span class=pstrut style=height:3em></span><span class=mord><span class=mord><span class="mord mathnormal">a</span><span class=msupsub><span class=vlist-t><span class=vlist-r><span class=vlist style=height:.8213em><span style=top:-3.113em;margin-right:.05em><span class=pstrut style=height:2.7em></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">−</span></span></span></span></span></span></span></span></span></span><span style=top:-2.41em><span class=pstrut style=height:3em></span><span class=mord><span class=mord><span class="mord mathnormal">b</span><span class=msupsub><span class=vlist-t><span class=vlist-r><span class=vlist style=height:.8213em><span style=top:-3.113em;margin-right:.05em><span class=pstrut style=height:2.7em></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">−</span></span></span></span></span></span></span></span></span></span></span><span class=vlist-s>​</span></span><span class=vlist-r><span class=vlist style=height:1.25em><span></span></span></span></span></span><span class=col-align-l><span class="vlist-t vlist-t2"><span class=vlist-r><span class=vlist style=height:1.75em><span style=top:-3.91em><span class=pstrut style=height:3em></span><span class=mord><span class=mord></span><span class=mspace style=margin-right:.2778em></span><span class=mrel>→</span><span class=mspace style=margin-right:.2778em></span><span class=mord><span class="mord mathnormal">b</span><span class=msupsub><span class=vlist-t><span class=vlist-r><span class=vlist style=height:.8213em><span style=top:-3.113em;margin-right:.05em><span class=pstrut style=height:2.7em></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">+</span></span></span></span></span></span></span></span></span></span><span style=top:-2.41em><span class=pstrut style=height:3em></span><span class=mord><span class=mord></span><span class=mspace style=margin-right:.2778em></span><span class=mrel>→</span><span class=mspace style=margin-right:.2778em></span><span class=mord><span class="mord mathnormal">a</span><span class=msupsub><span class=vlist-t><span class=vlist-r><span class=vlist style=height:.8213em><span style=top:-3.113em;margin-right:.05em><span class=pstrut style=height:2.7em></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">+</span></span></span></span></span></span></span></span></span></span></span><span class=vlist-s>​</span></span><span class=vlist-r><span class=vlist style=height:1.25em><span></span></span></span></span></span></span></span></span></span></span></span><p><figure style=text-align:center><img src=code/figs/two_cells_after_labels.svg alt style=max-width:400px></figure><p class=caption>The resulting single loop after surgery.</p></p><p>In the C code, this looks like the following, where <code>a</code> and <code>b</code> are <code>Arc</code> structs:</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>a<span style=color:#666>-&gt;</span>next<span style=color:#666>-&gt;</span>prev <span style=color:#666>=</span> b<span style=color:#666>-&gt;</span>prev;
</span></span><span style=display:flex><span>a<span style=color:#666>-&gt;</span>prev<span style=color:#666>-&gt;</span>next <span style=color:#666>=</span> b<span style=color:#666>-&gt;</span>next;
</span></span><span style=display:flex><span>b<span style=color:#666>-&gt;</span>next<span style=color:#666>-&gt;</span>prev <span style=color:#666>=</span> a<span style=color:#666>-&gt;</span>prev;
</span></span><span style=display:flex><span>b<span style=color:#666>-&gt;</span>prev<span style=color:#666>-&gt;</span>next <span style=color:#666>=</span> a<span style=color:#666>-&gt;</span>next;
</span></span></code></pre></div><h3 id=example-four-cells><a href=#example-four-cells class=anchor-link>###</a>Example: four cells</h3><p>Luckily, the loop surgery logic above works in all possible cases and in any order. Consider the following sequence of symmetric pair removals. Since we&rsquo;ve already seen it, we start with two pairs of cells with the common edges removed:</p><p><figure style=text-align:center><img src=code/figs/four_cells_0.svg alt style=max-width:400px></figure><figure style=text-align:center><img src=code/figs/four_cells_1.svg alt style=max-width:400px></figure><figure style=text-align:center><img src=code/figs/four_cells_2.svg alt style=max-width:400px></figure><figure style=text-align:center><img src=code/figs/four_cells_3.svg alt style=max-width:400px></figure></p><p>Note that we can <strong>remove edges in any order</strong>. The following is
a completely valid set of two linked-loops (even though the edges in the middle don&rsquo;t enclose any area and will need to be ultimately removed before we form proper polygons):</p><figure style=text-align:center><img src=code/figs/four_cells_4.svg alt style=max-width:400px></figure><h3 id=example-disk><a href=#example-disk class=anchor-link>###</a>Example: disk</h3><figure style=text-align:center><img src=code/figs/disk_0.svg alt style=max-width:400px></figure><p>Removing the edges associated with the center cell leaves a single
ring (with 6 degenerate pairs left to be removed):<figure style=text-align:center><img src=code/figs/disk_1.svg alt style=max-width:400px></figure></p><figure style=text-align:center><img src=code/figs/disk_2.svg alt style=max-width:400px></figure><h3 id=example-hole><a href=#example-hole class=anchor-link>###</a>Example: hole</h3><p>Note that canceling edges might split up rings:</p><p><figure style=text-align:center><img src=code/figs/ring_0.svg alt style=max-width:400px></figure><figure style=text-align:center><img src=code/figs/ring_1.svg alt style=max-width:400px></figure><figure style=text-align:center><img src=code/figs/ring_2.svg alt style=max-width:400px></figure></p><p>Also note that the inner hole of this polygon has the desired clockwise orientation.</p><h2 id=implementation-notes-doubly-linked-loops><a href=#implementation-notes-doubly-linked-loops class=anchor-link>##</a>Implementation notes: doubly-linked loops</h2><p>In <a href=https://github.com/uber/h3/pull/1113>uber/h3 #1113</a>, we initialize the edges from cells in <code>createArcSet()</code>,
and the <code>cellToEdgeArcs()</code> function puts the edges in the proper
order for each cell and connects them in the doubly-linked loop.</p><p>In <code>cancelArcPairs()</code>, we perform the linked-loop surgery operation
for each symmetric pair that we find.</p><h1 id=connected-components-partition-loops-into-polygons><a href=#connected-components-partition-loops-into-polygons class=anchor-link>#</a>Connected components partition loops into polygons</h1><p>So far we have the outer boundary of our polygons, along with the holes,
and we have the loops of edges in the proper order.</p><p>But how do we keep track of which loops (outer and holes) belong to which polygon? Recall the example with three polygons from the top of the page. It has
six loops total, across three polygons, but can we determine the grouping?</p><p><figure style=text-align:center><img src=code/figs/conn_comp_white.svg alt style=max-width:800px></figure><p class=caption>Six loops, each belonging to one of three polygons. Which loops group together into a polygon?</p></p><p>The key insight is that <strong>removing a symmetric pair of edges joins their cells&rsquo; connected components</strong>. We track this with a <a href=https://en.wikipedia.org/wiki/Disjoint-set_data_structure>union-find data structure</a>: when we cancel an edge pair, we union the components of the two adjacent cells.</p><p>Initially, each cell is its own component:</p><figure style=text-align:center><img src=code/figs/conn_comp_colors_0.svg alt style=max-width:800px></figure><p>As we remove symmetric pairs, components merge:</p><p><figure style=text-align:center><img src=code/figs/conn_comp_colors_1.svg alt style=max-width:800px></figure><figure style=text-align:center><img src=code/figs/conn_comp_colors_2.svg alt style=max-width:800px></figure><figure style=text-align:center><img src=code/figs/conn_comp_colors_3.svg alt style=max-width:800px></figure><figure style=text-align:center><img src=code/figs/conn_comp_colors_4.svg alt style=max-width:800px></figure></p><p>After all symmetric pairs are removed, the remaining components correspond exactly to the polygons we want to output. Loops belonging to the same polygon (both outer and holes) share the same connected component:</p><p><figure style=text-align:center><img src=code/figs/conn_comp_colors_5.svg alt style=max-width:800px></figure><p class=caption>Three connected components, each corresponding to a polygon. The loops within each component form one polygon's outer boundary and holes.</p></p><p>Note that at this stage we know <em>which</em> loops belong together, but we don&rsquo;t yet know which loop is the outer boundary versus which are holes. We&rsquo;ll address that in the next section.</p><h2 id=implementation-notes-union-find><a href=#implementation-notes-union-find class=anchor-link>##</a>Implementation notes: union-find</h2><p>In <a href=https://github.com/uber/h3/pull/1113>uber/h3 #1113</a>, each <code>Arc</code> stores the union-find state directly:</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#007020;font-weight:700>typedef</span> <span style=color:#007020;font-weight:700>struct</span> Arc {
</span></span><span style=display:flex><span>    H3Index id;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#902000>bool</span> isVisited;
</span></span><span style=display:flex><span>    <span style=color:#902000>bool</span> isRemoved;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#60a0b0;font-style:italic>// For doubly-linked list of edges in loop
</span></span></span><span style=display:flex><span>    <span style=color:#007020;font-weight:700>struct</span> Arc <span style=color:#666>*</span>next;
</span></span><span style=display:flex><span>    <span style=color:#007020;font-weight:700>struct</span> Arc <span style=color:#666>*</span>prev;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#60a0b0;font-style:italic>// For union-find data structure
</span></span></span><span style=display:flex><span>    <span style=color:#007020;font-weight:700>struct</span> Arc <span style=color:#666>*</span>parent;
</span></span><span style=display:flex><span>    <span style=color:#902000>int64_t</span> rank;
</span></span><span style=display:flex><span>} Arc;
</span></span></code></pre></div><p>The <code>parent</code> and <code>rank</code> fields implement the <a href=https://en.wikipedia.org/wiki/Disjoint-set_data_structure>union-find data structure</a>. Two functions handle the core operations:</p><ul><li><code>getRoot(Arc *arc)</code> finds the root of an <code>Arc</code>&rsquo;s connected component, using path compression for efficiency</li><li><code>unionArcs(Arc *a, Arc *b)</code> merges two components using union-by-rank</li></ul><p>We identify each connected component by one arbitrary edge ID—specifically, the <code>id</code> field of the root <code>Arc</code>. When we cancel a symmetric pair of edges in <code>cancelArcPairs()</code>, we call <code>unionArcs()</code> to merge the components of the two adjacent cells. After all cancellations, loops sharing the same root belong to the same polygon.</p><h1 id=which-loop-is-outside><a href=#which-loop-is-outside class=anchor-link>#</a>Which loop is &ldquo;outside&rdquo;?</h1><p>In a polygon, one loop is <em>special</em>. The outer loop. the rest are holes.
Actually, not relaly that special. any loop can be the outer loop and still mathematical describe the same polygon, even if it is an unintuitive format.</p><p>a tricky one might look like: blah</p><h1 id=code-overview><a href=#code-overview class=anchor-link>#</a>Code overview</h1><ul><li>this function does this&mldr;</li><li>that function does that</li></ul><h1 id=notes><a href=#notes class=anchor-link>#</a>Notes</h1><ul><li>maybe do a <strong>Summary</strong> section at the end of each, and also a <strong>Code</strong> section, that might ligthen it up? or is it helpful to have the code snippets in the doc inline?</li><li>separate out with Code section. can link multiple implementations. include the python one</li><li>end with some fun, tricky examples</li></ul></content><p></p></main><footer>© 2025 AJ Friend · Made with <a href=https://github.com/janraasch/hugo-bearblog/>Hugo ʕ•ᴥ•ʔ Bear</a></footer></body></html>