<!doctype html><html lang=en-us><head><meta http-equiv=X-Clacks-Overhead content="GNU Terry Pratchett"><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>[WIP] Making H3's cells-to-polygon faster | AJ Friend</title><meta name=title content="[WIP] Making H3's cells-to-polygon faster"><meta name=description content="Note: This post is currently a quick-and-dirty attempt at explaining the algorithm
behind cellsToMultiPolygon core algorithm #1113 · uber/h3. My plan is to grow this into a
proper blog post with more context, background, etc.
Goal: H3 cells to spherical polygons
A collection of H3 cells describes a subset of the globe,
and a common operation is to translate that set of cells into spherical polygons
(e.g., a GeoJSON MultiPolygon) outlining the same region."><meta name=keywords content><meta property="og:url" content="https://ajfriend.com/blog/cells_to_poly/"><meta property="og:site_name" content="AJ Friend"><meta property="og:title" content="[WIP] Making H3's cells-to-polygon faster"><meta property="og:description" content="Note: This post is currently a quick-and-dirty attempt at explaining the algorithm behind cellsToMultiPolygon core algorithm #1113 · uber/h3. My plan is to grow this into a proper blog post with more context, background, etc.
Goal: H3 cells to spherical polygons A collection of H3 cells describes a subset of the globe, and a common operation is to translate that set of cells into spherical polygons (e.g., a GeoJSON MultiPolygon) outlining the same region."><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="blog"><meta property="article:published_time" content="2026-01-09T00:00:00+00:00"><meta property="article:modified_time" content="2026-01-09T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="[WIP] Making H3's cells-to-polygon faster"><meta name=twitter:description content="Note: This post is currently a quick-and-dirty attempt at explaining the algorithm behind cellsToMultiPolygon core algorithm #1113 · uber/h3. My plan is to grow this into a proper blog post with more context, background, etc.
Goal: H3 cells to spherical polygons A collection of H3 cells describes a subset of the globe, and a common operation is to translate that set of cells into spherical polygons (e.g., a GeoJSON MultiPolygon) outlining the same region."><meta itemprop=name content="[WIP] Making H3's cells-to-polygon faster"><meta itemprop=description content="Note: This post is currently a quick-and-dirty attempt at explaining the algorithm behind cellsToMultiPolygon core algorithm #1113 · uber/h3. My plan is to grow this into a proper blog post with more context, background, etc.
Goal: H3 cells to spherical polygons A collection of H3 cells describes a subset of the globe, and a common operation is to translate that set of cells into spherical polygons (e.g., a GeoJSON MultiPolygon) outlining the same region."><meta itemprop=datePublished content="2026-01-09T00:00:00+00:00"><meta itemprop=dateModified content="2026-01-09T00:00:00+00:00"><meta itemprop=wordCount content="1281"><meta name=referrer content="no-referrer-when-downgrade"><style>:root{--width:720px;--font-main:Verdana, sans-serif;--font-secondary:Verdana, sans-serif;--font-scale:1em;--background-color:#fff;--heading-color:#222;--text-color:#444;--link-color:#3273dc;--visited-color:#8b6fcb;--blockquote-color:#222}@media(prefers-color-scheme:dark){:root{--background-color:#01242e;--heading-color:#eee;--text-color:#ddd;--link-color:#8cc2dd;--visited-color:#8b6fcb;--blockquote-color:#ccc}}body{font-family:var(--font-secondary);font-size:var(--font-scale);margin:auto;padding:20px;max-width:var(--width);text-align:left;background-color:var(--background-color);word-wrap:break-word;overflow-wrap:break-word;line-height:1.5;color:var(--text-color)}h1,h2,h3,h4,h5,h6{font-family:var(--font-main);color:var(--heading-color)}a{color:var(--link-color);cursor:pointer;text-decoration:none}a:hover{text-decoration:underline}nav a{margin-right:8px}strong,b{color:var(--heading-color)}button{margin:0;cursor:pointer}time{font-family:monospace;font-style:normal;font-size:15px}main{line-height:1.6}table{width:100%}hr{border:0;border-top:1px dashed}img{max-width:100%}code{font-family:monospace;padding:2px;border-radius:3px}blockquote{border-left:1px solid #999;color:var(--blockquote-color);padding-left:20px;font-style:italic}footer{padding:25px 0;text-align:center}.title:hover{text-decoration:none}.title h1{font-size:1.5em}.inline{width:auto!important}.highlight,.code{border-radius:3px;margin-block-start:1em;margin-block-end:1em;overflow-x:auto}ul.blog-posts{list-style-type:none;padding:unset}ul.blog-posts li{display:flex}ul.blog-posts li span{flex:0 0 130px}ul.blog-posts li a:visited{color:var(--visited-color)}</style><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.css integrity=sha384-nB0miv6/jRmo5UMMR1wu3Gz6NLsoTkbqJghGIsx//Rlm+ZU03BU6SQNC66uf4l5+ crossorigin=anonymous><style>:root{--width:900px}p.caption{text-align:center;font-size:small;font-style:italic;margin-top:-1rem}h1.page-title{font-size:2.2rem;color:#111;margin-bottom:.2rem;border-bottom:2px solid #3273dc;padding-bottom:.3rem}content h1{font-size:1.6rem;color:#333;margin-top:2rem}nav.toc{background:#f8f8f8;padding:1rem 1.5rem;margin-bottom:2rem;border-radius:4px}nav.toc h2{margin-top:0;font-size:1.1rem}nav.toc ul{margin:0;padding-left:1.5rem}nav.toc li{margin:.3rem 0}nav.toc a{text-decoration:none}nav.toc a:hover{text-decoration:underline}.highlight{background:#f6f8fa;border:1px solid #e1e4e8;border-radius:6px;margin:1.5rem 0;overflow-x:auto}.highlight pre{margin:0;padding:.1rem 1rem;background:0 0}.highlight code{font-size:.9rem;line-height:1.5;font-family:sf mono,Consolas,liberation mono,Menlo,monospace}.highlight .ln{color:#999;margin-right:1rem;user-select:none}code:not(.highlight code){background:#f0f0f0;padding:.15rem .4rem;border-radius:3px;font-size:.88em;font-family:sf mono,Consolas,liberation mono,Menlo,monospace}@media(prefers-color-scheme:dark){:root{--background-color:#fff;--heading-color:#222;--text-color:#444;--link-color:#3273dc;--visited-color:#8b6fcb;--blockquote-color:#222}}</style></head><body><header><a href=/ class=title><h2>AJ Friend</h2></a><nav><a href=/>Home</a>
<a href=/blog>Blog</a>
<a href=/software>Software</a>
<a href=/notes>Notes</a></nav></header><main><h1 class=page-title>[WIP] Making H3's cells-to-polygon faster</h1><p><i><time datetime=2026-01-09>2026-01-09</time></i></p><nav class=toc><h2>Contents</h2><nav id=TableOfContents><ul><li><a href=#goal-h3-cells-to-spherical-polygons>Goal: H3 cells to spherical polygons</a></li><li><a href=#h3-edges>H3 edges</a></li><li><a href=#general-idea-cancel-out-the-edges>General idea: cancel out the edges</a></li><li><a href=#rings-of-edges>Rings of edges</a></li><li><a href=#edge-cancellation>Edge cancellation</a><ul><li><a href=#finding-edge-pairs>Finding edge pairs</a></li><li><a href=#loop-surgery>Loop surgery</a></li><li><a href=#other-edge-cancellation-examples>Other edge cancellation examples</a><ul><li><a href=#disk>Disk</a></li><li><a href=#hole>Hole</a></li></ul></li></ul></li><li><a href=#connected-components-partition-loops-into-polygons>Connected components partition loops into polygons</a></li><li><a href=#which-loop-is-outside>Which loop is &ldquo;outside&rdquo;?</a></li><li><a href=#notes>Notes</a></li></ul></nav></nav><content><p><strong>Note</strong>: This post is currently a quick-and-dirty attempt at explaining the algorithm
behind <a href=https://github.com/uber/h3/pull/1113>cellsToMultiPolygon core algorithm #1113 · uber/h3</a>. My plan is to grow this into a
proper blog post with more context, background, etc.</p><h1 id=goal-h3-cells-to-spherical-polygons>Goal: H3 cells to spherical polygons</h1><p>A collection of <a href=https://h3geo.org/>H3 cells</a> describes a subset of the globe,
and a common operation is to translate that set of cells into spherical polygons
(e.g., a <a href=https://geojson.org/>GeoJSON</a> <code>MultiPolygon</code>) outlining the same region.</p><div style=display:flex;flex-wrap:wrap;justify-content:center;align-items:center;gap:1rem><div class=globe-container id=globe-gm0 style="max-width:400px;width:100%;aspect-ratio:1;margin:2em auto"></div><script type=module>
  import * as Plot from 'https://cdn.jsdelivr.net/npm/@observablehq/plot@0.6/+esm';
  import * as d3 from 'https://cdn.jsdelivr.net/npm/d3@7/+esm';
  import { feature } from 'https://cdn.jsdelivr.net/npm/topojson-client@3/+esm';

  (async function() {
    const rawData = {"features":[{"geometry":{"coordinates":[[[[-164.45647827941468,26.67326523622734],[-166.75703720202299,28.616915453971142],[-167.88337203384341,29.62550789823012],[-172.64626329548403,28.20896181794974],[-173.6703874763115,23.782822700979136],[-171.3530255445717,21.94669609285208],[-170.26790510748518,20.964113606206052],[-165.75801721847134,22.310289219453917],[-164.45647827941468,26.67326523622734]]],[[[-178.22376950605553,22.092681232201556],[-178.95063664056067,17.74333218723816],[-175.4582711140254,15.28573031248396],[-171.35903250000365,16.594714504739436],[-170.26790510748518,20.964113606206052],[-171.3530255445717,21.946696092852083],[-173.6703874763115,23.782822700979136],[-178.22376950605553,22.092681232201556]]],[[[-168.1728875957565,13.44560433788435],[-171.35903250000365,16.594714504739436],[-175.45827111402537,15.285730312483953],[-176.35806599111405,11.05195584369349],[-173.38014762578527,7.9727938308414075],[-169.2931299839693,9.060308038526603],[-168.1728875957565,13.44560433788435]]],[[[-156.08998858841755,24.696711258039056],[-159.5659720311805,27.919872272760344],[-164.45647827941468,26.67326523622734],[-165.75801721847134,22.310289219453917],[-162.39694129463984,19.114485874069658],[-157.6068486027842,20.259691594705036],[-156.08998858841755,24.696711258039056]]],[[[178.4754053347224,29.376139351007172],[177.84694371159145,24.75690942135447],[-178.22376950605553,22.092681232201556],[-173.6703874763115,23.782822700979136],[-172.64626329548403,28.20896181794974],[-176.54267313535857,31.148162090824524],[178.4754053347224,29.376139351007172]]],[[[179.77693144202632,9.615942399155198],[179.2171608248945,5.88992175431389],[-178.02519665249852,2.9040374505798114],[-174.31673738369324,3.8210244943304374],[-173.38014762578527,7.9727938308414075],[-176.35806599111405,11.05195584369349],[-178.23815999124182,10.46324037683843],[179.77693144202632,9.615942399155198]]],[[[179.77693144202632,9.615942399155198],[176.28993210653294,11.794175727566111],[172.29426677728955,9.978189493251357],[172.03418236939353,6.172978893164637],[175.46041201203371,4.248592317017825],[179.21716082489448,5.889921754313911],[179.77693144202632,9.615942399155198]]],[[[168.65279280829242,16.286127926718756],[172.88878640797157,18.30669067889132],[173.23062212965775,22.777763428069576],[168.91929058653923,25.257056432213375],[164.45727251367725,23.004725058862295],[164.53519134064652,18.52280839538614],[168.65279280829242,16.286127926718756]]],[[[178.4754053347224,29.376139351007172],[174.02804175387834,32.1119243692579],[169.07436240121478,29.9547386287809],[168.91929058653923,25.257056432213375],[173.23062212965775,22.777763428069576],[177.84694371159145,24.75690942135447],[178.4754053347224,29.376139351007172]]],[[[164.67056230846524,10.175448079467838],[168.53745793093609,12.10200548276957],[168.65279280829242,16.286127926718756],[164.53519134064652,18.52280839538614],[160.52670878987635,16.340968799924067],[160.7733897026288,12.194726726168003],[164.67056230846524,10.175448079467838]]],[[[164.67056230846524,10.175448079467838],[164.7007803629394,8.237083943199265],[164.93539603741021,6.119591258608642],[168.3352524578736,4.467031609784524],[172.03418236939353,6.172978893164637],[172.29426677728955,9.978189493251357],[168.53745793093609,12.10200548276957],[164.67056230846524,10.175448079467838]]],[[[-167.31261713417402,1.5147974903819574],[-166.16940101623453,5.767146686378417],[-169.2931299839693,9.060308038526603],[-173.38014762578527,7.9727938308414075],[-174.31673738369324,3.8210244943304374],[-171.37544324872502,0.649870565576401],[-167.31261713417402,1.5147974903819574]]],[[[-167.31261713417402,1.5147974903819574],[-164.25615857265893,-1.7743965588128086],[-159.93112334382027,-0.9446533902388665],[-158.59967491814012,3.335734857517349],[-161.77338167921764,6.766536253596436],[-166.16940101623453,5.767146686378417],[-167.31261713417402,1.5147974903819574]]],[[[-175.56432922504848,35.741206971176496],[179.9534193241767,38.728779390762334],[174.49688633843544,36.85680682151307],[174.02804175387834,32.1119243692579],[178.4754053347224,29.376139351007172],[-176.54267313535857,31.148162090824524],[-175.56432922504848,35.741206971176496]]],[[[-168.8876761772056,41.53861492567143],[-170.27191812997154,37.14623592274974],[-166.5289282511271,33.96535450751626],[-161.64707805135708,34.994006697107615],[-159.94762734735153,39.09941640444715],[-163.39292691687498,42.461841701752746],[-168.8876761772056,41.53861492567143]]],[[[-166.5289282511271,33.96535450751626],[-167.88337203384341,29.62550789823012],[-166.75703720202299,28.616915453971142],[-164.45647827941468,26.67326523622734],[-159.5659720311805,27.919872272760344],[-158.04649474959947,32.12156651323389],[-161.64707805135708,34.9940066971076],[-166.5289282511271,33.96535450751626]]],[[[-168.8876761772056,41.53861492567143],[-173.2513616288856,44.74985555511408],[-179.170112546831,43.33462463706695],[179.9534193241767,38.728779390762334],[-175.56432922504848,35.741206971176496],[-170.27191812997154,37.14623592274974],[-168.8876761772056,41.53861492567143]]],[[[-156.08998858841755,24.696711258039056],[-151.04796662686522,25.669243623986258],[-149.34707529879068,29.89183008460252],[-152.85043045733752,33.12732053866678],[-158.04649474959947,32.12156651323389],[-159.5659720311805,27.919872272760344],[-156.08998858841755,24.696711258039056]]],[[[-151.04796662686522,25.669243623986258],[-147.69594788211106,22.16693900740581],[-142.7188705783351,22.885971422359724],[-140.91889130500928,27.061192038819836],[-144.17342232410294,30.569950882968854],[-149.34707529879068,29.89183008460252],[-151.04796662686522,25.669243623986258]]],[[[-140.91889130500928,27.061192038819836],[-142.7188705783351,22.885971422359724],[-139.6214919325493,19.2239309458196],[-134.89965579269537,19.7532105149965],[-133.08381598345164,23.820431161854447],[-135.98689147817444,27.469138609544558],[-140.91889130500928,27.061192038819836]]],[[[-133.89520751564908,11.884131145297399],[-132.14080471892913,16.072271835802038],[-134.89965579269537,19.7532105149965],[-139.6214919325493,19.2239309458196],[-141.37151007296615,14.881959131410003],[-138.42043748614526,11.22287623237951],[-133.89520751564908,11.884131145297399]]],[[[-133.89520751564908,11.884131145297399],[-138.42043748614526,11.22287623237951],[-140.12125038010964,6.870649308036964],[-137.3063271216714,3.372828505596593],[-132.96499017492758,4.158942627265325],[-131.26895225504,8.320295172124068],[-133.89520751564908,11.884131145297399]]],[[[-159.93112334382027,-0.9446533902388665],[-156.8531091350144,-4.259065522271725],[-152.3980821982831,-3.4345808068957697],[-150.91862197114955,0.7969950664894166],[-154.0294052002189,4.260374459536214],[-158.59967491814012,3.335734857517349],[-159.93112334382027,-0.9446533902388665]]],[[[-143.3961790952625,-1.706579969821454],[-138.95903110794228,-0.8353130739527114],[-137.3063271216714,3.372828505596593],[-140.12125038010964,6.870649308036964],[-144.72979242136543,6.045591181415267],[-146.33638072286848,1.6772949381945044],[-143.3961790952625,-1.706579969821454]]],[[[-144.9683236097968,-5.820413131280587],[-143.3961790952625,-1.706579969821454],[-146.33638072286848,1.6772949381945044],[-150.91862197114955,0.7969950664894166],[-152.3980821982831,-3.4345808068957697],[-149.4028814909321,-6.672537737437516],[-144.9683236097968,-5.820413131280587]]],[[[-155.7634836482284,12.265823643881989],[-152.5335322367957,8.71898308656318],[-147.80006555587835,9.62874721795654],[-146.16007687374923,14.110797540904425],[-149.3676428224656,17.73753035354521],[-154.25484084592026,16.797013674901503],[-155.7634836482284,12.265823643881989]]],[[[-153.03739182353243,43.44325276436556],[-154.78487065089823,39.9092677035244],[-151.12386440058128,37.032961967755135],[-145.74636904346727,37.68759229063255],[-143.8463112012841,41.20828589932378],[-147.45009391663316,44.09362423911828],[-153.03739182353243,43.44325276436556]]],[[[-142.3232078622538,34.454167617014946],[-137.16670054747664,34.7661254517022],[-136.19839496396796,36.53790229001989],[-135.31985086435014,38.551076772095065],[-138.45029122366302,41.45713981733577],[-143.8463112012841,41.20828589932378],[-145.74636904346727,37.68759229063255],[-142.3232078622538,34.454167617014946]]],[[[-168.1728875957565,13.44560433788435],[-163.71455965998953,14.623074892227512],[-162.39694129463984,19.114485874069658],[-165.75801721847134,22.310289219453917],[-170.26790510748518,20.964113606206052],[-171.35903250000365,16.594714504739436],[-168.1728875957565,13.44560433788435]]],[[[-168.1728875957565,13.44560433788435],[-169.2931299839693,9.060308038526603],[-166.16940101623453,5.767146686378417],[-161.77338167921764,6.766536253596436],[-160.44607430026895,11.231115019630433],[-163.71455965998953,14.623074892227512],[-168.1728875957565,13.44560433788435]]]],"type":"MultiPolygon"},"properties":{"fill":"#3273dc","fillOpacity":0.3,"stroke":"#3273dc","strokeWidth":2},"type":"Feature"}],"type":"FeatureCollection"};

    if (!rawData || !rawData.features) {
      console.error('globe_map: Invalid or missing data');
      return;
    }

    
    const featureCollection = {
      type: rawData.type,
      features: rawData.features.map(f => {
        if (f.geometry.type === 'Polygon') {
          return {
            ...f,
            geometry: {
              ...f.geometry,
              coordinates: f.geometry.coordinates.map(ring => ring.slice().reverse())
            }
          };
        } else if (f.geometry.type === 'MultiPolygon') {
          return {
            ...f,
            geometry: {
              ...f.geometry,
              coordinates: f.geometry.coordinates.map(polygon =>
                polygon.map(ring => ring.slice().reverse())
              )
            }
          };
        }
        return f;
      })
    };

    const projection = "orthographic";
    const isGlobe = projection === "orthographic";
    const maxWidth =  400 ;
    const arrowStep =  0 ;

    const container = document.getElementById('globe-gm0');
    const getSize = () => {
      const width = container.offsetWidth || container.clientWidth;
      const w = width > 0 ? Math.min(maxWidth, width) : maxWidth;
      return { width: w, height: isGlobe ? w : w / 2 };
    };

    
    const inputRotate = null;
    const allPoints = [];
    rawData.features.forEach(f => {
      if (f.geometry.type === 'Point') {
        allPoints.push(f.geometry.coordinates);
      } else if (f.geometry.type === 'LineString') {
        allPoints.push(...f.geometry.coordinates);
      } else if (f.geometry.type === 'Polygon') {
        f.geometry.coordinates.forEach(ring => allPoints.push(...ring));
      } else if (f.geometry.type === 'MultiPolygon') {
        f.geometry.coordinates.forEach(polygon =>
          polygon.forEach(ring => allPoints.push(...ring))
        );
      }
    });
    const centroid = allPoints.length > 0
      ? d3.geoCentroid({ type: 'MultiPoint', coordinates: allPoints })
      : [0, 0];
    const centerRotate = inputRotate
      ? [-inputRotate[0], -inputRotate[1], inputRotate[2] ?? 0]
      : [-centroid[0], -centroid[1], 0];
    const size = getSize();
    const localState = { width: size.width, height: size.height };

    
    if (!window.globeMapSync) {
      window.globeMapSync = {
        rotate: centerRotate,
        centerRotate: centerRotate,
        renders: []
      };
    }
    const sync = window.globeMapSync;

    
    if (sync.renders.length === 0) {
      sync.rotate = centerRotate;
      sync.centerRotate = centerRotate;
    }

    if (!window.globeLandData) {
      const landTopo = await (await fetch('https://cdn.jsdelivr.net/npm/world-atlas@2/land-110m.json')).json();
      window.globeLandData = feature(landTopo, landTopo.objects.land);
    }
    const land = window.globeLandData;

    function render() {
      const size = getSize();
      localState.width = size.width;
      localState.height = size.height;

      const marks = [
        Plot.geo(land, { stroke: '#88b', fill: 'none', strokeWidth: 0.8, strokeOpacity: 0.8 }),
        Plot.graticule({ strokeOpacity: 0.06 })
      ];

      if (isGlobe) {
        marks.push(Plot.sphere({ strokeWidth: 2 }));
      } else {
        marks.push(Plot.frame({ strokeWidth: 1 }));
      }

      
      const polygons = {
        type: 'FeatureCollection',
        features: featureCollection.features.filter(f =>
          f.geometry.type === 'Polygon' || f.geometry.type === 'MultiPolygon'
        )
      };
      const lines = {
        type: 'FeatureCollection',
        features: featureCollection.features.filter(f => f.geometry.type === 'LineString')
      };
      const points = {
        type: 'FeatureCollection',
        features: featureCollection.features.filter(f => f.geometry.type === 'Point')
      };

      
      if (polygons.features.length > 0) {
        marks.push(Plot.geo(polygons, {
          fill: d => d.properties?.fill || 'red',
          fillOpacity: d => d.properties?.fillOpacity ?? 0.45,
          stroke: d => d.properties?.stroke || d.properties?.fill || 'red',
          strokeWidth: d => d.properties?.strokeWidth ?? 1,
          strokeOpacity: d => d.properties?.strokeOpacity ?? 0.7
        }));

        
        if (arrowStep > 0) {
          let edgeIndex = 0;
          
          rawData.features.forEach(f => {
            if (f.geometry.type !== 'Polygon' && f.geometry.type !== 'MultiPolygon') return;
            const stroke = f.properties?.stroke || f.properties?.fill || 'red';
            const strokeWidth = f.properties?.strokeWidth ?? 1;
            const rings = f.geometry.type === 'Polygon'
              ? f.geometry.coordinates
              : f.geometry.coordinates.flat();
            rings.forEach(ring => {
              for (let i = 0; i < ring.length - 1; i++) {
                if (edgeIndex % arrowStep === 0) {
                  const interpolate = d3.geoInterpolate(ring[i], ring[i + 1]);
                  marks.push(Plot.line([interpolate(0.45), interpolate(0.55)], {
                    x: d => d[0],
                    y: d => d[1],
                    markerEnd: 'arrow',
                    stroke: 'darkred',
                    strokeWidth: 1.5
                  }));
                }
                edgeIndex++;
              }
            });
          });
        }
      }

      
      if (lines.features.length > 0) {
        marks.push(Plot.geo(lines, {
          stroke: d => d.properties?.stroke || 'red',
          strokeWidth: d => d.properties?.strokeWidth ?? 2.5,
          strokeOpacity: d => d.properties?.strokeOpacity ?? 0.9
        }));

        
        lines.features.forEach(f => {
          if (f.properties?.arrow) {
            const coords = f.geometry.coordinates;
            for (let i = 0; i < coords.length - 1; i++) {
              const interpolate = d3.geoInterpolate(coords[i], coords[i + 1]);
              marks.push(Plot.line([interpolate(0.45), interpolate(0.55)], {
                x: d => d[0],
                y: d => d[1],
                markerEnd: 'arrow',
                stroke: f.properties?.stroke || 'darkred',
                strokeWidth: f.properties?.strokeWidth ?? 2
              }));
            }
          }
        });
      }

      
      points.features.forEach(f => {
        marks.push(Plot.geo(f, {
          fill: f.properties?.fill || 'red',
          stroke: f.properties?.stroke || 'darkred',
          strokeWidth: f.properties?.strokeWidth ?? 1,
          r: f.properties?.r ?? 5
        }));
      });

      const projectionConfig = isGlobe
        ? { type: projection, rotate: sync.rotate, inset: 1 }
        : { type: projection };

      const svg = Plot.plot({
        width: localState.width,
        height: localState.height,
        projection: projectionConfig,
        marks
      });

      container.innerHTML = '';
      container.appendChild(svg);
      if (isGlobe) {
        attachDrag(svg);
      }
    }

    window.addEventListener('resize', render);

    
    const versor = {
      cartesian: function(e) {
        const l = e[0] * Math.PI / 180, p = e[1] * Math.PI / 180, cp = Math.cos(p);
        return [cp * Math.cos(l), cp * Math.sin(l), Math.sin(p)];
      },
      rotation: function(q) {
        return [
          Math.atan2(2 * (q[0] * q[1] + q[2] * q[3]), 1 - 2 * (q[1] * q[1] + q[2] * q[2])) * 180 / Math.PI,
          Math.asin(Math.max(-1, Math.min(1, 2 * (q[0] * q[2] - q[3] * q[1])))) * 180 / Math.PI,
          Math.atan2(2 * (q[0] * q[3] + q[1] * q[2]), 1 - 2 * (q[2] * q[2] + q[3] * q[3])) * 180 / Math.PI
        ];
      },
      delta: function(v0, v1) {
        const w = this.cross(v0, v1), l = Math.sqrt(this.dot(w, w));
        if (!l) return [1, 0, 0, 0];
        const t = Math.acos(Math.max(-1, Math.min(1, this.dot(v0, v1)))) / 2, s = Math.sin(t);
        return [Math.cos(t), w[2] / l * s, -w[1] / l * s, w[0] / l * s];
      },
      multiply: function(a, b) {
        return [
          a[0] * b[0] - a[1] * b[1] - a[2] * b[2] - a[3] * b[3],
          a[0] * b[1] + a[1] * b[0] + a[2] * b[3] - a[3] * b[2],
          a[0] * b[2] - a[1] * b[3] + a[2] * b[0] + a[3] * b[1],
          a[0] * b[3] + a[1] * b[2] - a[2] * b[1] + a[3] * b[0]
        ];
      },
      from: function(r) {
        const l = r[0] / 2 * Math.PI / 180, p = r[1] / 2 * Math.PI / 180, g = r[2] / 2 * Math.PI / 180;
        const sl = Math.sin(l), cl = Math.cos(l);
        const sp = Math.sin(p), cp = Math.cos(p);
        const sg = Math.sin(g), cg = Math.cos(g);
        return [
          cl * cp * cg + sl * sp * sg,
          sl * cp * cg - cl * sp * sg,
          cl * sp * cg + sl * cp * sg,
          cl * cp * sg - sl * sp * cg
        ];
      },
      cross: function(a, b) { return [a[1]*b[2] - a[2]*b[1], a[2]*b[0] - a[0]*b[2], a[0]*b[1] - a[1]*b[0]]; },
      dot: function(a, b) { return a[0]*b[0] + a[1]*b[1] + a[2]*b[2]; }
    };

    function attachDrag(svg) {
      const projection = d3.geoOrthographic()
        .rotate(sync.rotate)
        .translate([localState.width / 2, localState.height / 2])
        .scale(Math.min(localState.width, localState.height) / 2 - 1);

      let v0, q0, r0;

      const drag = d3.drag()
        .on('start', (event) => {
          projection.rotate(sync.rotate).translate([localState.width / 2, localState.height / 2]).scale(Math.min(localState.width, localState.height) / 2 - 1);
          const inv = projection.invert([event.x, event.y]);
          if (inv) {
            v0 = versor.cartesian(inv);
            r0 = sync.rotate;
            q0 = versor.from(r0);
          }
        })
        .on('drag', (event) => {
          if (!v0) return;
          projection.rotate(r0);
          const inv = projection.invert([event.x, event.y]);
          if (!inv) return;
          const v1 = versor.cartesian(inv);
          const delta = versor.delta(v0, v1);
          const q1 = versor.multiply(q0, delta);
          sync.rotate = versor.rotation(q1);
          
          sync.renders.forEach(r => r());
        });

      d3.select(svg).call(drag);
      d3.select(svg).on('dblclick', () => {
        sync.rotate = sync.centerRotate.slice();
        sync.renders.forEach(r => r());
      });
    }

    
    sync.renders.push(render);

    render();
  })();
</script><span style=font-size:2rem>→</span><div class=globe-container id=globe-gm1 style="max-width:400px;width:100%;aspect-ratio:1;margin:2em auto"></div><script type=module>
  import * as Plot from 'https://cdn.jsdelivr.net/npm/@observablehq/plot@0.6/+esm';
  import * as d3 from 'https://cdn.jsdelivr.net/npm/d3@7/+esm';
  import { feature } from 'https://cdn.jsdelivr.net/npm/topojson-client@3/+esm';

  (async function() {
    const rawData = {"features":[{"geometry":{"coordinates":[[[[-179.170112546831,43.33462463706695],[179.9534193241767,38.728779390762334],[174.49688633843544,36.85680682151307],[174.02804175387834,32.1119243692579],[169.07436240121478,29.9547386287809],[168.91929058653923,25.257056432213375],[164.45727251367725,23.004725058862295],[164.53519134064652,18.52280839538614],[160.52670878987635,16.340968799924067],[160.7733897026288,12.194726726168003],[164.67056230846524,10.175448079467838],[164.7007803629394,8.237083943199265],[164.93539603741021,6.119591258608642],[168.3352524578736,4.467031609784524],[172.03418236939353,6.172978893164637],[175.46041201203371,4.248592317017825],[179.2171608248945,5.88992175431389],[-178.02519665249852,2.9040374505798114],[-174.31673738369324,3.8210244943304374],[-171.37544324872502,0.649870565576401],[-167.31261713417402,1.5147974903819574],[-164.25615857265893,-1.7743965588128086],[-159.93112334382027,-0.9446533902388665],[-156.8531091350144,-4.259065522271725],[-152.3980821982831,-3.4345808068957697],[-149.4028814909321,-6.672537737437516],[-144.9683236097968,-5.820413131280587],[-143.3961790952625,-1.706579969821454],[-138.95903110794228,-0.8353130739527114],[-137.3063271216714,3.372828505596593],[-132.96499017492758,4.158942627265325],[-131.26895225504,8.320295172124068],[-133.89520751564908,11.884131145297399],[-132.14080471892913,16.072271835802038],[-134.89965579269537,19.7532105149965],[-133.08381598345164,23.820431161854447],[-135.98689147817444,27.469138609544558],[-140.91889130500928,27.061192038819836],[-144.17342232410294,30.569950882968854],[-149.34707529879068,29.89183008460252],[-152.85043045733752,33.12732053866678],[-158.04649474959947,32.12156651323389],[-161.64707805135708,34.994006697107615],[-159.94762734735153,39.09941640444715],[-163.39292691687498,42.461841701752746],[-168.8876761772056,41.53861492567143],[-173.2513616288856,44.74985555511408],[-179.170112546831,43.33462463706695]],[[-157.6068486027842,20.259691594705036],[-156.08998858841755,24.696711258039056],[-151.04796662686522,25.669243623986258],[-147.69594788211106,22.16693900740581],[-142.7188705783351,22.885971422359724],[-139.6214919325493,19.2239309458196],[-141.37151007296615,14.881959131410003],[-138.42043748614526,11.22287623237951],[-140.12125038010964,6.870649308036964],[-144.72979242136543,6.045591181415267],[-146.33638072286848,1.6772949381945044],[-150.91862197114955,0.7969950664894166],[-154.0294052002189,4.260374459536214],[-158.59967491814012,3.335734857517349],[-161.77338167921764,6.766536253596436],[-160.44607430026895,11.231115019630433],[-163.71455965998953,14.623074892227512],[-162.39694129463984,19.114485874069658],[-157.6068486027842,20.259691594705036]],[[-178.95063664056067,17.74333218723816],[-175.45827111402537,15.285730312483953],[-176.35806599111405,11.05195584369349],[-178.23815999124182,10.46324037683843],[179.77693144202632,9.615942399155198],[176.28993210653294,11.794175727566111],[172.29426677728955,9.978189493251357],[168.53745793093609,12.10200548276957],[168.65279280829242,16.286127926718756],[172.88878640797157,18.30669067889132],[173.23062212965775,22.777763428069576],[177.84694371159145,24.75690942135447],[-178.22376950605553,22.092681232201556],[-178.95063664056067,17.74333218723816]],[[-175.56432922504848,35.741206971176496],[-170.27191812997154,37.14623592274974],[-166.5289282511271,33.96535450751626],[-167.88337203384341,29.62550789823012],[-172.64626329548403,28.20896181794974],[-176.54267313535857,31.148162090824524],[-175.56432922504848,35.741206971176496]]],[[[-137.16670054747664,34.7661254517022],[-136.19839496396796,36.53790229001989],[-135.31985086435014,38.551076772095065],[-138.45029122366302,41.45713981733577],[-143.8463112012841,41.20828589932378],[-147.45009391663316,44.09362423911828],[-153.03739182353243,43.44325276436556],[-154.78487065089823,39.9092677035244],[-151.12386440058128,37.032961967755135],[-145.74636904346727,37.68759229063255],[-142.3232078622538,34.454167617014946],[-137.16670054747664,34.7661254517022]]],[[[-147.80006555587835,9.62874721795654],[-146.16007687374923,14.110797540904425],[-149.3676428224656,17.73753035354521],[-154.25484084592026,16.797013674901503],[-155.7634836482284,12.265823643881989],[-152.5335322367957,8.71898308656318],[-147.80006555587835,9.62874721795654]]]],"type":"MultiPolygon"},"properties":{"fill":"#dc3545","fillOpacity":0.3,"stroke":"#dc3545","strokeWidth":2},"type":"Feature"}],"type":"FeatureCollection"};

    if (!rawData || !rawData.features) {
      console.error('globe_map: Invalid or missing data');
      return;
    }

    
    const featureCollection = {
      type: rawData.type,
      features: rawData.features.map(f => {
        if (f.geometry.type === 'Polygon') {
          return {
            ...f,
            geometry: {
              ...f.geometry,
              coordinates: f.geometry.coordinates.map(ring => ring.slice().reverse())
            }
          };
        } else if (f.geometry.type === 'MultiPolygon') {
          return {
            ...f,
            geometry: {
              ...f.geometry,
              coordinates: f.geometry.coordinates.map(polygon =>
                polygon.map(ring => ring.slice().reverse())
              )
            }
          };
        }
        return f;
      })
    };

    const projection = "orthographic";
    const isGlobe = projection === "orthographic";
    const maxWidth =  400 ;
    const arrowStep =  3 ;

    const container = document.getElementById('globe-gm1');
    const getSize = () => {
      const width = container.offsetWidth || container.clientWidth;
      const w = width > 0 ? Math.min(maxWidth, width) : maxWidth;
      return { width: w, height: isGlobe ? w : w / 2 };
    };

    
    const inputRotate = null;
    const allPoints = [];
    rawData.features.forEach(f => {
      if (f.geometry.type === 'Point') {
        allPoints.push(f.geometry.coordinates);
      } else if (f.geometry.type === 'LineString') {
        allPoints.push(...f.geometry.coordinates);
      } else if (f.geometry.type === 'Polygon') {
        f.geometry.coordinates.forEach(ring => allPoints.push(...ring));
      } else if (f.geometry.type === 'MultiPolygon') {
        f.geometry.coordinates.forEach(polygon =>
          polygon.forEach(ring => allPoints.push(...ring))
        );
      }
    });
    const centroid = allPoints.length > 0
      ? d3.geoCentroid({ type: 'MultiPoint', coordinates: allPoints })
      : [0, 0];
    const centerRotate = inputRotate
      ? [-inputRotate[0], -inputRotate[1], inputRotate[2] ?? 0]
      : [-centroid[0], -centroid[1], 0];
    const size = getSize();
    const localState = { width: size.width, height: size.height };

    
    if (!window.globeMapSync) {
      window.globeMapSync = {
        rotate: centerRotate,
        centerRotate: centerRotate,
        renders: []
      };
    }
    const sync = window.globeMapSync;

    
    if (sync.renders.length === 0) {
      sync.rotate = centerRotate;
      sync.centerRotate = centerRotate;
    }

    if (!window.globeLandData) {
      const landTopo = await (await fetch('https://cdn.jsdelivr.net/npm/world-atlas@2/land-110m.json')).json();
      window.globeLandData = feature(landTopo, landTopo.objects.land);
    }
    const land = window.globeLandData;

    function render() {
      const size = getSize();
      localState.width = size.width;
      localState.height = size.height;

      const marks = [
        Plot.geo(land, { stroke: '#88b', fill: 'none', strokeWidth: 0.8, strokeOpacity: 0.8 }),
        Plot.graticule({ strokeOpacity: 0.06 })
      ];

      if (isGlobe) {
        marks.push(Plot.sphere({ strokeWidth: 2 }));
      } else {
        marks.push(Plot.frame({ strokeWidth: 1 }));
      }

      
      const polygons = {
        type: 'FeatureCollection',
        features: featureCollection.features.filter(f =>
          f.geometry.type === 'Polygon' || f.geometry.type === 'MultiPolygon'
        )
      };
      const lines = {
        type: 'FeatureCollection',
        features: featureCollection.features.filter(f => f.geometry.type === 'LineString')
      };
      const points = {
        type: 'FeatureCollection',
        features: featureCollection.features.filter(f => f.geometry.type === 'Point')
      };

      
      if (polygons.features.length > 0) {
        marks.push(Plot.geo(polygons, {
          fill: d => d.properties?.fill || 'red',
          fillOpacity: d => d.properties?.fillOpacity ?? 0.45,
          stroke: d => d.properties?.stroke || d.properties?.fill || 'red',
          strokeWidth: d => d.properties?.strokeWidth ?? 1,
          strokeOpacity: d => d.properties?.strokeOpacity ?? 0.7
        }));

        
        if (arrowStep > 0) {
          let edgeIndex = 0;
          
          rawData.features.forEach(f => {
            if (f.geometry.type !== 'Polygon' && f.geometry.type !== 'MultiPolygon') return;
            const stroke = f.properties?.stroke || f.properties?.fill || 'red';
            const strokeWidth = f.properties?.strokeWidth ?? 1;
            const rings = f.geometry.type === 'Polygon'
              ? f.geometry.coordinates
              : f.geometry.coordinates.flat();
            rings.forEach(ring => {
              for (let i = 0; i < ring.length - 1; i++) {
                if (edgeIndex % arrowStep === 0) {
                  const interpolate = d3.geoInterpolate(ring[i], ring[i + 1]);
                  marks.push(Plot.line([interpolate(0.45), interpolate(0.55)], {
                    x: d => d[0],
                    y: d => d[1],
                    markerEnd: 'arrow',
                    stroke: 'darkred',
                    strokeWidth: 1.5
                  }));
                }
                edgeIndex++;
              }
            });
          });
        }
      }

      
      if (lines.features.length > 0) {
        marks.push(Plot.geo(lines, {
          stroke: d => d.properties?.stroke || 'red',
          strokeWidth: d => d.properties?.strokeWidth ?? 2.5,
          strokeOpacity: d => d.properties?.strokeOpacity ?? 0.9
        }));

        
        lines.features.forEach(f => {
          if (f.properties?.arrow) {
            const coords = f.geometry.coordinates;
            for (let i = 0; i < coords.length - 1; i++) {
              const interpolate = d3.geoInterpolate(coords[i], coords[i + 1]);
              marks.push(Plot.line([interpolate(0.45), interpolate(0.55)], {
                x: d => d[0],
                y: d => d[1],
                markerEnd: 'arrow',
                stroke: f.properties?.stroke || 'darkred',
                strokeWidth: f.properties?.strokeWidth ?? 2
              }));
            }
          }
        });
      }

      
      points.features.forEach(f => {
        marks.push(Plot.geo(f, {
          fill: f.properties?.fill || 'red',
          stroke: f.properties?.stroke || 'darkred',
          strokeWidth: f.properties?.strokeWidth ?? 1,
          r: f.properties?.r ?? 5
        }));
      });

      const projectionConfig = isGlobe
        ? { type: projection, rotate: sync.rotate, inset: 1 }
        : { type: projection };

      const svg = Plot.plot({
        width: localState.width,
        height: localState.height,
        projection: projectionConfig,
        marks
      });

      container.innerHTML = '';
      container.appendChild(svg);
      if (isGlobe) {
        attachDrag(svg);
      }
    }

    window.addEventListener('resize', render);

    
    const versor = {
      cartesian: function(e) {
        const l = e[0] * Math.PI / 180, p = e[1] * Math.PI / 180, cp = Math.cos(p);
        return [cp * Math.cos(l), cp * Math.sin(l), Math.sin(p)];
      },
      rotation: function(q) {
        return [
          Math.atan2(2 * (q[0] * q[1] + q[2] * q[3]), 1 - 2 * (q[1] * q[1] + q[2] * q[2])) * 180 / Math.PI,
          Math.asin(Math.max(-1, Math.min(1, 2 * (q[0] * q[2] - q[3] * q[1])))) * 180 / Math.PI,
          Math.atan2(2 * (q[0] * q[3] + q[1] * q[2]), 1 - 2 * (q[2] * q[2] + q[3] * q[3])) * 180 / Math.PI
        ];
      },
      delta: function(v0, v1) {
        const w = this.cross(v0, v1), l = Math.sqrt(this.dot(w, w));
        if (!l) return [1, 0, 0, 0];
        const t = Math.acos(Math.max(-1, Math.min(1, this.dot(v0, v1)))) / 2, s = Math.sin(t);
        return [Math.cos(t), w[2] / l * s, -w[1] / l * s, w[0] / l * s];
      },
      multiply: function(a, b) {
        return [
          a[0] * b[0] - a[1] * b[1] - a[2] * b[2] - a[3] * b[3],
          a[0] * b[1] + a[1] * b[0] + a[2] * b[3] - a[3] * b[2],
          a[0] * b[2] - a[1] * b[3] + a[2] * b[0] + a[3] * b[1],
          a[0] * b[3] + a[1] * b[2] - a[2] * b[1] + a[3] * b[0]
        ];
      },
      from: function(r) {
        const l = r[0] / 2 * Math.PI / 180, p = r[1] / 2 * Math.PI / 180, g = r[2] / 2 * Math.PI / 180;
        const sl = Math.sin(l), cl = Math.cos(l);
        const sp = Math.sin(p), cp = Math.cos(p);
        const sg = Math.sin(g), cg = Math.cos(g);
        return [
          cl * cp * cg + sl * sp * sg,
          sl * cp * cg - cl * sp * sg,
          cl * sp * cg + sl * cp * sg,
          cl * cp * sg - sl * sp * cg
        ];
      },
      cross: function(a, b) { return [a[1]*b[2] - a[2]*b[1], a[2]*b[0] - a[0]*b[2], a[0]*b[1] - a[1]*b[0]]; },
      dot: function(a, b) { return a[0]*b[0] + a[1]*b[1] + a[2]*b[2]; }
    };

    function attachDrag(svg) {
      const projection = d3.geoOrthographic()
        .rotate(sync.rotate)
        .translate([localState.width / 2, localState.height / 2])
        .scale(Math.min(localState.width, localState.height) / 2 - 1);

      let v0, q0, r0;

      const drag = d3.drag()
        .on('start', (event) => {
          projection.rotate(sync.rotate).translate([localState.width / 2, localState.height / 2]).scale(Math.min(localState.width, localState.height) / 2 - 1);
          const inv = projection.invert([event.x, event.y]);
          if (inv) {
            v0 = versor.cartesian(inv);
            r0 = sync.rotate;
            q0 = versor.from(r0);
          }
        })
        .on('drag', (event) => {
          if (!v0) return;
          projection.rotate(r0);
          const inv = projection.invert([event.x, event.y]);
          if (!inv) return;
          const v1 = versor.cartesian(inv);
          const delta = versor.delta(v0, v1);
          const q1 = versor.multiply(q0, delta);
          sync.rotate = versor.rotation(q1);
          
          sync.renders.forEach(r => r());
        });

      d3.select(svg).call(drag);
      d3.select(svg).on('dblclick', () => {
        sync.rotate = sync.centerRotate.slice();
        sync.renders.forEach(r => r());
      });
    }

    
    sync.renders.push(render);

    render();
  })();
</script></div><p class=caption>A set of H3 cells maps to three polygons; two with no holes, and one with three holes. Drag the globe to rotate; double click to reset.</p><p>Alternatively, in code, the translation might look like:</p><div style=display:flex;flex-wrap:wrap;justify-content:center;align-items:center;gap:2rem><div><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>cells <span style=color:#666>=</span> [
</span></span><span style=display:flex><span>  <span style=color:#4070a0>&#39;81463ffffffffff&#39;</span>,
</span></span><span style=display:flex><span>  <span style=color:#4070a0>&#39;8146bffffffffff&#39;</span>,
</span></span><span style=display:flex><span>  <span style=color:#4070a0>&#39;81713ffffffffff&#39;</span>,
</span></span><span style=display:flex><span>  <span style=color:#4070a0>&#39;81467ffffffffff&#39;</span>,
</span></span><span style=display:flex><span>  <span style=color:#4070a0>&#39;8147bffffffffff&#39;</span>,
</span></span><span style=display:flex><span>  <span style=color:#666>...</span>
</span></span><span style=display:flex><span>]
</span></span></code></pre></div></div><span style=font-size:2rem>→</span><div><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#062873;font-weight:700>&#34;type&#34;</span>: <span style=color:#4070a0>&#34;MultiPolygon&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#062873;font-weight:700>&#34;coordinates&#34;</span>: [
</span></span><span style=display:flex><span>    [[[<span style=color:#40a070>-179.1</span>, <span style=color:#40a070>43.3</span>], <span>...</span>]],
</span></span><span style=display:flex><span>    [[[<span style=color:#40a070>-137.1</span>, <span style=color:#40a070>34.7</span>], <span>...</span>]],
</span></span><span style=display:flex><span>    [[[<span style=color:#40a070>-147.8</span>, <span style=color:#40a070>9.6</span>], <span>...</span>]]
</span></span><span style=display:flex><span>  ]
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></div></div><p>GeoJSON is just one format we can use for describing spherical polygons,
but the algortihm we cover here here is applicable
to any similar format, and its easy to translate between them.
I wrote up my thoughts on &ldquo;ideal&rdquo; spherical polygons in <a href=/blog/sphere_poly/>another post</a>, but to summarize, we want to output spherical polygons such that:</p><ul><li>polygons consist of ordered loops of points on a sphere (lon/lat points)</li><li>polygons have one &ldquo;outer&rdquo; loop, with points oriented in counter-clockwise order, and zero or more &ldquo;inner&rdquo; loops, with points going clockwise (see the image above)</li><li>we can handle &ldquo;large&rdquo; cell sets, where resulting polygons may cross the antimeridian, enclose the poles, or be larger than a hemisphere</li></ul><h1 id=h3-edges>H3 edges</h1><p>How do we do this translation? For any h3 cell, we can get the simple polygon lat/lng points that describe its region. I want to avoid floating point comparisons, so instead we&rsquo;ll look at the set of edges. For any edge, you can get the same lat/lng points.</p><p>Edges are directed:</p><p>TODO: origin destination, and then switch them below. describe right hand rule. Maybe these aren&rsquo;t shrunk yet.</p><figure style=text-align:center><img src=code/figs/directed_edge.svg alt style=max-width:400px></figure><p>whenever we&rsquo;re plotting more than one cell, where the edges might conflict&mldr;</p><p>To avoid plotting two opposite edges on top of each other, we&rsquo;ll shrink
each edge towards its origin cell&rsquo;s center:</p><figure style=text-align:center><img src=code/figs/two_cells_edges.svg alt style=max-width:400px></figure><p>Maybe this is where we mention we can put the edges in order? Maybe not&mldr;
maybe we hold that off until after the cancellation talk.</p><h1 id=general-idea-cancel-out-the-edges>General idea: cancel out the edges</h1><p>So how do we get the outline? Well, looking at edges, we see we can just
cancel out the pairs and the outline remains.</p><p>However, we don&rsquo;t have the order of lat/lng points, we don&rsquo;t know what the loops are, which loops are part of which polygon, and which loops are outside and which are holes.</p><p>in this version, we just show sets of edges first.</p><p>compute the reverse. look for collisions.
ok, but this just gives us the bag of edges.
how do we get a loop in order?</p><p>we can go back to the idea of trying to figure out which one is which.</p><p>but what if we can exploit the fact that these edges are already sorted
in each cell. (ed: how do we demonstrate the loop?)</p><p>the hash table finds the <code>Arc</code> (pair of arcs) we want to work on. we once that&rsquo;s in hand,
we can do a few other things, like modify the linked-loop and keep
track of connected components.</p><h1 id=rings-of-edges>Rings of edges</h1><p>Each H3 cell has 6 directed edges (5 for pentagons) that we can enumerate
in counter-clockwise order. We store each edge in an <code>Arc</code> struct, using
<code>next</code> and <code>prev</code> pointers to form a doubly-linked list of the edges surrounding that cell:</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#007020;font-weight:700>typedef</span> <span style=color:#007020;font-weight:700>struct</span> Arc {
</span></span><span style=display:flex><span>    H3Index id;       <span style=color:#60a0b0;font-style:italic>// directed edge index
</span></span></span><span style=display:flex><span>    <span style=color:#007020;font-weight:700>struct</span> Arc <span style=color:#666>*</span>next;
</span></span><span style=display:flex><span>    <span style=color:#007020;font-weight:700>struct</span> Arc <span style=color:#666>*</span>prev;
</span></span><span style=display:flex><span>    <span style=color:#60a0b0;font-style:italic>// ...
</span></span></span><span style=display:flex><span>} Arc;
</span></span></code></pre></div><p>H3&rsquo;s <code>originToDirectedEdges</code> returns edges in a fixed order, but not
counter-clockwise. We reorder them:</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#007020;font-weight:700>static</span> <span style=color:#007020;font-weight:700>const</span> <span style=color:#902000>uint8_t</span> idxh[<span style=color:#40a070>6</span>] <span style=color:#666>=</span> {<span style=color:#40a070>0</span>, <span style=color:#40a070>4</span>, <span style=color:#40a070>3</span>, <span style=color:#40a070>5</span>, <span style=color:#40a070>1</span>, <span style=color:#40a070>2</span>};  <span style=color:#60a0b0;font-style:italic>// hexagons
</span></span></span><span style=display:flex><span><span style=color:#007020;font-weight:700>static</span> <span style=color:#007020;font-weight:700>const</span> <span style=color:#902000>uint8_t</span> idxp[<span style=color:#40a070>5</span>] <span style=color:#666>=</span> {<span style=color:#40a070>0</span>, <span style=color:#40a070>1</span>, <span style=color:#40a070>3</span>, <span style=color:#40a070>2</span>, <span style=color:#40a070>4</span>};     <span style=color:#60a0b0;font-style:italic>// pentagons
</span></span></span></code></pre></div><figure style=text-align:center><img src=code/figs/single_cell.svg alt style=max-width:400px></figure><p>For each cell in the input set, we create its 5 or 6 arcs and doubly-link them into a loop of <code>Arc</code>s (work done by <code>cellToEdgeArcs</code>). We store all the <code>Arc</code>s in an <code>ArcSet</code> so that we can iterate through the <code>Arc</code>/edges them later. Note that, at this point, the loops from different cells are disjoint from one another.</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#007020;font-weight:700>typedef</span> <span style=color:#007020;font-weight:700>struct</span> {
</span></span><span style=display:flex><span>    <span style=color:#902000>int64_t</span> numArcs;
</span></span><span style=display:flex><span>    Arc <span style=color:#666>*</span>arcs;
</span></span><span style=display:flex><span>    <span style=color:#60a0b0;font-style:italic>// ...
</span></span></span><span style=display:flex><span>} ArcSet;
</span></span></code></pre></div><p>For this loop, and the loops we&rsquo;ll have later on, we can call <code>directedEdgeToBoundary</code> to get the lat/lng coordinates of the edge vertices.</p><h1 id=edge-cancellation>Edge cancellation</h1><p>The main idea of the algorithm is that we start with valid loops (small loops around cells), find pairs of edges that cancel each other out,
remove the pairs of edges, and stitch together the loops&mdash;all while
<strong>maintaining valid loops the whole time</strong>.</p><p>For example, if we were to start with two neighboring cells, with two disjoint loops, the <code>ArcSet</code> would initially correspond to this picture:</p><figure style=text-align:center><img src=code/figs/two_cells_before.svg alt style=max-width:400px><p class=caption>Initial state of edges for two cells.</p></figure><p>After canceling the pair of edges, the <code>ArcSet</code> would look like this:</p><figure style=text-align:center><img src=code/figs/two_cells_after.svg alt style=max-width:600px><p class=caption>After canceling pairs of edges.</p></figure><p>Note that the edges stay in a counter-clockwise loop.</p><h2 id=finding-edge-pairs>Finding edge pairs</h2><p>Every directed edge has an edge representing the opposite direction. To find pairs, we iterate through all arcs,
compute the reverse with <code>reverseDirectedEdge</code>, and look it up in a hash table:</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#06287e>H3_EXPORT</span>(reverseDirectedEdge)(a<span style=color:#666>-&gt;</span>id, <span style=color:#666>&amp;</span>reversedEdge);
</span></span><span style=display:flex><span>Arc <span style=color:#666>*</span>b <span style=color:#666>=</span> <span style=color:#06287e>findArc</span>(arcset, reversedEdge);
</span></span></code></pre></div><p>If <code>b</code> exists, we&rsquo;ve found a pair to cancel. We mark both as removed with <code>isRemoved = true</code> in the <code>Arc</code> struct.</p><p>The hash table lives in <code>ArcSet</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#007020;font-weight:700>typedef</span> <span style=color:#007020;font-weight:700>struct</span> {
</span></span><span style=display:flex><span>    <span style=color:#902000>int64_t</span> numArcs;
</span></span><span style=display:flex><span>    Arc <span style=color:#666>*</span>arcs;
</span></span><span style=display:flex><span>    <span style=color:#902000>int64_t</span> numBuckets;  <span style=color:#60a0b0;font-style:italic>// = 10 * numArcs
</span></span></span><span style=display:flex><span>    Arc <span style=color:#666>**</span>buckets;
</span></span><span style=display:flex><span>} ArcSet;
</span></span></code></pre></div><p>We use a simple linear probing scheme with <code>numBuckets = 10 * numArcs</code> to keep collisions low. In the future, an improved algorithm could use less memory without sacrificing lookup speed.</p><h2 id=loop-surgery>Loop surgery</h2><p>When canceling edges <code>a</code> and <code>b</code>, we splice them out by reconnecting their neighbors.</p><p>The edges in the loops are initially chained like:</p><span class=katex-display><span class=katex><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:3em;vertical-align:-1.25em></span><span class=mord><span class=mtable><span class=col-align-r><span class="vlist-t vlist-t2"><span class=vlist-r><span class=vlist style=height:1.75em><span style=top:-3.91em><span class=pstrut style=height:3em></span><span class=mord><span class=mord><span class="mord mathnormal">a</span><span class=msupsub><span class=vlist-t><span class=vlist-r><span class=vlist style=height:.8213em><span style=top:-3.113em;margin-right:.05em><span class=pstrut style=height:2.7em></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">−</span></span></span></span></span></span></span></span></span></span><span style=top:-2.41em><span class=pstrut style=height:3em></span><span class=mord><span class=mord><span class="mord mathnormal">b</span><span class=msupsub><span class=vlist-t><span class=vlist-r><span class=vlist style=height:.8213em><span style=top:-3.113em;margin-right:.05em><span class=pstrut style=height:2.7em></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">−</span></span></span></span></span></span></span></span></span></span></span><span class=vlist-s>​</span></span><span class=vlist-r><span class=vlist style=height:1.25em><span></span></span></span></span></span><span class=col-align-l><span class="vlist-t vlist-t2"><span class=vlist-r><span class=vlist style=height:1.75em><span style=top:-3.91em><span class=pstrut style=height:3em></span><span class=mord><span class=mord></span><span class=mspace style=margin-right:.2778em></span><span class=mrel>→</span><span class=mspace style=margin-right:.2778em></span><span class="mord mathnormal">a</span><span class=mspace style=margin-right:.2778em></span><span class=mrel>→</span><span class=mspace style=margin-right:.2778em></span><span class=mord><span class="mord mathnormal">a</span><span class=msupsub><span class=vlist-t><span class=vlist-r><span class=vlist style=height:.8213em><span style=top:-3.113em;margin-right:.05em><span class=pstrut style=height:2.7em></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">+</span></span></span></span></span></span></span></span></span></span><span style=top:-2.41em><span class=pstrut style=height:3em></span><span class=mord><span class=mord></span><span class=mspace style=margin-right:.2778em></span><span class=mrel>→</span><span class=mspace style=margin-right:.2778em></span><span class="mord mathnormal">b</span><span class=mspace style=margin-right:.2778em></span><span class=mrel>→</span><span class=mspace style=margin-right:.2778em></span><span class=mord><span class="mord mathnormal">b</span><span class=msupsub><span class=vlist-t><span class=vlist-r><span class=vlist style=height:.8213em><span style=top:-3.113em;margin-right:.05em><span class=pstrut style=height:2.7em></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">+</span></span></span></span></span></span></span></span></span></span></span><span class=vlist-s>​</span></span><span class=vlist-r><span class=vlist style=height:1.25em><span></span></span></span></span></span></span></span></span></span></span></span><figure style=text-align:center><img src=code/figs/two_cells_before_labels.svg alt style=max-width:400px></figure><p>After removing edges <code>a</code> and <code>b</code>, we recconect their surrounding edges like
the following, which merges the two loops into one counter-clockwise loop,
updating the doubly-linked list appropriately.</p><span class=katex-display><span class=katex><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:3em;vertical-align:-1.25em></span><span class=mord><span class=mtable><span class=col-align-r><span class="vlist-t vlist-t2"><span class=vlist-r><span class=vlist style=height:1.75em><span style=top:-3.91em><span class=pstrut style=height:3em></span><span class=mord><span class=mord><span class="mord mathnormal">a</span><span class=msupsub><span class=vlist-t><span class=vlist-r><span class=vlist style=height:.8213em><span style=top:-3.113em;margin-right:.05em><span class=pstrut style=height:2.7em></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">−</span></span></span></span></span></span></span></span></span></span><span style=top:-2.41em><span class=pstrut style=height:3em></span><span class=mord><span class=mord><span class="mord mathnormal">b</span><span class=msupsub><span class=vlist-t><span class=vlist-r><span class=vlist style=height:.8213em><span style=top:-3.113em;margin-right:.05em><span class=pstrut style=height:2.7em></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">−</span></span></span></span></span></span></span></span></span></span></span><span class=vlist-s>​</span></span><span class=vlist-r><span class=vlist style=height:1.25em><span></span></span></span></span></span><span class=col-align-l><span class="vlist-t vlist-t2"><span class=vlist-r><span class=vlist style=height:1.75em><span style=top:-3.91em><span class=pstrut style=height:3em></span><span class=mord><span class=mord></span><span class=mspace style=margin-right:.2778em></span><span class=mrel>→</span><span class=mspace style=margin-right:.2778em></span><span class=mord><span class="mord mathnormal">b</span><span class=msupsub><span class=vlist-t><span class=vlist-r><span class=vlist style=height:.8213em><span style=top:-3.113em;margin-right:.05em><span class=pstrut style=height:2.7em></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">+</span></span></span></span></span></span></span></span></span></span><span style=top:-2.41em><span class=pstrut style=height:3em></span><span class=mord><span class=mord></span><span class=mspace style=margin-right:.2778em></span><span class=mrel>→</span><span class=mspace style=margin-right:.2778em></span><span class=mord><span class="mord mathnormal">a</span><span class=msupsub><span class=vlist-t><span class=vlist-r><span class=vlist style=height:.8213em><span style=top:-3.113em;margin-right:.05em><span class=pstrut style=height:2.7em></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">+</span></span></span></span></span></span></span></span></span></span></span><span class=vlist-s>​</span></span><span class=vlist-r><span class=vlist style=height:1.25em><span></span></span></span></span></span></span></span></span></span></span></span><figure style=text-align:center><img src=code/figs/two_cells_after_labels.svg alt style=max-width:400px></figure><p>In the C code, this looks like the following, where <code>a</code> and <code>b</code> are <code>Arc</code> structs:</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>a<span style=color:#666>-&gt;</span>next<span style=color:#666>-&gt;</span>prev <span style=color:#666>=</span> b<span style=color:#666>-&gt;</span>prev;
</span></span><span style=display:flex><span>a<span style=color:#666>-&gt;</span>prev<span style=color:#666>-&gt;</span>next <span style=color:#666>=</span> b<span style=color:#666>-&gt;</span>next;
</span></span><span style=display:flex><span>b<span style=color:#666>-&gt;</span>next<span style=color:#666>-&gt;</span>prev <span style=color:#666>=</span> a<span style=color:#666>-&gt;</span>prev;
</span></span><span style=display:flex><span>b<span style=color:#666>-&gt;</span>prev<span style=color:#666>-&gt;</span>next <span style=color:#666>=</span> a<span style=color:#666>-&gt;</span>next;
</span></span></code></pre></div><h2 id=other-edge-cancellation-examples>Other edge cancellation examples</h2><p>Luckily, the loop surgery logic above works in all possible cases.</p><p><figure style=text-align:center><img src=code/figs/four_cells_0.svg alt style=max-width:400px></figure><figure style=text-align:center><img src=code/figs/four_cells_1.svg alt style=max-width:400px></figure><figure style=text-align:center><img src=code/figs/four_cells_2.svg alt style=max-width:400px></figure><figure style=text-align:center><img src=code/figs/four_cells_3.svg alt style=max-width:400px></figure></p><p>Note that we can remove the edges in any order. Even the following is
a completely valid set of two linked-loops (even though the edges in the middle don&rsquo;t enclose any area and will need to be ultimately removed before we form proper polygons):</p><figure style=text-align:center><img src=code/figs/four_cells_4.svg alt style=max-width:400px></figure><h3 id=disk>Disk</h3><figure style=text-align:center><img src=code/figs/disk_0.svg alt style=max-width:400px></figure><p>Removing the edges associated with the center cell leaves a single
ring (with 6 degenerate pairs left to be removed):<figure style=text-align:center><img src=code/figs/disk_1.svg alt style=max-width:400px></figure></p><figure style=text-align:center><img src=code/figs/disk_2.svg alt style=max-width:400px></figure><h3 id=hole>Hole</h3><p>Note that canceling edges might split up rings:</p><p><figure style=text-align:center><img src=code/figs/ring_0.svg alt style=max-width:400px></figure><figure style=text-align:center><img src=code/figs/ring_1.svg alt style=max-width:400px></figure><figure style=text-align:center><img src=code/figs/ring_2.svg alt style=max-width:400px></figure></p><h1 id=connected-components-partition-loops-into-polygons>Connected components partition loops into polygons</h1><p>TODO: edges example with multiple loops and polygons.</p><p>Plotting: make the connected components easier by just plotting the whole
H3 cell, then i don&rsquo;t have to do the bits to connect the shrunken cells.</p><h1 id=which-loop-is-outside>Which loop is &ldquo;outside&rdquo;?</h1><p>In a polygon, one loop is <em>special</em>. The outer loop. the rest are holes.
Actually, not relaly that special. any loop can be the outer loop and still mathematical describe the same polygon, even if it is an unintuitive format.</p><p>a tricky one might look like: blah</p><h1 id=notes>Notes</h1><ul><li>maybe do a <strong>Summary</strong> section at the end of each, and also a <strong>Code</strong> section, that might ligthen it up? or is it helpful to have the code snippets in the doc inline?</li><li>separate out with Code section. can link multiple implementations. include the python one</li><li>end with some fun, tricky examples</li></ul></content><p></p></main><footer>© 2025 AJ Friend · Made with <a href=https://github.com/janraasch/hugo-bearblog/>Hugo ʕ•ᴥ•ʔ Bear</a></footer></body></html>