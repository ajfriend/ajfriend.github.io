<!doctype html><html lang=en-us><head><meta http-equiv=X-Clacks-Overhead content="GNU Terry Pratchett"><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>[WIP] Elements of Spherical Polygons | AJ Friend</title><meta name=title content="[WIP] Elements of Spherical Polygons"><meta name=description content="These are some of my notes on constructing spherical polygons, related to
my work on the H3 cells-to-polygon functionality.
When working with spherical polygons, &ldquo;edge cases&rdquo; often cause problems: larger-than-a-hemisphere polygons, edges that cross the antimeridian, polygons containing
the north or south pole, or issues with loop orientation.
Luckly, all these issues can be handled easily if you format and interpret polygons
in the right way.
This is my take on &ldquo;the right way&rdquo;. Note that these ideas are not new, and if other
systems do something different, it is probably because they are constrained by supporting historical formats. (TODO: maybe discuss some differences in an appendix.
2d-native, non-geodesic lines)"><meta name=keywords content><meta property="og:url" content="https://ajfriend.com/blog/sphere_poly/"><meta property="og:site_name" content="AJ Friend"><meta property="og:title" content="[WIP] Elements of Spherical Polygons"><meta property="og:description" content="These are some of my notes on constructing spherical polygons, related to my work on the H3 cells-to-polygon functionality.
When working with spherical polygons, “edge cases” often cause problems: larger-than-a-hemisphere polygons, edges that cross the antimeridian, polygons containing the north or south pole, or issues with loop orientation. Luckly, all these issues can be handled easily if you format and interpret polygons in the right way.
This is my take on “the right way”. Note that these ideas are not new, and if other systems do something different, it is probably because they are constrained by supporting historical formats. (TODO: maybe discuss some differences in an appendix. 2d-native, non-geodesic lines)"><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="blog"><meta property="article:published_time" content="2026-01-02T00:00:00+00:00"><meta property="article:modified_time" content="2026-01-02T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="[WIP] Elements of Spherical Polygons"><meta name=twitter:description content="These are some of my notes on constructing spherical polygons, related to my work on the H3 cells-to-polygon functionality.
When working with spherical polygons, “edge cases” often cause problems: larger-than-a-hemisphere polygons, edges that cross the antimeridian, polygons containing the north or south pole, or issues with loop orientation. Luckly, all these issues can be handled easily if you format and interpret polygons in the right way.
This is my take on “the right way”. Note that these ideas are not new, and if other systems do something different, it is probably because they are constrained by supporting historical formats. (TODO: maybe discuss some differences in an appendix. 2d-native, non-geodesic lines)"><meta itemprop=name content="[WIP] Elements of Spherical Polygons"><meta itemprop=description content="These are some of my notes on constructing spherical polygons, related to my work on the H3 cells-to-polygon functionality.
When working with spherical polygons, “edge cases” often cause problems: larger-than-a-hemisphere polygons, edges that cross the antimeridian, polygons containing the north or south pole, or issues with loop orientation. Luckly, all these issues can be handled easily if you format and interpret polygons in the right way.
This is my take on “the right way”. Note that these ideas are not new, and if other systems do something different, it is probably because they are constrained by supporting historical formats. (TODO: maybe discuss some differences in an appendix. 2d-native, non-geodesic lines)"><meta itemprop=datePublished content="2026-01-02T00:00:00+00:00"><meta itemprop=dateModified content="2026-01-02T00:00:00+00:00"><meta itemprop=wordCount content="1133"><meta name=referrer content="no-referrer-when-downgrade"><style>:root{--width:720px;--font-main:Verdana, sans-serif;--font-secondary:Verdana, sans-serif;--font-scale:1em;--background-color:#fff;--heading-color:#222;--text-color:#444;--link-color:#3273dc;--visited-color:#8b6fcb;--blockquote-color:#222}@media(prefers-color-scheme:dark){:root{--background-color:#01242e;--heading-color:#eee;--text-color:#ddd;--link-color:#8cc2dd;--visited-color:#8b6fcb;--blockquote-color:#ccc}}body{font-family:var(--font-secondary);font-size:var(--font-scale);margin:auto;padding:20px;max-width:var(--width);text-align:left;background-color:var(--background-color);word-wrap:break-word;overflow-wrap:break-word;line-height:1.5;color:var(--text-color)}h1,h2,h3,h4,h5,h6{font-family:var(--font-main);color:var(--heading-color)}a{color:var(--link-color);cursor:pointer;text-decoration:none}a:hover{text-decoration:underline}nav a{margin-right:8px}strong,b{color:var(--heading-color)}button{margin:0;cursor:pointer}time{font-family:monospace;font-style:normal;font-size:15px}main{line-height:1.6}table{width:100%}hr{border:0;border-top:1px dashed}img{max-width:100%}code{font-family:monospace;padding:2px;border-radius:3px}blockquote{border-left:1px solid #999;color:var(--blockquote-color);padding-left:20px;font-style:italic}footer{padding:25px 0;text-align:center}.title:hover{text-decoration:none}.title h1{font-size:1.5em}.inline{width:auto!important}.highlight,.code{border-radius:3px;margin-block-start:1em;margin-block-end:1em;overflow-x:auto}ul.blog-posts{list-style-type:none;padding:unset}ul.blog-posts li{display:flex}ul.blog-posts li span{flex:0 0 130px}ul.blog-posts li a:visited{color:var(--visited-color)}</style><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.css integrity=sha384-nB0miv6/jRmo5UMMR1wu3Gz6NLsoTkbqJghGIsx//Rlm+ZU03BU6SQNC66uf4l5+ crossorigin=anonymous><style>:root{--width:900px}p.caption{text-align:center;font-size:small;font-style:italic;margin-top:-1rem}h1.page-title{font-size:2.2rem;color:#111;margin-bottom:.2rem;border-bottom:2px solid #3273dc;padding-bottom:.3rem}content h1{font-size:1.6rem;color:#333;margin-top:2rem}nav.toc{background:#f8f8f8;padding:1rem 1.5rem;margin-bottom:2rem;border-radius:4px}nav.toc h2{margin-top:0;font-size:1.1rem}nav.toc ul{margin:0;padding-left:1.5rem}nav.toc li{margin:.3rem 0}nav.toc a{text-decoration:none}nav.toc a:hover{text-decoration:underline}.highlight{background:#f6f8fa;border:1px solid #e1e4e8;border-radius:6px;margin:1.5rem 0;overflow-x:auto}.highlight pre{margin:0;padding:.1rem 1rem;background:0 0}.highlight code{font-size:.9rem;line-height:1.5;font-family:sf mono,Consolas,liberation mono,Menlo,monospace}.highlight .ln{color:#999;margin-right:1rem;user-select:none}code:not(.highlight code){background:#f0f0f0;padding:.15rem .4rem;border-radius:3px;font-size:.88em;font-family:sf mono,Consolas,liberation mono,Menlo,monospace}@media(prefers-color-scheme:dark){:root{--background-color:#fff;--heading-color:#222;--text-color:#444;--link-color:#3273dc;--visited-color:#8b6fcb;--blockquote-color:#222}}</style></head><body><header><a href=/ class=title><h2>AJ Friend</h2></a><nav><a href=/>Home</a>
<a href=/blog>Blog</a>
<a href=/software>Software</a>
<a href=/notes>Notes</a></nav></header><main><h1 class=page-title>[WIP] Elements of Spherical Polygons</h1><p><i><time datetime=2026-01-02>2026-01-02</time></i></p><content><p>These are some of my notes on constructing spherical polygons, related to
my work on the H3 cells-to-polygon functionality.</p><p>When working with spherical polygons, &ldquo;edge cases&rdquo; often cause problems: larger-than-a-hemisphere polygons, edges that cross the antimeridian, polygons containing
the north or south pole, or issues with loop orientation.
Luckly, all these issues can be handled easily if you format and interpret polygons
in the right way.</p><p>This is my take on &ldquo;the right way&rdquo;. Note that these ideas are not new, and if other
systems do something different, it is probably because they are constrained by supporting historical formats. (TODO: maybe discuss some differences in an appendix.
2d-native, non-geodesic lines)</p><p>Start with an image in mind. its Hlepful to have an image in mind as we build up from building blocks.</p><p>Rougly, spherical polygon denotes a region on the surface of the unit sphere,
given by an outer ring of points in counter-clockwise order, and zero or more
holes, given by a ring of points in clockwise order.
Of course, there&rsquo;s more detail that we&rsquo;ll go into below.</p><p>(Nod to other formats? GeoJSON. State that this will be agnostic.) List some other formats. Maybe.</p><div class=globe-container id=globe-g0 style="max-width:600px;width:100%;aspect-ratio:1;margin:2em auto"></div><script type=module>
  import * as Plot from 'https://cdn.jsdelivr.net/npm/@observablehq/plot@0.6/+esm';
  import * as d3 from 'https://cdn.jsdelivr.net/npm/d3@7/+esm';
  import { feature } from 'https://cdn.jsdelivr.net/npm/topojson-client@3/+esm';

  (async function() {
    
    
    const geoJsonCoords = [[[[-128.90985381013775,50.15451159756744],[-138.450291223663,41.457139817335765],[-134.10648897177788,31.285608665560563],[-142.7188705783351,22.885971422359724],[-138.42043748614526,11.22287623237951],[-127.11406580207421,8.93189150044687],[-124.29849277976768,-1.4476428602001965],[-114.02904784459382,-5.24292940957167],[-105.17323884809628,0.8701881901666538],[-95.07033345637271,-4.3484866954754455],[-84.77330656823203,2.5046046873156858],[-85.63106856426799,13.836853809820953],[-75.99854824376126,19.35882343539422],[-74.64046816708004,30.21949219982811],[-84.58516703208811,37.099588896819945],[-81.91962699890831,48.295316381881364],[-98.56184761891002,55.218550700351585],[-112.78800392829437,48.011188120377795],[-128.90985381013775,50.15451159756744]],[[-118.48186571718101,16.572699557873406],[-121.3366283326517,28.653019311484535],[-110.25748485653355,36.800197061174266],[-96.66289038040519,31.619530626908528],[-96.05020989622146,19.26900694125663],[-106.5596852317401,12.150574686647923],[-118.48186571718101,16.572699557873406]]]];
    const coords = geoJsonCoords.map(polygon => polygon.map(ring => ring.slice().reverse()));
    const arrowStep =  1 ;
    const poly = {
      type: 'Feature',
      properties: { name: 'Polygon' },
      geometry: { type: 'MultiPolygon', coordinates: coords }
    };

    
    function getEdgeArrows(ring, step = 10) {
      const arrows = [];
      for (let i = 0; i < ring.length - 1; i += step) {
        const p1 = ring[i];
        const p2 = ring[i + 1];
        const interpolate = d3.geoInterpolate(p1, p2);
        
        arrows.push([interpolate(0.4), interpolate(0.6)]);
      }
      return arrows;
    }
    const edgeArrows = arrowStep > 0
      ? geoJsonCoords.flatMap(polygon => polygon.flatMap(ring => getEdgeArrows(ring, arrowStep)))
      : [];

    const container = document.getElementById('globe-g0');
    const getSize = () => {
      const width = container.offsetWidth || container.clientWidth;
      return width > 0 ? Math.min(600, width) : 600;
    };
    
    const inputRotate = null;
    const allPoints = coords.flatMap(polygon => polygon.flatMap(ring => ring));
    const centroid = d3.geoCentroid({ type: 'MultiPoint', coordinates: allPoints });
    
    const centerRotate = inputRotate
      ? [-inputRotate[0], -inputRotate[1], inputRotate[2] ?? 0]
      : [-centroid[0], -centroid[1], 0];
    const state = { rotate: centerRotate, width: getSize(), height: getSize() };

    if (!window.globeLandData) {
      const landTopo = await (await fetch('https://cdn.jsdelivr.net/npm/world-atlas@2/land-110m.json')).json();
      window.globeLandData = feature(landTopo, landTopo.objects.land);
    }
    const land = window.globeLandData;

    function preview(geometryOrFeature, rotate) {
      const marks = [
        Plot.geo(land, { stroke: '#88b', fill: 'none', strokeWidth: 0.8, strokeOpacity: 0.8 }),
        Plot.geo(geometryOrFeature, { fill: 'red', fillOpacity: 0.45, stroke: 'red', strokeOpacity: 0.7 }),
        Plot.graticule({ strokeOpacity: 0.06 }),
        Plot.sphere({ strokeWidth: 2 })
      ];

      if (arrowStep > 0) {
        edgeArrows.forEach(segment => {
          marks.push(Plot.line(segment, {
            x: d => d[0],
            y: d => d[1],
            markerEnd: 'arrow',
            stroke: 'darkred',
            strokeWidth: 1.5
          }));
        });
      }

      return Plot.plot({
        width: state.width,
        height: state.height,
        projection: { type: 'orthographic', rotate, inset: 1 },
        marks
      });
    }

    let frame = null;

    function render() {
      if (frame) return;
      frame = requestAnimationFrame(() => {
        frame = null;
        state.width = getSize();
        state.height = getSize();
        container.innerHTML = '';
        const svg = preview(poly, state.rotate);
        container.appendChild(svg);
        attachDrag(svg);
      });
    }

    window.addEventListener('resize', render);

    function attachDrag(svg) {
      const drag = d3.drag()
        .on('start', (event) => {
          drag.startX = event.x;
          drag.startY = event.y;
          drag.startRotate = state.rotate.slice();
        })
        .on('drag', (event) => {
          const dx = event.x - drag.startX;
          const dy = event.y - drag.startY;
          const k = 0.25;
          state.rotate = [
            drag.startRotate[0] + dx * k,
            drag.startRotate[1] - dy * k,
            0
          ];
          render();
        });
      d3.select(svg).call(drag);
      d3.select(svg).on('dblclick', () => {
        state.rotate = centerRotate.slice();
        render();
      });
    }

    render();
  })();
</script><p class=caption>A polygon with one outer ring (counter-clockwise) and one hole (clockwise).</p><p>You can drag the image (and others in this post) to see different parts of the globe.
Double click to reset the image to whatever I was trying to get you to look at.</p><h1 id=spherical-model-of-earth>Spherical model of Earth</h1><p>In this post, we&rsquo;ll assume the polygons are on the surface of the unit sphere.
While it&rsquo;s true the Earth is roughly a sphere, it&rsquo;s
<a href=https://en.wikipedia.org/wiki/Earth_ellipsoid>better approximated by an ellipsoid</a>.
We&rsquo;ll use the sphere model because that&rsquo;s what H3 uses.</p><p>To compute surface areas on the Earth, you&rsquo;d scale up any areas from the unit
sphere by
<span class=katex><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.8141em></span><span class=mord><span class="mord mathnormal" style=margin-right:.00773em>R</span><span class=msupsub><span class=vlist-t><span class=vlist-r><span class=vlist style=height:.8141em><span style=top:-3.063em;margin-right:.05em><span class=pstrut style=height:2.7em></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>, where
<span class=katex><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.6833em></span><span class="mord mathnormal" style=margin-right:.00773em>R</span><span class=mspace style=margin-right:.2778em></span><span class=mrel>≈</span><span class=mspace style=margin-right:.2778em></span></span><span class=base><span class=strut style=height:.8889em;vertical-align:-.1944em></span><span class=mord>6</span><span class=mord><span class=mpunct>,</span></span><span class=mord>371</span><span class=mspace> </span><span class="mord text"><span class=mord>km</span></span></span></span></span>.</p><h1 id=points>Points</h1><p>We&rsquo;ll describe points on the sphere as the latitude–longitude pair
<span class=katex><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:1em;vertical-align:-.25em></span><span class=mopen>(</span><span class="mord mathnormal" style=margin-right:.02778em>θ</span><span class=mpunct>,</span><span class=mspace style=margin-right:.1667em></span><span class="mord mathnormal">ϕ</span><span class=mclose>)</span></span></span></span>, in units of degrees. Typically, you&rsquo;ll see the values
normalized like</p><span class=katex-display><span class=katex><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:3em;vertical-align:-1.25em></span><span class=mord><span class=mtable><span class=col-align-r><span class="vlist-t vlist-t2"><span class=vlist-r><span class=vlist style=height:1.75em><span style=top:-3.91em><span class=pstrut style=height:3em></span><span class=mord><span class=mord>−</span><span class=mord>90</span></span></span><span style=top:-2.41em><span class=pstrut style=height:3em></span><span class=mord><span class=mord>−</span><span class=mord>180</span></span></span></span><span class=vlist-s>​</span></span><span class=vlist-r><span class=vlist style=height:1.25em><span></span></span></span></span></span><span class=col-align-l><span class="vlist-t vlist-t2"><span class=vlist-r><span class=vlist style=height:1.75em><span style=top:-3.91em><span class=pstrut style=height:3em></span><span class=mord><span class=mord></span><span class=mspace style=margin-right:.2778em></span><span class=mrel>≤</span><span class=mspace style=margin-right:.2778em></span><span class="mord mathnormal" style=margin-right:.02778em>θ</span><span class=mspace style=margin-right:.2778em></span><span class=mrel>≤</span><span class=mspace style=margin-right:.2778em></span><span class=mord>+</span><span class=mord>90</span><span class=mpunct>,</span></span></span><span style=top:-2.41em><span class=pstrut style=height:3em></span><span class=mord><span class=mord></span><span class=mspace style=margin-right:.2778em></span><span class=mrel>&lt;</span><span class=mspace style=margin-right:.2778em></span><span class="mord mathnormal">ϕ</span><span class=mspace style=margin-right:.2778em></span><span class=mrel>≤</span><span class=mspace style=margin-right:.2778em></span><span class=mord>+</span><span class=mord>180</span><span class=mpunct>,</span></span></span></span><span class=vlist-s>​</span></span><span class=vlist-r><span class=vlist style=height:1.25em><span></span></span></span></span></span></span></span></span><span class=tag><span class=strut style=height:3em;vertical-align:-1.25em></span><span class="mord text"><span class=mord>(</span><span class=mord><span class=mord>1</span></span><span class=mord>)</span></span></span></span></span></span><p>but this shouldn&rsquo;t be strictly necessary, as I&rsquo;ll argue below.</p><h2 id=what-doesnt-matter>What doesn&rsquo;t matter</h2><p>There are many other conventions and notations.
Almost everything described here is unchanged if you instead use
longitude–latitude order, radians instead of degrees,
write “lon” instead of “lng”, or use different symbols
(I like
<span class=katex><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.6944em></span><span class="mord mathnormal" style=margin-right:.02778em>θ</span></span></span></span> and
<span class=katex><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.8889em;vertical-align:-.1944em></span><span class="mord mathnormal">ϕ</span></span></span></span> because the little lines go through the little circles mnemonically).</p><p>I might say either 180 degrees or
<span class=katex><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.4306em></span><span class="mord mathnormal" style=margin-right:.03588em>π</span></span></span></span>, meaning the same thing.</p><h2 id=what-does-matter>What <em>does</em> matter</h2><p>&ldquo;one approach is to try and make it unique, like&mldr;&rdquo; but even that doesn&rsquo;t work!
Note that the representation above is not unique; a single point can correspond
to many different
<span class=katex><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:1em;vertical-align:-.25em></span><span class=mopen>(</span><span class="mord mathnormal" style=margin-right:.02778em>θ</span><span class=mpunct>,</span><span class=mspace style=margin-right:.1667em></span><span class="mord mathnormal">ϕ</span><span class=mclose>)</span></span></span></span> pairs.
You&rsquo;ll often see mention of bounds like in Eq. (1) to make the representation
unique, but event that doesn&rsquo;t quite do it:
the north pole can be represented equivalently as
<span class=katex><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:1em;vertical-align:-.25em></span><span class=mopen>(</span><span class=mord>90</span><span class=mpunct>,</span><span class=mspace style=margin-right:.1667em></span><span class=mord>0</span><span class=mclose>)</span></span></span></span> or
<span class=katex><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:1em;vertical-align:-.25em></span><span class=mopen>(</span><span class=mord>90</span><span class=mpunct>,</span><span class=mspace style=margin-right:.1667em></span><span class=mord>10</span><span class=mclose>)</span></span></span></span> or
<span class=katex><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:1em;vertical-align:-.25em></span><span class=mopen>(</span><span class=mord>90</span><span class=mpunct>,</span><span class=mspace style=margin-right:.1667em></span><span class=mord>123456789</span><span class=mclose>)</span></span></span></span>, since the longitude value can
be anything.</p><p>So, instead of trying to make things unique, let&rsquo;s allow it to be anything.
That is, our algorithms should be equivalent for any representations of the same
points, and shouldn&rsquo;t depend on antyhing from the representation outside
of which point on the sphere it represents.</p><p>Another way to say this is via an equivalance class.
We consider all
<span class=katex><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:1em;vertical-align:-.25em></span><span class=mopen>(</span><span class="mord mathnormal" style=margin-right:.02778em>θ</span><span class=mpunct>,</span><span class=mspace style=margin-right:.1667em></span><span class="mord mathnormal">ϕ</span><span class=mclose>)</span></span></span></span> points the same if they map to the same point
on the sphere in 3D, that is:</p><span class=katex-display><span class=katex><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:1em;vertical-align:-.25em></span><span class="mord mathnormal" style=margin-right:.10764em>f</span><span class=mopen>(</span><span class="mord mathnormal" style=margin-right:.02778em>θ</span><span class=mpunct>,</span><span class=mspace style=margin-right:.1667em></span><span class="mord mathnormal">ϕ</span><span class=mclose>)</span><span class=mspace style=margin-right:.2778em></span><span class=mrel>=</span><span class=mspace style=margin-right:.2778em></span></span><span class=base><span class=strut style=height:3.6em;vertical-align:-1.55em></span><span class=minner><span class=mopen><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class=vlist-r><span class=vlist style=height:2.05em><span style=top:-4.05em><span class=pstrut style=height:5.6em></span><span style=width:.667em;height:3.6em><svg width=".667em" height="3.6em" viewBox="0 0 667 3600"><path d="M403 1759V84H666V0H319V1759v0 1759h347v-84H403zm0 0V0H319V1759v0 1759h84z"/></svg></span></span></span><span class=vlist-s>​</span></span><span class=vlist-r><span class=vlist style=height:1.55em><span></span></span></span></span></span></span><span class=mord><span class=mtable><span class=col-align-c><span class="vlist-t vlist-t2"><span class=vlist-r><span class=vlist style=height:2.05em><span style=top:-4.21em><span class=pstrut style=height:3em></span><span class=mord><span class=mop>cos</span><span class=mspace style=margin-right:.1667em></span><span class="mord mathnormal" style=margin-right:.02778em>θ</span><span class=mspace style=margin-right:.1667em></span><span class=mop>cos</span><span class=mspace style=margin-right:.1667em></span><span class="mord mathnormal">ϕ</span></span></span><span style=top:-3.01em><span class=pstrut style=height:3em></span><span class=mord><span class=mop>cos</span><span class=mspace style=margin-right:.1667em></span><span class="mord mathnormal" style=margin-right:.02778em>θ</span><span class=mspace style=margin-right:.1667em></span><span class=mop>sin</span><span class=mspace style=margin-right:.1667em></span><span class="mord mathnormal">ϕ</span></span></span><span style=top:-1.81em><span class=pstrut style=height:3em></span><span class=mord><span class=mop>sin</span><span class=mspace style=margin-right:.1667em></span><span class="mord mathnormal" style=margin-right:.02778em>θ</span></span></span></span><span class=vlist-s>​</span></span><span class=vlist-r><span class=vlist style=height:1.55em><span></span></span></span></span></span></span></span><span class=mclose><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class=vlist-r><span class=vlist style=height:2.05em><span style=top:-4.05em><span class=pstrut style=height:5.6em></span><span style=width:.667em;height:3.6em><svg width=".667em" height="3.6em" viewBox="0 0 667 3600"><path d="M347 1759V0H0V84H263V1759v0 1759H0v84H347zm0 0V0H263V1759v0 1759h84z"/></svg></span></span></span><span class=vlist-s>​</span></span><span class=vlist-r><span class=vlist style=height:1.55em><span></span></span></span></span></span></span></span><span class=mspace style=margin-right:.1667em></span><span class=mord>.</span></span></span></span></span><p>You don&rsquo;t have to actually do that transformation. You just need to make sure
your code respects the equivalence class.</p><p>Note that this definition is nice because it handles all cases:</p><ul><li><span class=katex><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:1em;vertical-align:-.25em></span><span class="mord mathnormal" style=margin-right:.10764em>f</span><span class=mopen>(</span><span class=mord>90</span><span class=mpunct>,</span><span class=mspace style=margin-right:.1667em></span><span class="mord mathnormal">x</span><span class=mclose>)</span><span class=mspace style=margin-right:.2778em></span><span class=mrel>=</span><span class=mspace style=margin-right:.2778em></span></span><span class=base><span class=strut style=height:1em;vertical-align:-.25em></span><span class="mord mathnormal" style=margin-right:.10764em>f</span><span class=mopen>(</span><span class=mord>90</span><span class=mpunct>,</span><span class=mspace style=margin-right:.1667em></span><span class="mord mathnormal" style=margin-right:.03588em>y</span><span class=mclose>)</span></span></span></span> for any
<span class=katex><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.625em;vertical-align:-.1944em></span><span class="mord mathnormal">x</span><span class=mpunct>,</span><span class=mspace style=margin-right:.1667em></span><span class="mord mathnormal" style=margin-right:.03588em>y</span></span></span></span></li><li><span class=katex><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:1em;vertical-align:-.25em></span><span class="mord mathnormal" style=margin-right:.10764em>f</span><span class=mopen>(</span><span class="mord mathnormal" style=margin-right:.02778em>θ</span><span class=mpunct>,</span><span class=mspace style=margin-right:.1667em></span><span class="mord mathnormal">ϕ</span><span class=mclose>)</span><span class=mspace style=margin-right:.2778em></span><span class=mrel>=</span><span class=mspace style=margin-right:.2778em></span></span><span class=base><span class=strut style=height:1em;vertical-align:-.25em></span><span class="mord mathnormal" style=margin-right:.10764em>f</span><span class=mopen>(</span><span class="mord mathnormal" style=margin-right:.02778em>θ</span><span class=mpunct>,</span><span class=mspace style=margin-right:.1667em></span><span class="mord mathnormal">ϕ</span><span class=mspace style=margin-right:.2222em></span><span class=mbin>+</span><span class=mspace style=margin-right:.2222em></span></span><span class=base><span class=strut style=height:1em;vertical-align:-.25em></span><span class=mord>360</span><span class=mclose>)</span></span></span></span></li></ul><p>And we can even extend
<span class=katex><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.6944em></span><span class="mord mathnormal" style=margin-right:.02778em>θ</span></span></span></span> outside its normal bounds. For example
<span class=katex><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:1em;vertical-align:-.25em></span><span class=mopen>(</span><span class=mord>80</span><span class=mpunct>,</span><span class=mspace style=margin-right:.1667em></span><span class=mord>0</span><span class=mclose>)</span></span></span></span> can also be written
<span class=katex><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:1em;vertical-align:-.25em></span><span class=mopen>(</span><span class=mord>110</span><span class=mpunct>,</span><span class=mspace style=margin-right:.1667em></span><span class=mord>180</span><span class=mclose>)</span></span></span></span>. (Does this need an image?)</p><p>Note that, luckily, this is usually taken care of automatically when you&rsquo;re plugging quantities into trig functions. but note that if you&rsquo;re testing
<span class=katex><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.5782em;vertical-align:-.0391em></span><span class="mord mathnormal">x</span><span class=mspace style=margin-right:.2778em></span><span class=mrel>&lt;</span><span class=mspace style=margin-right:.2778em></span></span><span class=base><span class=strut style=height:.625em;vertical-align:-.1944em></span><span class="mord mathnormal" style=margin-right:.03588em>y</span></span></span></span>, you&rsquo;re probably doing it wrong. &ldquo;won&rsquo;t be robust to&mldr;&rdquo;</p><p>non-uniqueness can be a feature. if you&rsquo;re exporting to a system that doesn&rsquo;t handle
the sphere natively, you might want to choose representatives that make it easier.
show the example of a box around antimeridian in mapbox vs D3</p><h2 id=bottom-line-ugh>Bottom line (ugh..)</h2><p>Lat/lng points should be treated as represenatives of a point on 3D sphere,
and algorithms, plots, everything we do should work and look the same
no matter what representation you give them.</p><h1 id=great-circle-arcs>Great circle arcs</h1><p>OK OK. we&rsquo;ll use lon/lat&mldr;</p><p>The great circle arc between <code>(-150, 0)</code> and <code>(0, 0)</code> goes east:</p><p><div class=globe-container id=globe-gm2 style="max-width:1e3px;width:100%;aspect-ratio:2;margin:2em auto"></div><script type=module>
  import * as Plot from 'https://cdn.jsdelivr.net/npm/@observablehq/plot@0.6/+esm';
  import * as d3 from 'https://cdn.jsdelivr.net/npm/d3@7/+esm';
  import { feature } from 'https://cdn.jsdelivr.net/npm/topojson-client@3/+esm';

  (async function() {
    const rawData = {"features":[{"geometry":{"coordinates":[[[0,90],[-150,0],[0,-90],[0,0],[0,90]]],"type":"Polygon"},"properties":{"fill":"gray","fillOpacity":0.35,"strokeWidth":0},"type":"Feature"},{"geometry":{"coordinates":[[-150,0],[0,0]],"type":"LineString"},"properties":{"arrow":true,"stroke":"darkblue","strokeWidth":3},"type":"Feature"},{"geometry":{"coordinates":[[-150,90],[-150,0],[-150,-90]],"type":"LineString"},"properties":{"arrow":false,"stroke":"green","strokeWidth":3},"type":"Feature"},{"geometry":{"coordinates":[-150,0],"type":"Point"},"properties":{"fill":"green","r":5,"stroke":"darkgreen"},"type":"Feature"},{"geometry":{"coordinates":[[-0,90],[-0,0],[-0,-90]],"type":"LineString"},"properties":{"arrow":false,"stroke":"red","strokeWidth":3},"type":"Feature"},{"geometry":{"coordinates":[0,0],"type":"Point"},"properties":{"fill":"red","r":5,"stroke":"darkred"},"type":"Feature"}],"type":"FeatureCollection"};

    if (!rawData || !rawData.features) {
      console.error('globe_map: Invalid or missing data');
      return;
    }

    
    const featureCollection = {
      type: rawData.type,
      features: rawData.features.map(f => {
        if (f.geometry.type === 'Polygon') {
          return {
            ...f,
            geometry: {
              ...f.geometry,
              coordinates: f.geometry.coordinates.map(ring => ring.slice().reverse())
            }
          };
        } else if (f.geometry.type === 'MultiPolygon') {
          return {
            ...f,
            geometry: {
              ...f.geometry,
              coordinates: f.geometry.coordinates.map(polygon =>
                polygon.map(ring => ring.slice().reverse())
              )
            }
          };
        }
        return f;
      })
    };

    const projection = "equirectangular";
    const isGlobe = projection === "orthographic";
    const maxWidth =  1000 ;
    const arrowStep =  0 ;

    const container = document.getElementById('globe-gm2');
    const getSize = () => {
      const width = container.offsetWidth || container.clientWidth;
      const w = width > 0 ? Math.min(maxWidth, width) : maxWidth;
      return { width: w, height: isGlobe ? w : w / 2 };
    };

    
    const inputRotate = null;
    const allPoints = [];
    rawData.features.forEach(f => {
      if (f.geometry.type === 'Point') {
        allPoints.push(f.geometry.coordinates);
      } else if (f.geometry.type === 'LineString') {
        allPoints.push(...f.geometry.coordinates);
      } else if (f.geometry.type === 'Polygon') {
        f.geometry.coordinates.forEach(ring => allPoints.push(...ring));
      } else if (f.geometry.type === 'MultiPolygon') {
        f.geometry.coordinates.forEach(polygon =>
          polygon.forEach(ring => allPoints.push(...ring))
        );
      }
    });
    const centroid = allPoints.length > 0
      ? d3.geoCentroid({ type: 'MultiPoint', coordinates: allPoints })
      : [0, 0];
    const centerRotate = inputRotate
      ? [-inputRotate[0], -inputRotate[1], inputRotate[2] ?? 0]
      : [-centroid[0], -centroid[1], 0];
    const size = getSize();
    const localState = { width: size.width, height: size.height };

    
    if (!window.globeMapSync) {
      window.globeMapSync = {
        rotate: centerRotate,
        centerRotate: centerRotate,
        renders: []
      };
    }
    const sync = window.globeMapSync;

    
    if (sync.renders.length === 0) {
      sync.rotate = centerRotate;
      sync.centerRotate = centerRotate;
    }

    if (!window.globeLandData) {
      const landTopo = await (await fetch('https://cdn.jsdelivr.net/npm/world-atlas@2/land-110m.json')).json();
      window.globeLandData = feature(landTopo, landTopo.objects.land);
    }
    const land = window.globeLandData;

    function render() {
      const size = getSize();
      localState.width = size.width;
      localState.height = size.height;

      const marks = [
        Plot.geo(land, { stroke: '#88b', fill: 'none', strokeWidth: 0.8, strokeOpacity: 0.8 }),
        Plot.graticule({ strokeOpacity: 0.06 })
      ];

      if (isGlobe) {
        marks.push(Plot.sphere({ strokeWidth: 2 }));
      } else {
        marks.push(Plot.frame({ strokeWidth: 1 }));
      }

      
      const polygons = {
        type: 'FeatureCollection',
        features: featureCollection.features.filter(f =>
          f.geometry.type === 'Polygon' || f.geometry.type === 'MultiPolygon'
        )
      };
      const lines = {
        type: 'FeatureCollection',
        features: featureCollection.features.filter(f => f.geometry.type === 'LineString')
      };
      const points = {
        type: 'FeatureCollection',
        features: featureCollection.features.filter(f => f.geometry.type === 'Point')
      };

      
      if (polygons.features.length > 0) {
        marks.push(Plot.geo(polygons, {
          fill: d => d.properties?.fill || 'red',
          fillOpacity: d => d.properties?.fillOpacity ?? 0.45,
          stroke: d => d.properties?.stroke || d.properties?.fill || 'red',
          strokeWidth: d => d.properties?.strokeWidth ?? 1,
          strokeOpacity: d => d.properties?.strokeOpacity ?? 0.7
        }));

        
        if (arrowStep > 0) {
          let edgeIndex = 0;
          
          rawData.features.forEach(f => {
            if (f.geometry.type !== 'Polygon' && f.geometry.type !== 'MultiPolygon') return;
            const stroke = f.properties?.stroke || f.properties?.fill || 'red';
            const strokeWidth = f.properties?.strokeWidth ?? 1;
            const rings = f.geometry.type === 'Polygon'
              ? f.geometry.coordinates
              : f.geometry.coordinates.flat();
            rings.forEach(ring => {
              for (let i = 0; i < ring.length - 1; i++) {
                if (edgeIndex % arrowStep === 0) {
                  const interpolate = d3.geoInterpolate(ring[i], ring[i + 1]);
                  marks.push(Plot.line([interpolate(0.45), interpolate(0.55)], {
                    x: d => d[0],
                    y: d => d[1],
                    markerEnd: 'arrow',
                    stroke: 'darkred',
                    strokeWidth: 1.5
                  }));
                }
                edgeIndex++;
              }
            });
          });
        }
      }

      
      if (lines.features.length > 0) {
        marks.push(Plot.geo(lines, {
          stroke: d => d.properties?.stroke || 'red',
          strokeWidth: d => d.properties?.strokeWidth ?? 2.5,
          strokeOpacity: d => d.properties?.strokeOpacity ?? 0.9
        }));

        
        lines.features.forEach(f => {
          if (f.properties?.arrow) {
            const coords = f.geometry.coordinates;
            for (let i = 0; i < coords.length - 1; i++) {
              const interpolate = d3.geoInterpolate(coords[i], coords[i + 1]);
              marks.push(Plot.line([interpolate(0.45), interpolate(0.55)], {
                x: d => d[0],
                y: d => d[1],
                markerEnd: 'arrow',
                stroke: f.properties?.stroke || 'darkred',
                strokeWidth: f.properties?.strokeWidth ?? 2
              }));
            }
          }
        });
      }

      
      points.features.forEach(f => {
        marks.push(Plot.geo(f, {
          fill: f.properties?.fill || 'red',
          stroke: f.properties?.stroke || 'darkred',
          strokeWidth: f.properties?.strokeWidth ?? 1,
          r: f.properties?.r ?? 5
        }));
      });

      const projectionConfig = isGlobe
        ? { type: projection, rotate: sync.rotate, inset: 1 }
        : { type: projection };

      const svg = Plot.plot({
        width: localState.width,
        height: localState.height,
        projection: projectionConfig,
        marks
      });

      container.innerHTML = '';
      container.appendChild(svg);
      if (isGlobe) {
        attachDrag(svg);
      }
    }

    window.addEventListener('resize', render);

    
    const versor = {
      cartesian: function(e) {
        const l = e[0] * Math.PI / 180, p = e[1] * Math.PI / 180, cp = Math.cos(p);
        return [cp * Math.cos(l), cp * Math.sin(l), Math.sin(p)];
      },
      rotation: function(q) {
        return [
          Math.atan2(2 * (q[0] * q[1] + q[2] * q[3]), 1 - 2 * (q[1] * q[1] + q[2] * q[2])) * 180 / Math.PI,
          Math.asin(Math.max(-1, Math.min(1, 2 * (q[0] * q[2] - q[3] * q[1])))) * 180 / Math.PI,
          Math.atan2(2 * (q[0] * q[3] + q[1] * q[2]), 1 - 2 * (q[2] * q[2] + q[3] * q[3])) * 180 / Math.PI
        ];
      },
      delta: function(v0, v1) {
        const w = this.cross(v0, v1), l = Math.sqrt(this.dot(w, w));
        if (!l) return [1, 0, 0, 0];
        const t = Math.acos(Math.max(-1, Math.min(1, this.dot(v0, v1)))) / 2, s = Math.sin(t);
        return [Math.cos(t), w[2] / l * s, -w[1] / l * s, w[0] / l * s];
      },
      multiply: function(a, b) {
        return [
          a[0] * b[0] - a[1] * b[1] - a[2] * b[2] - a[3] * b[3],
          a[0] * b[1] + a[1] * b[0] + a[2] * b[3] - a[3] * b[2],
          a[0] * b[2] - a[1] * b[3] + a[2] * b[0] + a[3] * b[1],
          a[0] * b[3] + a[1] * b[2] - a[2] * b[1] + a[3] * b[0]
        ];
      },
      from: function(r) {
        const l = r[0] / 2 * Math.PI / 180, p = r[1] / 2 * Math.PI / 180, g = r[2] / 2 * Math.PI / 180;
        const sl = Math.sin(l), cl = Math.cos(l);
        const sp = Math.sin(p), cp = Math.cos(p);
        const sg = Math.sin(g), cg = Math.cos(g);
        return [
          cl * cp * cg + sl * sp * sg,
          sl * cp * cg - cl * sp * sg,
          cl * sp * cg + sl * cp * sg,
          cl * cp * sg - sl * sp * cg
        ];
      },
      cross: function(a, b) { return [a[1]*b[2] - a[2]*b[1], a[2]*b[0] - a[0]*b[2], a[0]*b[1] - a[1]*b[0]]; },
      dot: function(a, b) { return a[0]*b[0] + a[1]*b[1] + a[2]*b[2]; }
    };

    function attachDrag(svg) {
      const projection = d3.geoOrthographic()
        .rotate(sync.rotate)
        .translate([localState.width / 2, localState.height / 2])
        .scale(Math.min(localState.width, localState.height) / 2 - 1);

      let v0, q0, r0;

      const drag = d3.drag()
        .on('start', (event) => {
          projection.rotate(sync.rotate).translate([localState.width / 2, localState.height / 2]).scale(Math.min(localState.width, localState.height) / 2 - 1);
          const inv = projection.invert([event.x, event.y]);
          if (inv) {
            v0 = versor.cartesian(inv);
            r0 = sync.rotate;
            q0 = versor.from(r0);
          }
        })
        .on('drag', (event) => {
          if (!v0) return;
          projection.rotate(r0);
          const inv = projection.invert([event.x, event.y]);
          if (!inv) return;
          const v1 = versor.cartesian(inv);
          const delta = versor.delta(v0, v1);
          const q1 = versor.multiply(q0, delta);
          sync.rotate = versor.rotation(q1);
          
          sync.renders.forEach(r => r());
        });

      d3.select(svg).call(drag);
      d3.select(svg).on('dblclick', () => {
        sync.rotate = sync.centerRotate.slice();
        sync.renders.forEach(r => r());
      });
    }

    
    sync.renders.push(render);

    render();
  })();
</script><p class=caption>Arc from (-150, 0) to (0, 0).</p></p><p>We can see that it takes that route because it is the shortest distance,
looking from above, we can see that it is along the equator along an arc
that&rsquo;s less than 180 degrees:</p><p><div class=globe-container id=globe-gm4 style="max-width:600px;width:100%;aspect-ratio:1;margin:2em auto"></div><script type=module>
  import * as Plot from 'https://cdn.jsdelivr.net/npm/@observablehq/plot@0.6/+esm';
  import * as d3 from 'https://cdn.jsdelivr.net/npm/d3@7/+esm';
  import { feature } from 'https://cdn.jsdelivr.net/npm/topojson-client@3/+esm';

  (async function() {
    const rawData = {"features":[{"geometry":{"coordinates":[[[0,90],[-150,0],[0,-90],[0,0],[0,90]]],"type":"Polygon"},"properties":{"fill":"gray","fillOpacity":0.35,"strokeWidth":0},"type":"Feature"},{"geometry":{"coordinates":[[-150,0],[0,0]],"type":"LineString"},"properties":{"arrow":true,"stroke":"darkblue","strokeWidth":3},"type":"Feature"},{"geometry":{"coordinates":[[-150,90],[-150,0],[-150,-90]],"type":"LineString"},"properties":{"arrow":false,"stroke":"green","strokeWidth":3},"type":"Feature"},{"geometry":{"coordinates":[-150,0],"type":"Point"},"properties":{"fill":"green","r":5,"stroke":"darkgreen"},"type":"Feature"},{"geometry":{"coordinates":[[-0,90],[-0,0],[-0,-90]],"type":"LineString"},"properties":{"arrow":false,"stroke":"red","strokeWidth":3},"type":"Feature"},{"geometry":{"coordinates":[0,0],"type":"Point"},"properties":{"fill":"red","r":5,"stroke":"darkred"},"type":"Feature"}],"type":"FeatureCollection"};

    if (!rawData || !rawData.features) {
      console.error('globe_map: Invalid or missing data');
      return;
    }

    
    const featureCollection = {
      type: rawData.type,
      features: rawData.features.map(f => {
        if (f.geometry.type === 'Polygon') {
          return {
            ...f,
            geometry: {
              ...f.geometry,
              coordinates: f.geometry.coordinates.map(ring => ring.slice().reverse())
            }
          };
        } else if (f.geometry.type === 'MultiPolygon') {
          return {
            ...f,
            geometry: {
              ...f.geometry,
              coordinates: f.geometry.coordinates.map(polygon =>
                polygon.map(ring => ring.slice().reverse())
              )
            }
          };
        }
        return f;
      })
    };

    const projection = "orthographic";
    const isGlobe = projection === "orthographic";
    const maxWidth =  600 ;
    const arrowStep =  0 ;

    const container = document.getElementById('globe-gm4');
    const getSize = () => {
      const width = container.offsetWidth || container.clientWidth;
      const w = width > 0 ? Math.min(maxWidth, width) : maxWidth;
      return { width: w, height: isGlobe ? w : w / 2 };
    };

    
    const inputRotate = [0, 90, 60];
    const allPoints = [];
    rawData.features.forEach(f => {
      if (f.geometry.type === 'Point') {
        allPoints.push(f.geometry.coordinates);
      } else if (f.geometry.type === 'LineString') {
        allPoints.push(...f.geometry.coordinates);
      } else if (f.geometry.type === 'Polygon') {
        f.geometry.coordinates.forEach(ring => allPoints.push(...ring));
      } else if (f.geometry.type === 'MultiPolygon') {
        f.geometry.coordinates.forEach(polygon =>
          polygon.forEach(ring => allPoints.push(...ring))
        );
      }
    });
    const centroid = allPoints.length > 0
      ? d3.geoCentroid({ type: 'MultiPoint', coordinates: allPoints })
      : [0, 0];
    const centerRotate = inputRotate
      ? [-inputRotate[0], -inputRotate[1], inputRotate[2] ?? 0]
      : [-centroid[0], -centroid[1], 0];
    const size = getSize();
    const localState = { width: size.width, height: size.height };

    
    if (!window.globeMapSync) {
      window.globeMapSync = {
        rotate: centerRotate,
        centerRotate: centerRotate,
        renders: []
      };
    }
    const sync = window.globeMapSync;

    
    if (sync.renders.length === 0) {
      sync.rotate = centerRotate;
      sync.centerRotate = centerRotate;
    }

    if (!window.globeLandData) {
      const landTopo = await (await fetch('https://cdn.jsdelivr.net/npm/world-atlas@2/land-110m.json')).json();
      window.globeLandData = feature(landTopo, landTopo.objects.land);
    }
    const land = window.globeLandData;

    function render() {
      const size = getSize();
      localState.width = size.width;
      localState.height = size.height;

      const marks = [
        Plot.geo(land, { stroke: '#88b', fill: 'none', strokeWidth: 0.8, strokeOpacity: 0.8 }),
        Plot.graticule({ strokeOpacity: 0.06 })
      ];

      if (isGlobe) {
        marks.push(Plot.sphere({ strokeWidth: 2 }));
      } else {
        marks.push(Plot.frame({ strokeWidth: 1 }));
      }

      
      const polygons = {
        type: 'FeatureCollection',
        features: featureCollection.features.filter(f =>
          f.geometry.type === 'Polygon' || f.geometry.type === 'MultiPolygon'
        )
      };
      const lines = {
        type: 'FeatureCollection',
        features: featureCollection.features.filter(f => f.geometry.type === 'LineString')
      };
      const points = {
        type: 'FeatureCollection',
        features: featureCollection.features.filter(f => f.geometry.type === 'Point')
      };

      
      if (polygons.features.length > 0) {
        marks.push(Plot.geo(polygons, {
          fill: d => d.properties?.fill || 'red',
          fillOpacity: d => d.properties?.fillOpacity ?? 0.45,
          stroke: d => d.properties?.stroke || d.properties?.fill || 'red',
          strokeWidth: d => d.properties?.strokeWidth ?? 1,
          strokeOpacity: d => d.properties?.strokeOpacity ?? 0.7
        }));

        
        if (arrowStep > 0) {
          let edgeIndex = 0;
          
          rawData.features.forEach(f => {
            if (f.geometry.type !== 'Polygon' && f.geometry.type !== 'MultiPolygon') return;
            const stroke = f.properties?.stroke || f.properties?.fill || 'red';
            const strokeWidth = f.properties?.strokeWidth ?? 1;
            const rings = f.geometry.type === 'Polygon'
              ? f.geometry.coordinates
              : f.geometry.coordinates.flat();
            rings.forEach(ring => {
              for (let i = 0; i < ring.length - 1; i++) {
                if (edgeIndex % arrowStep === 0) {
                  const interpolate = d3.geoInterpolate(ring[i], ring[i + 1]);
                  marks.push(Plot.line([interpolate(0.45), interpolate(0.55)], {
                    x: d => d[0],
                    y: d => d[1],
                    markerEnd: 'arrow',
                    stroke: 'darkred',
                    strokeWidth: 1.5
                  }));
                }
                edgeIndex++;
              }
            });
          });
        }
      }

      
      if (lines.features.length > 0) {
        marks.push(Plot.geo(lines, {
          stroke: d => d.properties?.stroke || 'red',
          strokeWidth: d => d.properties?.strokeWidth ?? 2.5,
          strokeOpacity: d => d.properties?.strokeOpacity ?? 0.9
        }));

        
        lines.features.forEach(f => {
          if (f.properties?.arrow) {
            const coords = f.geometry.coordinates;
            for (let i = 0; i < coords.length - 1; i++) {
              const interpolate = d3.geoInterpolate(coords[i], coords[i + 1]);
              marks.push(Plot.line([interpolate(0.45), interpolate(0.55)], {
                x: d => d[0],
                y: d => d[1],
                markerEnd: 'arrow',
                stroke: f.properties?.stroke || 'darkred',
                strokeWidth: f.properties?.strokeWidth ?? 2
              }));
            }
          }
        });
      }

      
      points.features.forEach(f => {
        marks.push(Plot.geo(f, {
          fill: f.properties?.fill || 'red',
          stroke: f.properties?.stroke || 'darkred',
          strokeWidth: f.properties?.strokeWidth ?? 1,
          r: f.properties?.r ?? 5
        }));
      });

      const projectionConfig = isGlobe
        ? { type: projection, rotate: sync.rotate, inset: 1 }
        : { type: projection };

      const svg = Plot.plot({
        width: localState.width,
        height: localState.height,
        projection: projectionConfig,
        marks
      });

      container.innerHTML = '';
      container.appendChild(svg);
      if (isGlobe) {
        attachDrag(svg);
      }
    }

    window.addEventListener('resize', render);

    
    const versor = {
      cartesian: function(e) {
        const l = e[0] * Math.PI / 180, p = e[1] * Math.PI / 180, cp = Math.cos(p);
        return [cp * Math.cos(l), cp * Math.sin(l), Math.sin(p)];
      },
      rotation: function(q) {
        return [
          Math.atan2(2 * (q[0] * q[1] + q[2] * q[3]), 1 - 2 * (q[1] * q[1] + q[2] * q[2])) * 180 / Math.PI,
          Math.asin(Math.max(-1, Math.min(1, 2 * (q[0] * q[2] - q[3] * q[1])))) * 180 / Math.PI,
          Math.atan2(2 * (q[0] * q[3] + q[1] * q[2]), 1 - 2 * (q[2] * q[2] + q[3] * q[3])) * 180 / Math.PI
        ];
      },
      delta: function(v0, v1) {
        const w = this.cross(v0, v1), l = Math.sqrt(this.dot(w, w));
        if (!l) return [1, 0, 0, 0];
        const t = Math.acos(Math.max(-1, Math.min(1, this.dot(v0, v1)))) / 2, s = Math.sin(t);
        return [Math.cos(t), w[2] / l * s, -w[1] / l * s, w[0] / l * s];
      },
      multiply: function(a, b) {
        return [
          a[0] * b[0] - a[1] * b[1] - a[2] * b[2] - a[3] * b[3],
          a[0] * b[1] + a[1] * b[0] + a[2] * b[3] - a[3] * b[2],
          a[0] * b[2] - a[1] * b[3] + a[2] * b[0] + a[3] * b[1],
          a[0] * b[3] + a[1] * b[2] - a[2] * b[1] + a[3] * b[0]
        ];
      },
      from: function(r) {
        const l = r[0] / 2 * Math.PI / 180, p = r[1] / 2 * Math.PI / 180, g = r[2] / 2 * Math.PI / 180;
        const sl = Math.sin(l), cl = Math.cos(l);
        const sp = Math.sin(p), cp = Math.cos(p);
        const sg = Math.sin(g), cg = Math.cos(g);
        return [
          cl * cp * cg + sl * sp * sg,
          sl * cp * cg - cl * sp * sg,
          cl * sp * cg + sl * cp * sg,
          cl * cp * sg - sl * sp * cg
        ];
      },
      cross: function(a, b) { return [a[1]*b[2] - a[2]*b[1], a[2]*b[0] - a[0]*b[2], a[0]*b[1] - a[1]*b[0]]; },
      dot: function(a, b) { return a[0]*b[0] + a[1]*b[1] + a[2]*b[2]; }
    };

    function attachDrag(svg) {
      const projection = d3.geoOrthographic()
        .rotate(sync.rotate)
        .translate([localState.width / 2, localState.height / 2])
        .scale(Math.min(localState.width, localState.height) / 2 - 1);

      let v0, q0, r0;

      const drag = d3.drag()
        .on('start', (event) => {
          projection.rotate(sync.rotate).translate([localState.width / 2, localState.height / 2]).scale(Math.min(localState.width, localState.height) / 2 - 1);
          const inv = projection.invert([event.x, event.y]);
          if (inv) {
            v0 = versor.cartesian(inv);
            r0 = sync.rotate;
            q0 = versor.from(r0);
          }
        })
        .on('drag', (event) => {
          if (!v0) return;
          projection.rotate(r0);
          const inv = projection.invert([event.x, event.y]);
          if (!inv) return;
          const v1 = versor.cartesian(inv);
          const delta = versor.delta(v0, v1);
          const q1 = versor.multiply(q0, delta);
          sync.rotate = versor.rotation(q1);
          
          sync.renders.forEach(r => r());
        });

      d3.select(svg).call(drag);
      d3.select(svg).on('dblclick', () => {
        sync.rotate = sync.centerRotate.slice();
        sync.renders.forEach(r => r());
      });
    }

    
    sync.renders.push(render);

    render();
  })();
</script><p class=caption>Arc from (-150, 0) to (0, 0).</p></p><p>However, if we extend the endpoint further east and look
at the arc connecting <code>(-150, 0)</code> and <code>(+60, 0)</code>, we see that everything changes.
The arc changes direction and goes around the globe in the other direction.</p><p><div class=globe-container id=globe-gm6 style="max-width:1e3px;width:100%;aspect-ratio:2;margin:2em auto"></div><script type=module>
  import * as Plot from 'https://cdn.jsdelivr.net/npm/@observablehq/plot@0.6/+esm';
  import * as d3 from 'https://cdn.jsdelivr.net/npm/d3@7/+esm';
  import { feature } from 'https://cdn.jsdelivr.net/npm/topojson-client@3/+esm';

  (async function() {
    const rawData = {"features":[{"geometry":{"coordinates":[[[0,90],[60,0],[0,-90],[-150,0],[0,90]]],"type":"Polygon"},"properties":{"fill":"gray","fillOpacity":0.35,"strokeWidth":0},"type":"Feature"},{"geometry":{"coordinates":[[-150,0],[60,0]],"type":"LineString"},"properties":{"arrow":true,"stroke":"darkblue","strokeWidth":3},"type":"Feature"},{"geometry":{"coordinates":[[-150,90],[-150,0],[-150,-90]],"type":"LineString"},"properties":{"arrow":false,"stroke":"green","strokeWidth":3},"type":"Feature"},{"geometry":{"coordinates":[-150,0],"type":"Point"},"properties":{"fill":"green","r":5,"stroke":"darkgreen"},"type":"Feature"},{"geometry":{"coordinates":[[60,90],[60,0],[60,-90]],"type":"LineString"},"properties":{"arrow":false,"stroke":"red","strokeWidth":3},"type":"Feature"},{"geometry":{"coordinates":[60,0],"type":"Point"},"properties":{"fill":"red","r":5,"stroke":"darkred"},"type":"Feature"}],"type":"FeatureCollection"};

    if (!rawData || !rawData.features) {
      console.error('globe_map: Invalid or missing data');
      return;
    }

    
    const featureCollection = {
      type: rawData.type,
      features: rawData.features.map(f => {
        if (f.geometry.type === 'Polygon') {
          return {
            ...f,
            geometry: {
              ...f.geometry,
              coordinates: f.geometry.coordinates.map(ring => ring.slice().reverse())
            }
          };
        } else if (f.geometry.type === 'MultiPolygon') {
          return {
            ...f,
            geometry: {
              ...f.geometry,
              coordinates: f.geometry.coordinates.map(polygon =>
                polygon.map(ring => ring.slice().reverse())
              )
            }
          };
        }
        return f;
      })
    };

    const projection = "equirectangular";
    const isGlobe = projection === "orthographic";
    const maxWidth =  1000 ;
    const arrowStep =  0 ;

    const container = document.getElementById('globe-gm6');
    const getSize = () => {
      const width = container.offsetWidth || container.clientWidth;
      const w = width > 0 ? Math.min(maxWidth, width) : maxWidth;
      return { width: w, height: isGlobe ? w : w / 2 };
    };

    
    const inputRotate = null;
    const allPoints = [];
    rawData.features.forEach(f => {
      if (f.geometry.type === 'Point') {
        allPoints.push(f.geometry.coordinates);
      } else if (f.geometry.type === 'LineString') {
        allPoints.push(...f.geometry.coordinates);
      } else if (f.geometry.type === 'Polygon') {
        f.geometry.coordinates.forEach(ring => allPoints.push(...ring));
      } else if (f.geometry.type === 'MultiPolygon') {
        f.geometry.coordinates.forEach(polygon =>
          polygon.forEach(ring => allPoints.push(...ring))
        );
      }
    });
    const centroid = allPoints.length > 0
      ? d3.geoCentroid({ type: 'MultiPoint', coordinates: allPoints })
      : [0, 0];
    const centerRotate = inputRotate
      ? [-inputRotate[0], -inputRotate[1], inputRotate[2] ?? 0]
      : [-centroid[0], -centroid[1], 0];
    const size = getSize();
    const localState = { width: size.width, height: size.height };

    
    if (!window.globeMapSync) {
      window.globeMapSync = {
        rotate: centerRotate,
        centerRotate: centerRotate,
        renders: []
      };
    }
    const sync = window.globeMapSync;

    
    if (sync.renders.length === 0) {
      sync.rotate = centerRotate;
      sync.centerRotate = centerRotate;
    }

    if (!window.globeLandData) {
      const landTopo = await (await fetch('https://cdn.jsdelivr.net/npm/world-atlas@2/land-110m.json')).json();
      window.globeLandData = feature(landTopo, landTopo.objects.land);
    }
    const land = window.globeLandData;

    function render() {
      const size = getSize();
      localState.width = size.width;
      localState.height = size.height;

      const marks = [
        Plot.geo(land, { stroke: '#88b', fill: 'none', strokeWidth: 0.8, strokeOpacity: 0.8 }),
        Plot.graticule({ strokeOpacity: 0.06 })
      ];

      if (isGlobe) {
        marks.push(Plot.sphere({ strokeWidth: 2 }));
      } else {
        marks.push(Plot.frame({ strokeWidth: 1 }));
      }

      
      const polygons = {
        type: 'FeatureCollection',
        features: featureCollection.features.filter(f =>
          f.geometry.type === 'Polygon' || f.geometry.type === 'MultiPolygon'
        )
      };
      const lines = {
        type: 'FeatureCollection',
        features: featureCollection.features.filter(f => f.geometry.type === 'LineString')
      };
      const points = {
        type: 'FeatureCollection',
        features: featureCollection.features.filter(f => f.geometry.type === 'Point')
      };

      
      if (polygons.features.length > 0) {
        marks.push(Plot.geo(polygons, {
          fill: d => d.properties?.fill || 'red',
          fillOpacity: d => d.properties?.fillOpacity ?? 0.45,
          stroke: d => d.properties?.stroke || d.properties?.fill || 'red',
          strokeWidth: d => d.properties?.strokeWidth ?? 1,
          strokeOpacity: d => d.properties?.strokeOpacity ?? 0.7
        }));

        
        if (arrowStep > 0) {
          let edgeIndex = 0;
          
          rawData.features.forEach(f => {
            if (f.geometry.type !== 'Polygon' && f.geometry.type !== 'MultiPolygon') return;
            const stroke = f.properties?.stroke || f.properties?.fill || 'red';
            const strokeWidth = f.properties?.strokeWidth ?? 1;
            const rings = f.geometry.type === 'Polygon'
              ? f.geometry.coordinates
              : f.geometry.coordinates.flat();
            rings.forEach(ring => {
              for (let i = 0; i < ring.length - 1; i++) {
                if (edgeIndex % arrowStep === 0) {
                  const interpolate = d3.geoInterpolate(ring[i], ring[i + 1]);
                  marks.push(Plot.line([interpolate(0.45), interpolate(0.55)], {
                    x: d => d[0],
                    y: d => d[1],
                    markerEnd: 'arrow',
                    stroke: 'darkred',
                    strokeWidth: 1.5
                  }));
                }
                edgeIndex++;
              }
            });
          });
        }
      }

      
      if (lines.features.length > 0) {
        marks.push(Plot.geo(lines, {
          stroke: d => d.properties?.stroke || 'red',
          strokeWidth: d => d.properties?.strokeWidth ?? 2.5,
          strokeOpacity: d => d.properties?.strokeOpacity ?? 0.9
        }));

        
        lines.features.forEach(f => {
          if (f.properties?.arrow) {
            const coords = f.geometry.coordinates;
            for (let i = 0; i < coords.length - 1; i++) {
              const interpolate = d3.geoInterpolate(coords[i], coords[i + 1]);
              marks.push(Plot.line([interpolate(0.45), interpolate(0.55)], {
                x: d => d[0],
                y: d => d[1],
                markerEnd: 'arrow',
                stroke: f.properties?.stroke || 'darkred',
                strokeWidth: f.properties?.strokeWidth ?? 2
              }));
            }
          }
        });
      }

      
      points.features.forEach(f => {
        marks.push(Plot.geo(f, {
          fill: f.properties?.fill || 'red',
          stroke: f.properties?.stroke || 'darkred',
          strokeWidth: f.properties?.strokeWidth ?? 1,
          r: f.properties?.r ?? 5
        }));
      });

      const projectionConfig = isGlobe
        ? { type: projection, rotate: sync.rotate, inset: 1 }
        : { type: projection };

      const svg = Plot.plot({
        width: localState.width,
        height: localState.height,
        projection: projectionConfig,
        marks
      });

      container.innerHTML = '';
      container.appendChild(svg);
      if (isGlobe) {
        attachDrag(svg);
      }
    }

    window.addEventListener('resize', render);

    
    const versor = {
      cartesian: function(e) {
        const l = e[0] * Math.PI / 180, p = e[1] * Math.PI / 180, cp = Math.cos(p);
        return [cp * Math.cos(l), cp * Math.sin(l), Math.sin(p)];
      },
      rotation: function(q) {
        return [
          Math.atan2(2 * (q[0] * q[1] + q[2] * q[3]), 1 - 2 * (q[1] * q[1] + q[2] * q[2])) * 180 / Math.PI,
          Math.asin(Math.max(-1, Math.min(1, 2 * (q[0] * q[2] - q[3] * q[1])))) * 180 / Math.PI,
          Math.atan2(2 * (q[0] * q[3] + q[1] * q[2]), 1 - 2 * (q[2] * q[2] + q[3] * q[3])) * 180 / Math.PI
        ];
      },
      delta: function(v0, v1) {
        const w = this.cross(v0, v1), l = Math.sqrt(this.dot(w, w));
        if (!l) return [1, 0, 0, 0];
        const t = Math.acos(Math.max(-1, Math.min(1, this.dot(v0, v1)))) / 2, s = Math.sin(t);
        return [Math.cos(t), w[2] / l * s, -w[1] / l * s, w[0] / l * s];
      },
      multiply: function(a, b) {
        return [
          a[0] * b[0] - a[1] * b[1] - a[2] * b[2] - a[3] * b[3],
          a[0] * b[1] + a[1] * b[0] + a[2] * b[3] - a[3] * b[2],
          a[0] * b[2] - a[1] * b[3] + a[2] * b[0] + a[3] * b[1],
          a[0] * b[3] + a[1] * b[2] - a[2] * b[1] + a[3] * b[0]
        ];
      },
      from: function(r) {
        const l = r[0] / 2 * Math.PI / 180, p = r[1] / 2 * Math.PI / 180, g = r[2] / 2 * Math.PI / 180;
        const sl = Math.sin(l), cl = Math.cos(l);
        const sp = Math.sin(p), cp = Math.cos(p);
        const sg = Math.sin(g), cg = Math.cos(g);
        return [
          cl * cp * cg + sl * sp * sg,
          sl * cp * cg - cl * sp * sg,
          cl * sp * cg + sl * cp * sg,
          cl * cp * sg - sl * sp * cg
        ];
      },
      cross: function(a, b) { return [a[1]*b[2] - a[2]*b[1], a[2]*b[0] - a[0]*b[2], a[0]*b[1] - a[1]*b[0]]; },
      dot: function(a, b) { return a[0]*b[0] + a[1]*b[1] + a[2]*b[2]; }
    };

    function attachDrag(svg) {
      const projection = d3.geoOrthographic()
        .rotate(sync.rotate)
        .translate([localState.width / 2, localState.height / 2])
        .scale(Math.min(localState.width, localState.height) / 2 - 1);

      let v0, q0, r0;

      const drag = d3.drag()
        .on('start', (event) => {
          projection.rotate(sync.rotate).translate([localState.width / 2, localState.height / 2]).scale(Math.min(localState.width, localState.height) / 2 - 1);
          const inv = projection.invert([event.x, event.y]);
          if (inv) {
            v0 = versor.cartesian(inv);
            r0 = sync.rotate;
            q0 = versor.from(r0);
          }
        })
        .on('drag', (event) => {
          if (!v0) return;
          projection.rotate(r0);
          const inv = projection.invert([event.x, event.y]);
          if (!inv) return;
          const v1 = versor.cartesian(inv);
          const delta = versor.delta(v0, v1);
          const q1 = versor.multiply(q0, delta);
          sync.rotate = versor.rotation(q1);
          
          sync.renders.forEach(r => r());
        });

      d3.select(svg).call(drag);
      d3.select(svg).on('dblclick', () => {
        sync.rotate = sync.centerRotate.slice();
        sync.renders.forEach(r => r());
      });
    }

    
    sync.renders.push(render);

    render();
  })();
</script><p class=caption>Arc from (-150, 0) to (+60, 0).</p></p><p>Confirm its the shortest path because its going good good:</p><p><div class=globe-container id=globe-gm8 style="max-width:600px;width:100%;aspect-ratio:1;margin:2em auto"></div><script type=module>
  import * as Plot from 'https://cdn.jsdelivr.net/npm/@observablehq/plot@0.6/+esm';
  import * as d3 from 'https://cdn.jsdelivr.net/npm/d3@7/+esm';
  import { feature } from 'https://cdn.jsdelivr.net/npm/topojson-client@3/+esm';

  (async function() {
    const rawData = {"features":[{"geometry":{"coordinates":[[[0,90],[60,0],[0,-90],[-150,0],[0,90]]],"type":"Polygon"},"properties":{"fill":"gray","fillOpacity":0.35,"strokeWidth":0},"type":"Feature"},{"geometry":{"coordinates":[[-150,0],[60,0]],"type":"LineString"},"properties":{"arrow":true,"stroke":"darkblue","strokeWidth":3},"type":"Feature"},{"geometry":{"coordinates":[[-150,90],[-150,0],[-150,-90]],"type":"LineString"},"properties":{"arrow":false,"stroke":"green","strokeWidth":3},"type":"Feature"},{"geometry":{"coordinates":[-150,0],"type":"Point"},"properties":{"fill":"green","r":5,"stroke":"darkgreen"},"type":"Feature"},{"geometry":{"coordinates":[[60,90],[60,0],[60,-90]],"type":"LineString"},"properties":{"arrow":false,"stroke":"red","strokeWidth":3},"type":"Feature"},{"geometry":{"coordinates":[60,0],"type":"Point"},"properties":{"fill":"red","r":5,"stroke":"darkred"},"type":"Feature"}],"type":"FeatureCollection"};

    if (!rawData || !rawData.features) {
      console.error('globe_map: Invalid or missing data');
      return;
    }

    
    const featureCollection = {
      type: rawData.type,
      features: rawData.features.map(f => {
        if (f.geometry.type === 'Polygon') {
          return {
            ...f,
            geometry: {
              ...f.geometry,
              coordinates: f.geometry.coordinates.map(ring => ring.slice().reverse())
            }
          };
        } else if (f.geometry.type === 'MultiPolygon') {
          return {
            ...f,
            geometry: {
              ...f.geometry,
              coordinates: f.geometry.coordinates.map(polygon =>
                polygon.map(ring => ring.slice().reverse())
              )
            }
          };
        }
        return f;
      })
    };

    const projection = "orthographic";
    const isGlobe = projection === "orthographic";
    const maxWidth =  600 ;
    const arrowStep =  0 ;

    const container = document.getElementById('globe-gm8');
    const getSize = () => {
      const width = container.offsetWidth || container.clientWidth;
      const w = width > 0 ? Math.min(maxWidth, width) : maxWidth;
      return { width: w, height: isGlobe ? w : w / 2 };
    };

    
    const inputRotate = [0, 90, 60];
    const allPoints = [];
    rawData.features.forEach(f => {
      if (f.geometry.type === 'Point') {
        allPoints.push(f.geometry.coordinates);
      } else if (f.geometry.type === 'LineString') {
        allPoints.push(...f.geometry.coordinates);
      } else if (f.geometry.type === 'Polygon') {
        f.geometry.coordinates.forEach(ring => allPoints.push(...ring));
      } else if (f.geometry.type === 'MultiPolygon') {
        f.geometry.coordinates.forEach(polygon =>
          polygon.forEach(ring => allPoints.push(...ring))
        );
      }
    });
    const centroid = allPoints.length > 0
      ? d3.geoCentroid({ type: 'MultiPoint', coordinates: allPoints })
      : [0, 0];
    const centerRotate = inputRotate
      ? [-inputRotate[0], -inputRotate[1], inputRotate[2] ?? 0]
      : [-centroid[0], -centroid[1], 0];
    const size = getSize();
    const localState = { width: size.width, height: size.height };

    
    if (!window.globeMapSync) {
      window.globeMapSync = {
        rotate: centerRotate,
        centerRotate: centerRotate,
        renders: []
      };
    }
    const sync = window.globeMapSync;

    
    if (sync.renders.length === 0) {
      sync.rotate = centerRotate;
      sync.centerRotate = centerRotate;
    }

    if (!window.globeLandData) {
      const landTopo = await (await fetch('https://cdn.jsdelivr.net/npm/world-atlas@2/land-110m.json')).json();
      window.globeLandData = feature(landTopo, landTopo.objects.land);
    }
    const land = window.globeLandData;

    function render() {
      const size = getSize();
      localState.width = size.width;
      localState.height = size.height;

      const marks = [
        Plot.geo(land, { stroke: '#88b', fill: 'none', strokeWidth: 0.8, strokeOpacity: 0.8 }),
        Plot.graticule({ strokeOpacity: 0.06 })
      ];

      if (isGlobe) {
        marks.push(Plot.sphere({ strokeWidth: 2 }));
      } else {
        marks.push(Plot.frame({ strokeWidth: 1 }));
      }

      
      const polygons = {
        type: 'FeatureCollection',
        features: featureCollection.features.filter(f =>
          f.geometry.type === 'Polygon' || f.geometry.type === 'MultiPolygon'
        )
      };
      const lines = {
        type: 'FeatureCollection',
        features: featureCollection.features.filter(f => f.geometry.type === 'LineString')
      };
      const points = {
        type: 'FeatureCollection',
        features: featureCollection.features.filter(f => f.geometry.type === 'Point')
      };

      
      if (polygons.features.length > 0) {
        marks.push(Plot.geo(polygons, {
          fill: d => d.properties?.fill || 'red',
          fillOpacity: d => d.properties?.fillOpacity ?? 0.45,
          stroke: d => d.properties?.stroke || d.properties?.fill || 'red',
          strokeWidth: d => d.properties?.strokeWidth ?? 1,
          strokeOpacity: d => d.properties?.strokeOpacity ?? 0.7
        }));

        
        if (arrowStep > 0) {
          let edgeIndex = 0;
          
          rawData.features.forEach(f => {
            if (f.geometry.type !== 'Polygon' && f.geometry.type !== 'MultiPolygon') return;
            const stroke = f.properties?.stroke || f.properties?.fill || 'red';
            const strokeWidth = f.properties?.strokeWidth ?? 1;
            const rings = f.geometry.type === 'Polygon'
              ? f.geometry.coordinates
              : f.geometry.coordinates.flat();
            rings.forEach(ring => {
              for (let i = 0; i < ring.length - 1; i++) {
                if (edgeIndex % arrowStep === 0) {
                  const interpolate = d3.geoInterpolate(ring[i], ring[i + 1]);
                  marks.push(Plot.line([interpolate(0.45), interpolate(0.55)], {
                    x: d => d[0],
                    y: d => d[1],
                    markerEnd: 'arrow',
                    stroke: 'darkred',
                    strokeWidth: 1.5
                  }));
                }
                edgeIndex++;
              }
            });
          });
        }
      }

      
      if (lines.features.length > 0) {
        marks.push(Plot.geo(lines, {
          stroke: d => d.properties?.stroke || 'red',
          strokeWidth: d => d.properties?.strokeWidth ?? 2.5,
          strokeOpacity: d => d.properties?.strokeOpacity ?? 0.9
        }));

        
        lines.features.forEach(f => {
          if (f.properties?.arrow) {
            const coords = f.geometry.coordinates;
            for (let i = 0; i < coords.length - 1; i++) {
              const interpolate = d3.geoInterpolate(coords[i], coords[i + 1]);
              marks.push(Plot.line([interpolate(0.45), interpolate(0.55)], {
                x: d => d[0],
                y: d => d[1],
                markerEnd: 'arrow',
                stroke: f.properties?.stroke || 'darkred',
                strokeWidth: f.properties?.strokeWidth ?? 2
              }));
            }
          }
        });
      }

      
      points.features.forEach(f => {
        marks.push(Plot.geo(f, {
          fill: f.properties?.fill || 'red',
          stroke: f.properties?.stroke || 'darkred',
          strokeWidth: f.properties?.strokeWidth ?? 1,
          r: f.properties?.r ?? 5
        }));
      });

      const projectionConfig = isGlobe
        ? { type: projection, rotate: sync.rotate, inset: 1 }
        : { type: projection };

      const svg = Plot.plot({
        width: localState.width,
        height: localState.height,
        projection: projectionConfig,
        marks
      });

      container.innerHTML = '';
      container.appendChild(svg);
      if (isGlobe) {
        attachDrag(svg);
      }
    }

    window.addEventListener('resize', render);

    
    const versor = {
      cartesian: function(e) {
        const l = e[0] * Math.PI / 180, p = e[1] * Math.PI / 180, cp = Math.cos(p);
        return [cp * Math.cos(l), cp * Math.sin(l), Math.sin(p)];
      },
      rotation: function(q) {
        return [
          Math.atan2(2 * (q[0] * q[1] + q[2] * q[3]), 1 - 2 * (q[1] * q[1] + q[2] * q[2])) * 180 / Math.PI,
          Math.asin(Math.max(-1, Math.min(1, 2 * (q[0] * q[2] - q[3] * q[1])))) * 180 / Math.PI,
          Math.atan2(2 * (q[0] * q[3] + q[1] * q[2]), 1 - 2 * (q[2] * q[2] + q[3] * q[3])) * 180 / Math.PI
        ];
      },
      delta: function(v0, v1) {
        const w = this.cross(v0, v1), l = Math.sqrt(this.dot(w, w));
        if (!l) return [1, 0, 0, 0];
        const t = Math.acos(Math.max(-1, Math.min(1, this.dot(v0, v1)))) / 2, s = Math.sin(t);
        return [Math.cos(t), w[2] / l * s, -w[1] / l * s, w[0] / l * s];
      },
      multiply: function(a, b) {
        return [
          a[0] * b[0] - a[1] * b[1] - a[2] * b[2] - a[3] * b[3],
          a[0] * b[1] + a[1] * b[0] + a[2] * b[3] - a[3] * b[2],
          a[0] * b[2] - a[1] * b[3] + a[2] * b[0] + a[3] * b[1],
          a[0] * b[3] + a[1] * b[2] - a[2] * b[1] + a[3] * b[0]
        ];
      },
      from: function(r) {
        const l = r[0] / 2 * Math.PI / 180, p = r[1] / 2 * Math.PI / 180, g = r[2] / 2 * Math.PI / 180;
        const sl = Math.sin(l), cl = Math.cos(l);
        const sp = Math.sin(p), cp = Math.cos(p);
        const sg = Math.sin(g), cg = Math.cos(g);
        return [
          cl * cp * cg + sl * sp * sg,
          sl * cp * cg - cl * sp * sg,
          cl * sp * cg + sl * cp * sg,
          cl * cp * sg - sl * sp * cg
        ];
      },
      cross: function(a, b) { return [a[1]*b[2] - a[2]*b[1], a[2]*b[0] - a[0]*b[2], a[0]*b[1] - a[1]*b[0]]; },
      dot: function(a, b) { return a[0]*b[0] + a[1]*b[1] + a[2]*b[2]; }
    };

    function attachDrag(svg) {
      const projection = d3.geoOrthographic()
        .rotate(sync.rotate)
        .translate([localState.width / 2, localState.height / 2])
        .scale(Math.min(localState.width, localState.height) / 2 - 1);

      let v0, q0, r0;

      const drag = d3.drag()
        .on('start', (event) => {
          projection.rotate(sync.rotate).translate([localState.width / 2, localState.height / 2]).scale(Math.min(localState.width, localState.height) / 2 - 1);
          const inv = projection.invert([event.x, event.y]);
          if (inv) {
            v0 = versor.cartesian(inv);
            r0 = sync.rotate;
            q0 = versor.from(r0);
          }
        })
        .on('drag', (event) => {
          if (!v0) return;
          projection.rotate(r0);
          const inv = projection.invert([event.x, event.y]);
          if (!inv) return;
          const v1 = versor.cartesian(inv);
          const delta = versor.delta(v0, v1);
          const q1 = versor.multiply(q0, delta);
          sync.rotate = versor.rotation(q1);
          
          sync.renders.forEach(r => r());
        });

      d3.select(svg).call(drag);
      d3.select(svg).on('dblclick', () => {
        sync.rotate = sync.centerRotate.slice();
        sync.renders.forEach(r => r());
      });
    }

    
    sync.renders.push(render);

    render();
  })();
</script><p class=caption>Arc from (-150, 0) to (+60, 0).</p></p><p>But it is possible to represent that path, we just need to add an intermediate
point to break up the any arcs that would otherwise be
<span class=katex><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.7719em;vertical-align:-.136em></span><span class=mrel>≥</span><span class=mspace style=margin-right:.2778em></span></span><span class=base><span class=strut style=height:.6444em></span><span class=mord>180</span></span></span></span> degrees:</p><p><div class=globe-container id=globe-gma style="max-width:1e3px;width:100%;aspect-ratio:2;margin:2em auto"></div><script type=module>
  import * as Plot from 'https://cdn.jsdelivr.net/npm/@observablehq/plot@0.6/+esm';
  import * as d3 from 'https://cdn.jsdelivr.net/npm/d3@7/+esm';
  import { feature } from 'https://cdn.jsdelivr.net/npm/topojson-client@3/+esm';

  (async function() {
    const rawData = {"features":[{"geometry":{"coordinates":[[[0,90],[-150,0],[0,-90],[60,0],[0,90]]],"type":"Polygon"},"properties":{"fill":"gray","fillOpacity":0.35,"strokeWidth":0},"type":"Feature"},{"geometry":{"coordinates":[[-150,0],[0,0],[60,0]],"type":"LineString"},"properties":{"arrow":true,"stroke":"darkblue","strokeWidth":3},"type":"Feature"},{"geometry":{"coordinates":[[-150,90],[-150,0],[-150,-90]],"type":"LineString"},"properties":{"arrow":false,"stroke":"green","strokeWidth":3},"type":"Feature"},{"geometry":{"coordinates":[-150,0],"type":"Point"},"properties":{"fill":"green","r":5,"stroke":"darkgreen"},"type":"Feature"},{"geometry":{"coordinates":[[60,90],[60,0],[60,-90]],"type":"LineString"},"properties":{"arrow":false,"stroke":"red","strokeWidth":3},"type":"Feature"},{"geometry":{"coordinates":[60,0],"type":"Point"},"properties":{"fill":"red","r":5,"stroke":"darkred"},"type":"Feature"},{"geometry":{"coordinates":[0,0],"type":"Point"},"properties":{"fill":"blue","r":5,"stroke":"darkblue"},"type":"Feature"}],"type":"FeatureCollection"};

    if (!rawData || !rawData.features) {
      console.error('globe_map: Invalid or missing data');
      return;
    }

    
    const featureCollection = {
      type: rawData.type,
      features: rawData.features.map(f => {
        if (f.geometry.type === 'Polygon') {
          return {
            ...f,
            geometry: {
              ...f.geometry,
              coordinates: f.geometry.coordinates.map(ring => ring.slice().reverse())
            }
          };
        } else if (f.geometry.type === 'MultiPolygon') {
          return {
            ...f,
            geometry: {
              ...f.geometry,
              coordinates: f.geometry.coordinates.map(polygon =>
                polygon.map(ring => ring.slice().reverse())
              )
            }
          };
        }
        return f;
      })
    };

    const projection = "equirectangular";
    const isGlobe = projection === "orthographic";
    const maxWidth =  1000 ;
    const arrowStep =  0 ;

    const container = document.getElementById('globe-gma');
    const getSize = () => {
      const width = container.offsetWidth || container.clientWidth;
      const w = width > 0 ? Math.min(maxWidth, width) : maxWidth;
      return { width: w, height: isGlobe ? w : w / 2 };
    };

    
    const inputRotate = null;
    const allPoints = [];
    rawData.features.forEach(f => {
      if (f.geometry.type === 'Point') {
        allPoints.push(f.geometry.coordinates);
      } else if (f.geometry.type === 'LineString') {
        allPoints.push(...f.geometry.coordinates);
      } else if (f.geometry.type === 'Polygon') {
        f.geometry.coordinates.forEach(ring => allPoints.push(...ring));
      } else if (f.geometry.type === 'MultiPolygon') {
        f.geometry.coordinates.forEach(polygon =>
          polygon.forEach(ring => allPoints.push(...ring))
        );
      }
    });
    const centroid = allPoints.length > 0
      ? d3.geoCentroid({ type: 'MultiPoint', coordinates: allPoints })
      : [0, 0];
    const centerRotate = inputRotate
      ? [-inputRotate[0], -inputRotate[1], inputRotate[2] ?? 0]
      : [-centroid[0], -centroid[1], 0];
    const size = getSize();
    const localState = { width: size.width, height: size.height };

    
    if (!window.globeMapSync) {
      window.globeMapSync = {
        rotate: centerRotate,
        centerRotate: centerRotate,
        renders: []
      };
    }
    const sync = window.globeMapSync;

    
    if (sync.renders.length === 0) {
      sync.rotate = centerRotate;
      sync.centerRotate = centerRotate;
    }

    if (!window.globeLandData) {
      const landTopo = await (await fetch('https://cdn.jsdelivr.net/npm/world-atlas@2/land-110m.json')).json();
      window.globeLandData = feature(landTopo, landTopo.objects.land);
    }
    const land = window.globeLandData;

    function render() {
      const size = getSize();
      localState.width = size.width;
      localState.height = size.height;

      const marks = [
        Plot.geo(land, { stroke: '#88b', fill: 'none', strokeWidth: 0.8, strokeOpacity: 0.8 }),
        Plot.graticule({ strokeOpacity: 0.06 })
      ];

      if (isGlobe) {
        marks.push(Plot.sphere({ strokeWidth: 2 }));
      } else {
        marks.push(Plot.frame({ strokeWidth: 1 }));
      }

      
      const polygons = {
        type: 'FeatureCollection',
        features: featureCollection.features.filter(f =>
          f.geometry.type === 'Polygon' || f.geometry.type === 'MultiPolygon'
        )
      };
      const lines = {
        type: 'FeatureCollection',
        features: featureCollection.features.filter(f => f.geometry.type === 'LineString')
      };
      const points = {
        type: 'FeatureCollection',
        features: featureCollection.features.filter(f => f.geometry.type === 'Point')
      };

      
      if (polygons.features.length > 0) {
        marks.push(Plot.geo(polygons, {
          fill: d => d.properties?.fill || 'red',
          fillOpacity: d => d.properties?.fillOpacity ?? 0.45,
          stroke: d => d.properties?.stroke || d.properties?.fill || 'red',
          strokeWidth: d => d.properties?.strokeWidth ?? 1,
          strokeOpacity: d => d.properties?.strokeOpacity ?? 0.7
        }));

        
        if (arrowStep > 0) {
          let edgeIndex = 0;
          
          rawData.features.forEach(f => {
            if (f.geometry.type !== 'Polygon' && f.geometry.type !== 'MultiPolygon') return;
            const stroke = f.properties?.stroke || f.properties?.fill || 'red';
            const strokeWidth = f.properties?.strokeWidth ?? 1;
            const rings = f.geometry.type === 'Polygon'
              ? f.geometry.coordinates
              : f.geometry.coordinates.flat();
            rings.forEach(ring => {
              for (let i = 0; i < ring.length - 1; i++) {
                if (edgeIndex % arrowStep === 0) {
                  const interpolate = d3.geoInterpolate(ring[i], ring[i + 1]);
                  marks.push(Plot.line([interpolate(0.45), interpolate(0.55)], {
                    x: d => d[0],
                    y: d => d[1],
                    markerEnd: 'arrow',
                    stroke: 'darkred',
                    strokeWidth: 1.5
                  }));
                }
                edgeIndex++;
              }
            });
          });
        }
      }

      
      if (lines.features.length > 0) {
        marks.push(Plot.geo(lines, {
          stroke: d => d.properties?.stroke || 'red',
          strokeWidth: d => d.properties?.strokeWidth ?? 2.5,
          strokeOpacity: d => d.properties?.strokeOpacity ?? 0.9
        }));

        
        lines.features.forEach(f => {
          if (f.properties?.arrow) {
            const coords = f.geometry.coordinates;
            for (let i = 0; i < coords.length - 1; i++) {
              const interpolate = d3.geoInterpolate(coords[i], coords[i + 1]);
              marks.push(Plot.line([interpolate(0.45), interpolate(0.55)], {
                x: d => d[0],
                y: d => d[1],
                markerEnd: 'arrow',
                stroke: f.properties?.stroke || 'darkred',
                strokeWidth: f.properties?.strokeWidth ?? 2
              }));
            }
          }
        });
      }

      
      points.features.forEach(f => {
        marks.push(Plot.geo(f, {
          fill: f.properties?.fill || 'red',
          stroke: f.properties?.stroke || 'darkred',
          strokeWidth: f.properties?.strokeWidth ?? 1,
          r: f.properties?.r ?? 5
        }));
      });

      const projectionConfig = isGlobe
        ? { type: projection, rotate: sync.rotate, inset: 1 }
        : { type: projection };

      const svg = Plot.plot({
        width: localState.width,
        height: localState.height,
        projection: projectionConfig,
        marks
      });

      container.innerHTML = '';
      container.appendChild(svg);
      if (isGlobe) {
        attachDrag(svg);
      }
    }

    window.addEventListener('resize', render);

    
    const versor = {
      cartesian: function(e) {
        const l = e[0] * Math.PI / 180, p = e[1] * Math.PI / 180, cp = Math.cos(p);
        return [cp * Math.cos(l), cp * Math.sin(l), Math.sin(p)];
      },
      rotation: function(q) {
        return [
          Math.atan2(2 * (q[0] * q[1] + q[2] * q[3]), 1 - 2 * (q[1] * q[1] + q[2] * q[2])) * 180 / Math.PI,
          Math.asin(Math.max(-1, Math.min(1, 2 * (q[0] * q[2] - q[3] * q[1])))) * 180 / Math.PI,
          Math.atan2(2 * (q[0] * q[3] + q[1] * q[2]), 1 - 2 * (q[2] * q[2] + q[3] * q[3])) * 180 / Math.PI
        ];
      },
      delta: function(v0, v1) {
        const w = this.cross(v0, v1), l = Math.sqrt(this.dot(w, w));
        if (!l) return [1, 0, 0, 0];
        const t = Math.acos(Math.max(-1, Math.min(1, this.dot(v0, v1)))) / 2, s = Math.sin(t);
        return [Math.cos(t), w[2] / l * s, -w[1] / l * s, w[0] / l * s];
      },
      multiply: function(a, b) {
        return [
          a[0] * b[0] - a[1] * b[1] - a[2] * b[2] - a[3] * b[3],
          a[0] * b[1] + a[1] * b[0] + a[2] * b[3] - a[3] * b[2],
          a[0] * b[2] - a[1] * b[3] + a[2] * b[0] + a[3] * b[1],
          a[0] * b[3] + a[1] * b[2] - a[2] * b[1] + a[3] * b[0]
        ];
      },
      from: function(r) {
        const l = r[0] / 2 * Math.PI / 180, p = r[1] / 2 * Math.PI / 180, g = r[2] / 2 * Math.PI / 180;
        const sl = Math.sin(l), cl = Math.cos(l);
        const sp = Math.sin(p), cp = Math.cos(p);
        const sg = Math.sin(g), cg = Math.cos(g);
        return [
          cl * cp * cg + sl * sp * sg,
          sl * cp * cg - cl * sp * sg,
          cl * sp * cg + sl * cp * sg,
          cl * cp * sg - sl * sp * cg
        ];
      },
      cross: function(a, b) { return [a[1]*b[2] - a[2]*b[1], a[2]*b[0] - a[0]*b[2], a[0]*b[1] - a[1]*b[0]]; },
      dot: function(a, b) { return a[0]*b[0] + a[1]*b[1] + a[2]*b[2]; }
    };

    function attachDrag(svg) {
      const projection = d3.geoOrthographic()
        .rotate(sync.rotate)
        .translate([localState.width / 2, localState.height / 2])
        .scale(Math.min(localState.width, localState.height) / 2 - 1);

      let v0, q0, r0;

      const drag = d3.drag()
        .on('start', (event) => {
          projection.rotate(sync.rotate).translate([localState.width / 2, localState.height / 2]).scale(Math.min(localState.width, localState.height) / 2 - 1);
          const inv = projection.invert([event.x, event.y]);
          if (inv) {
            v0 = versor.cartesian(inv);
            r0 = sync.rotate;
            q0 = versor.from(r0);
          }
        })
        .on('drag', (event) => {
          if (!v0) return;
          projection.rotate(r0);
          const inv = projection.invert([event.x, event.y]);
          if (!inv) return;
          const v1 = versor.cartesian(inv);
          const delta = versor.delta(v0, v1);
          const q1 = versor.multiply(q0, delta);
          sync.rotate = versor.rotation(q1);
          
          sync.renders.forEach(r => r());
        });

      d3.select(svg).call(drag);
      d3.select(svg).on('dblclick', () => {
        sync.rotate = sync.centerRotate.slice();
        sync.renders.forEach(r => r());
      });
    }

    
    sync.renders.push(render);

    render();
  })();
</script><p class=caption>Two arcs from (-150, 0) to (0, 0) to (+60, 0) sweep out an arc larger than 180 degrees.</p></p><p><div class=globe-container id=globe-gmc style="max-width:600px;width:100%;aspect-ratio:1;margin:2em auto"></div><script type=module>
  import * as Plot from 'https://cdn.jsdelivr.net/npm/@observablehq/plot@0.6/+esm';
  import * as d3 from 'https://cdn.jsdelivr.net/npm/d3@7/+esm';
  import { feature } from 'https://cdn.jsdelivr.net/npm/topojson-client@3/+esm';

  (async function() {
    const rawData = {"features":[{"geometry":{"coordinates":[[[0,90],[-150,0],[0,-90],[60,0],[0,90]]],"type":"Polygon"},"properties":{"fill":"gray","fillOpacity":0.35,"strokeWidth":0},"type":"Feature"},{"geometry":{"coordinates":[[-150,0],[0,0],[60,0]],"type":"LineString"},"properties":{"arrow":true,"stroke":"darkblue","strokeWidth":3},"type":"Feature"},{"geometry":{"coordinates":[[-150,90],[-150,0],[-150,-90]],"type":"LineString"},"properties":{"arrow":false,"stroke":"green","strokeWidth":3},"type":"Feature"},{"geometry":{"coordinates":[-150,0],"type":"Point"},"properties":{"fill":"green","r":5,"stroke":"darkgreen"},"type":"Feature"},{"geometry":{"coordinates":[[60,90],[60,0],[60,-90]],"type":"LineString"},"properties":{"arrow":false,"stroke":"red","strokeWidth":3},"type":"Feature"},{"geometry":{"coordinates":[60,0],"type":"Point"},"properties":{"fill":"red","r":5,"stroke":"darkred"},"type":"Feature"},{"geometry":{"coordinates":[0,0],"type":"Point"},"properties":{"fill":"blue","r":5,"stroke":"darkblue"},"type":"Feature"}],"type":"FeatureCollection"};

    if (!rawData || !rawData.features) {
      console.error('globe_map: Invalid or missing data');
      return;
    }

    
    const featureCollection = {
      type: rawData.type,
      features: rawData.features.map(f => {
        if (f.geometry.type === 'Polygon') {
          return {
            ...f,
            geometry: {
              ...f.geometry,
              coordinates: f.geometry.coordinates.map(ring => ring.slice().reverse())
            }
          };
        } else if (f.geometry.type === 'MultiPolygon') {
          return {
            ...f,
            geometry: {
              ...f.geometry,
              coordinates: f.geometry.coordinates.map(polygon =>
                polygon.map(ring => ring.slice().reverse())
              )
            }
          };
        }
        return f;
      })
    };

    const projection = "orthographic";
    const isGlobe = projection === "orthographic";
    const maxWidth =  600 ;
    const arrowStep =  0 ;

    const container = document.getElementById('globe-gmc');
    const getSize = () => {
      const width = container.offsetWidth || container.clientWidth;
      const w = width > 0 ? Math.min(maxWidth, width) : maxWidth;
      return { width: w, height: isGlobe ? w : w / 2 };
    };

    
    const inputRotate = [0, 90, 60];
    const allPoints = [];
    rawData.features.forEach(f => {
      if (f.geometry.type === 'Point') {
        allPoints.push(f.geometry.coordinates);
      } else if (f.geometry.type === 'LineString') {
        allPoints.push(...f.geometry.coordinates);
      } else if (f.geometry.type === 'Polygon') {
        f.geometry.coordinates.forEach(ring => allPoints.push(...ring));
      } else if (f.geometry.type === 'MultiPolygon') {
        f.geometry.coordinates.forEach(polygon =>
          polygon.forEach(ring => allPoints.push(...ring))
        );
      }
    });
    const centroid = allPoints.length > 0
      ? d3.geoCentroid({ type: 'MultiPoint', coordinates: allPoints })
      : [0, 0];
    const centerRotate = inputRotate
      ? [-inputRotate[0], -inputRotate[1], inputRotate[2] ?? 0]
      : [-centroid[0], -centroid[1], 0];
    const size = getSize();
    const localState = { width: size.width, height: size.height };

    
    if (!window.globeMapSync) {
      window.globeMapSync = {
        rotate: centerRotate,
        centerRotate: centerRotate,
        renders: []
      };
    }
    const sync = window.globeMapSync;

    
    if (sync.renders.length === 0) {
      sync.rotate = centerRotate;
      sync.centerRotate = centerRotate;
    }

    if (!window.globeLandData) {
      const landTopo = await (await fetch('https://cdn.jsdelivr.net/npm/world-atlas@2/land-110m.json')).json();
      window.globeLandData = feature(landTopo, landTopo.objects.land);
    }
    const land = window.globeLandData;

    function render() {
      const size = getSize();
      localState.width = size.width;
      localState.height = size.height;

      const marks = [
        Plot.geo(land, { stroke: '#88b', fill: 'none', strokeWidth: 0.8, strokeOpacity: 0.8 }),
        Plot.graticule({ strokeOpacity: 0.06 })
      ];

      if (isGlobe) {
        marks.push(Plot.sphere({ strokeWidth: 2 }));
      } else {
        marks.push(Plot.frame({ strokeWidth: 1 }));
      }

      
      const polygons = {
        type: 'FeatureCollection',
        features: featureCollection.features.filter(f =>
          f.geometry.type === 'Polygon' || f.geometry.type === 'MultiPolygon'
        )
      };
      const lines = {
        type: 'FeatureCollection',
        features: featureCollection.features.filter(f => f.geometry.type === 'LineString')
      };
      const points = {
        type: 'FeatureCollection',
        features: featureCollection.features.filter(f => f.geometry.type === 'Point')
      };

      
      if (polygons.features.length > 0) {
        marks.push(Plot.geo(polygons, {
          fill: d => d.properties?.fill || 'red',
          fillOpacity: d => d.properties?.fillOpacity ?? 0.45,
          stroke: d => d.properties?.stroke || d.properties?.fill || 'red',
          strokeWidth: d => d.properties?.strokeWidth ?? 1,
          strokeOpacity: d => d.properties?.strokeOpacity ?? 0.7
        }));

        
        if (arrowStep > 0) {
          let edgeIndex = 0;
          
          rawData.features.forEach(f => {
            if (f.geometry.type !== 'Polygon' && f.geometry.type !== 'MultiPolygon') return;
            const stroke = f.properties?.stroke || f.properties?.fill || 'red';
            const strokeWidth = f.properties?.strokeWidth ?? 1;
            const rings = f.geometry.type === 'Polygon'
              ? f.geometry.coordinates
              : f.geometry.coordinates.flat();
            rings.forEach(ring => {
              for (let i = 0; i < ring.length - 1; i++) {
                if (edgeIndex % arrowStep === 0) {
                  const interpolate = d3.geoInterpolate(ring[i], ring[i + 1]);
                  marks.push(Plot.line([interpolate(0.45), interpolate(0.55)], {
                    x: d => d[0],
                    y: d => d[1],
                    markerEnd: 'arrow',
                    stroke: 'darkred',
                    strokeWidth: 1.5
                  }));
                }
                edgeIndex++;
              }
            });
          });
        }
      }

      
      if (lines.features.length > 0) {
        marks.push(Plot.geo(lines, {
          stroke: d => d.properties?.stroke || 'red',
          strokeWidth: d => d.properties?.strokeWidth ?? 2.5,
          strokeOpacity: d => d.properties?.strokeOpacity ?? 0.9
        }));

        
        lines.features.forEach(f => {
          if (f.properties?.arrow) {
            const coords = f.geometry.coordinates;
            for (let i = 0; i < coords.length - 1; i++) {
              const interpolate = d3.geoInterpolate(coords[i], coords[i + 1]);
              marks.push(Plot.line([interpolate(0.45), interpolate(0.55)], {
                x: d => d[0],
                y: d => d[1],
                markerEnd: 'arrow',
                stroke: f.properties?.stroke || 'darkred',
                strokeWidth: f.properties?.strokeWidth ?? 2
              }));
            }
          }
        });
      }

      
      points.features.forEach(f => {
        marks.push(Plot.geo(f, {
          fill: f.properties?.fill || 'red',
          stroke: f.properties?.stroke || 'darkred',
          strokeWidth: f.properties?.strokeWidth ?? 1,
          r: f.properties?.r ?? 5
        }));
      });

      const projectionConfig = isGlobe
        ? { type: projection, rotate: sync.rotate, inset: 1 }
        : { type: projection };

      const svg = Plot.plot({
        width: localState.width,
        height: localState.height,
        projection: projectionConfig,
        marks
      });

      container.innerHTML = '';
      container.appendChild(svg);
      if (isGlobe) {
        attachDrag(svg);
      }
    }

    window.addEventListener('resize', render);

    
    const versor = {
      cartesian: function(e) {
        const l = e[0] * Math.PI / 180, p = e[1] * Math.PI / 180, cp = Math.cos(p);
        return [cp * Math.cos(l), cp * Math.sin(l), Math.sin(p)];
      },
      rotation: function(q) {
        return [
          Math.atan2(2 * (q[0] * q[1] + q[2] * q[3]), 1 - 2 * (q[1] * q[1] + q[2] * q[2])) * 180 / Math.PI,
          Math.asin(Math.max(-1, Math.min(1, 2 * (q[0] * q[2] - q[3] * q[1])))) * 180 / Math.PI,
          Math.atan2(2 * (q[0] * q[3] + q[1] * q[2]), 1 - 2 * (q[2] * q[2] + q[3] * q[3])) * 180 / Math.PI
        ];
      },
      delta: function(v0, v1) {
        const w = this.cross(v0, v1), l = Math.sqrt(this.dot(w, w));
        if (!l) return [1, 0, 0, 0];
        const t = Math.acos(Math.max(-1, Math.min(1, this.dot(v0, v1)))) / 2, s = Math.sin(t);
        return [Math.cos(t), w[2] / l * s, -w[1] / l * s, w[0] / l * s];
      },
      multiply: function(a, b) {
        return [
          a[0] * b[0] - a[1] * b[1] - a[2] * b[2] - a[3] * b[3],
          a[0] * b[1] + a[1] * b[0] + a[2] * b[3] - a[3] * b[2],
          a[0] * b[2] - a[1] * b[3] + a[2] * b[0] + a[3] * b[1],
          a[0] * b[3] + a[1] * b[2] - a[2] * b[1] + a[3] * b[0]
        ];
      },
      from: function(r) {
        const l = r[0] / 2 * Math.PI / 180, p = r[1] / 2 * Math.PI / 180, g = r[2] / 2 * Math.PI / 180;
        const sl = Math.sin(l), cl = Math.cos(l);
        const sp = Math.sin(p), cp = Math.cos(p);
        const sg = Math.sin(g), cg = Math.cos(g);
        return [
          cl * cp * cg + sl * sp * sg,
          sl * cp * cg - cl * sp * sg,
          cl * sp * cg + sl * cp * sg,
          cl * cp * sg - sl * sp * cg
        ];
      },
      cross: function(a, b) { return [a[1]*b[2] - a[2]*b[1], a[2]*b[0] - a[0]*b[2], a[0]*b[1] - a[1]*b[0]]; },
      dot: function(a, b) { return a[0]*b[0] + a[1]*b[1] + a[2]*b[2]; }
    };

    function attachDrag(svg) {
      const projection = d3.geoOrthographic()
        .rotate(sync.rotate)
        .translate([localState.width / 2, localState.height / 2])
        .scale(Math.min(localState.width, localState.height) / 2 - 1);

      let v0, q0, r0;

      const drag = d3.drag()
        .on('start', (event) => {
          projection.rotate(sync.rotate).translate([localState.width / 2, localState.height / 2]).scale(Math.min(localState.width, localState.height) / 2 - 1);
          const inv = projection.invert([event.x, event.y]);
          if (inv) {
            v0 = versor.cartesian(inv);
            r0 = sync.rotate;
            q0 = versor.from(r0);
          }
        })
        .on('drag', (event) => {
          if (!v0) return;
          projection.rotate(r0);
          const inv = projection.invert([event.x, event.y]);
          if (!inv) return;
          const v1 = versor.cartesian(inv);
          const delta = versor.delta(v0, v1);
          const q1 = versor.multiply(q0, delta);
          sync.rotate = versor.rotation(q1);
          
          sync.renders.forEach(r => r());
        });

      d3.select(svg).call(drag);
      d3.select(svg).on('dblclick', () => {
        sync.rotate = sync.centerRotate.slice();
        sync.renders.forEach(r => r());
      });
    }

    
    sync.renders.push(render);

    render();
  })();
</script><p class=caption>Two arcs from (-150, 0) to (0, 0) to (+60, 0) sweep out an arc larger than 180 degrees.</p></p><h2 id=summary>Summary</h2><p>don&rsquo;t be exactly 180 degrees.</p><p>Note, in the example above, that there&rsquo;s no problem with an arc crossing the antimeridian; we just need to remember that all arcs will be interpreted as
their &lt; 180 degree arc. (maybe this is the section summary.)</p><p>All these were along the equator, but its the same anywhere on the globe.</p><p>Direction depends on the ordering of the pair of points: always go from
point one to point 2, along the shortest great circle arc. There are two options,
take the shorter one.</p><h1 id=rings>Rings</h1><p>TODO: good digrammatic polygon with winding order, holes, polys inside polys</p><p>What you&rsquo;ll learn:</p><ul><li>what a spherical polygon is</li><li>common formats</li><li>lat/lng/ lng/lat. rads degress</li><li>antimeridian and wrapping</li><li>right hand rule clockwise ordering of points</li><li>why the &ldquo;outer&rdquo; loop is kinda arbitrary</li><li>how to surround most of the world in a meter of rope. &ndash; tag</li><li>nothing about any specific format, but what you learn here should generalize.</li></ul><p>What you won&rsquo;t learn:</p><ul><li>lat/lng order</li><li>extra vertex repeated at end</li></ul><p>Here&rsquo;s a twisted polygon on the globe (drag to rotate, double-click to reset):</p><div class=globe-container id=globe-ge style="max-width:600px;width:100%;aspect-ratio:1;margin:2em auto"></div><script type=module>
  import * as Plot from 'https://cdn.jsdelivr.net/npm/@observablehq/plot@0.6/+esm';
  import * as d3 from 'https://cdn.jsdelivr.net/npm/d3@7/+esm';
  import { feature } from 'https://cdn.jsdelivr.net/npm/topojson-client@3/+esm';

  (async function() {
    
    
    const geoJsonCoords = [[[[-115.6016830241182,75.13310683752093],[-98.25189182399922,75.42296242259827],[-84.34895424909982,78.73560128535237],[-65.32649015145262,76.66757659192989],[-45.91067006571702,77.6358967544068],[-34.75841798028464,81.27137179020501],[-51.70487751530809,84.93555635380528],[8.384360674741012,87.82361750161158],[145.5581976913369,87.36469532319619],[-161.89171801085914,84.22628942426208],[-176.36726611745192,79.98369865816576],[160.68630381362877,78.12011723529922],[136.93797037496347,79.32046590614668],[126.86805888148528,75.09700284062423],[109.85869817326203,73.85683569908095],[94.14309010184776,76.163042830191],[82.2191189236603,72.9747801211237],[67.04817195975176,73.26746640072776],[62.34534495650971,69.39359648991828],[50.52420090534295,68.52987901066768],[46.47229116360072,69.82855264652378],[41.09749729154039,70.96471952348472],[31.831280499087377,68.92995788193983],[31.517537185292593,64.87303661186431],[24.517172437523477,62.478113451924735],[17.535446308408336,63.800792653212156],[15.771773841154108,62.889968357962516],[11.080660058482366,61.5405146000252],[8.644221197607186,61.8908384753262],[4.012620898449968,63.3270613280184],[-2.2975260876218146,61.54550957788075],[-10.444977544778325,63.095054077525454],[-16.37196241724275,60.568693514800785],[-20.65092627345633,60.98827691429016],[-24.57076597472634,61.43040476232069],[-29.882335644494077,58.03211375817635],[-37.741944187946864,58.170123409126475],[-42.19852987664649,61.972726906031674],[-51.550082921060856,61.33081918088026],[-54.16389762671933,56.86222737436078],[-62.07826603752657,55.37451169620835],[-69.0549959056329,58.110019274352645],[-76.55890845203461,55.6803963083049],[-84.54003278821037,57.52364604763142],[-90.6514460154606,54.300916137492074],[-98.56184761891002,55.218550700351585],[-102.90229770085304,51.55677580791122],[-109.99461055319725,51.75486598535891],[-114.22928039520944,55.4783881395021],[-121.4424549287285,54.916649815151494],[-123.12286550407035,50.984711281689044],[-128.90985381013775,50.154511597567456],[-133.85114156470928,52.84669103300532],[-138.99195596812496,51.52127910420027],[-142.45878105924547,52.9686073691119],[-144.4245651319535,53.21749558931391],[-147.55974651599715,51.50437545423507],[-148.41135616643643,50.423740032442545],[-153.78137213372952,50.5331018823282],[-157.28277091871553,54.01377148101902],[-163.66453871424696,53.773571456509124],[-165.61336675442524,49.89597414875072],[-171.87311046039585,49.05085282910134],[-177.04785603399293,52.113519976620616],[176.3024402828945,50.63969712744497],[175.6209968167824,46.180014657090155],[169.66101739290986,44.17622039141847],[163.91021485526235,46.48282657751594],[158.38289640953528,43.912304017571415],[152.544806053949,45.62266462732754],[147.81728377284585,42.633406882356155],[142.3058437365082,43.816094965537175],[140.81932027711574,47.94353494620577],[137.965723000237,48.30438780776228],[134.76393627595755,48.41801789173906],[131.77440098149353,45.2536134909801],[125.98114176677377,45.09643436908034],[123.98412056729994,41.99937425331303],[120.55588074330021,41.71719444493961],[119.13690952882241,41.14827082786993],[115.50113901102064,43.25414167974318],[110.98113865629122,41.21659856438631],[106.53560104056335,43.13981346746202],[101.93382777845231,40.615119547681495],[96.77091959116152,42.20694073128457],[92.34774404572356,39.17381250225141],[86.70820981047306,40.31276675619656],[82.7286870762826,36.835377392607754],[76.94535091342905,37.477284318316336],[74.43633811146184,41.761836643769904],[68.0486075236378,41.98577467201586],[65.03033141654677,37.894403776101235],[59.150326723667334,37.656443450315685],[55.52729405295955,41.39291048343534],[49.67064440002375,40.63612336794766],[48.11443574118379,36.404918747900226],[46.404510337105044,36.11444480483865],[43.07440081871427,35.326155690177366],[38.930217596746424,38.400687413420364],[33.614583723213144,36.85866401664056],[28.846868847179124,39.64331054771269],[23.474780873002853,37.6303425743379],[18.325260281104836,39.98817796336323],[13.244313475659819,37.523712365785194],[8.045142114241342,39.40213636897177],[3.5435893569877903,36.59789814478598],[0.23871595462881517,37.58884624349159],[-1.4162342628377007,38.1159967227654],[-5.442348460730083,35.12442405176797],[-10.744488220052984,36.383229951792835],[-14.570452111245075,32.95438593767852],[-20.10838274495798,33.794127804904804],[-23.54251737908868,30.029487035562912],[-29.030406967463787,30.469788192503234],[-31.590030919491358,34.71446768669329],[-37.30966446935987,34.76793171992824],[-39.90371712605461,30.658039731336256],[-45.101964247992925,30.42765660497883],[-47.09234080406861,26.387727327373366],[-51.70374278490925,26.024129726893676],[-54.67394745626158,29.457126834825857],[-58.972372274137555,28.788083858698766],[-62.02252554784451,31.877885956365812],[-66.41090036021146,30.2738899624896],[-66.79574711847854,26.872316674232128],[-69.40349518337901,25.805978646929855],[-70.33904370008679,24.945215618732814],[-73.86827872769487,26.19044873092739],[-76.8312173516333,23.342862880634836],[-80.82969048713068,24.429618069495433],[-81.9664941624314,28.63180650194559],[-86.54577821124968,29.759287059695453],[-89.80771154120198,26.42647813530849],[-94.74356847987167,27.26400561736174],[-97.90563426634658,23.589794368093237],[-103.01162576662247,24.12172726544782],[-105.25067839657362,28.43865978592777],[-110.66261804031069,28.72380952741313],[-113.46044826906298,24.671633767522994],[-118.63264326814091,24.676154575544953],[-121.01253489901505,20.57399140249709],[-125.79514460772695,20.415980206926488],[-128.4779115319772,24.19492082737583],[-131.54639010786792,23.913612778407924],[-133.08381598345164,23.820431161854447],[-134.89965579269537,19.7532105149965],[-139.6214919325493,19.2239309458196],[-142.7188705783351,22.885971422359724],[-147.69594788211106,22.16693900740581],[-151.04796662686522,25.669243623986258],[-156.08998858841755,24.696711258039056],[-157.6068486027842,20.259691594705036],[-162.39694129463984,19.114485874069658],[-165.75801721847134,22.310289219453917],[-170.26790510748518,20.964113606206052],[-171.3530255445717,21.946696092852083],[-173.6703874763115,23.782822700979136],[-178.22376950605553,22.092681232201556],[-178.95063664056067,17.74333218723816],[176.7615924622716,15.921990549108143],[172.88878640797157,18.30669067889132],[168.65279280829242,16.286127926718756],[164.53519134064652,18.52280839538614],[160.52670878987635,16.340968799924067],[156.3345017757493,18.378344876415618],[155.0908180524783,17.612650219785667],[152.72123821625237,15.944244424286081],[148.40568576193812,17.78359946080229],[144.6843894988152,15.071456211059555],[140.1697245352548,16.779214626193742],[136.4065502724283,13.866921861790894],[131.87381670052898,15.422507023667904],[128.2235738321257,12.387611570633615],[123.85482415801252,13.797500809062365],[120.449366342475,10.736966167684393],[117.72051153154996,11.610616592954969],[116.37231939217895,12.105101652283977],[113.09327126386995,9.10538636195205],[108.77247792549403,10.50768755405878],[107.74262433198103,15.063301114735607],[103.13773328689898,16.482450442847686],[99.62104197842224,13.236333300082233],[94.89357672220478,14.501202967940499],[91.464698892715,11.11188905936001],[86.80542094987004,12.238125270361769],[83.59315755505943,8.82060245673717],[79.17056508080194,9.844673375903138],[76.26408541439847,6.511600732441479],[72.19363429195394,7.473863638092713],[70.86172974036968,11.593032005402348],[67.03356105469996,12.31424293862071],[64.70807868588638,9.132230941835733],[61.315435771664646,9.83036925628956],[60.638711932789995,8.825639091130398],[58.54988276272472,7.302087248609318],[57.375161256993955,7.6162281860636245],[55.2505622892379,9.09268603178858],[52.13941397202456,7.605969353681876],[48.70181724423405,9.876090877671764],[45.240404460013565,8.292129888631607],[43.42442441139784,9.440447666346104],[41.86780918021332,10.627353551154322],[37.848935371300406,8.893462571252645],[37.77676428812329,4.74095538189142],[33.814945033944454,2.8026599483934844],[29.961298273611618,5.1819226249528905],[25.886010570251138,3.202074339142956],[22.136132249356994,5.527020080114615],[18.09981644071494,3.5346227999232194],[14.583250071411674,5.762860491436915],[10.722777827285633,3.789624991750129],[9.102371418548282,4.860811812073258],[7.212914562720072,5.860392168376587],[3.9430361557864506,3.968796976609581],[0.3098039635355267,5.864518365517619],[-2.5790347646674987,4.020023638586551],[-4.862616126699467,5.2106109314008116],[-6.064496108778538,5.362739776582626],[-7.899841472392981,3.559837831413195],[-8.412776379912247,2.467580053183621],[-11.830186971127075,2.638932741201293],[-13.559193205964707,-0.8762512952424143],[-17.373147196370113,-0.8227221314451982],[-19.42154916686706,2.985051052916481],[-23.577254165479836,3.152670815193172],[-25.721264011811797,-0.6931851479671439],[-30.203425049597982,-0.6173843220866737],[-32.48012811254947,3.4549175353760115],[-37.14019742640149,3.5803293669296306],[-39.563133079118444,-0.44748322046602834],[-44.322948507187284,-0.3562094817730327],[-46.5899429561277,3.76138350054279],[-51.252815863927914,3.813394894857517],[-53.68204442813005,-0.17017772412858903],[-58.163640147998116,-0.07918007660184663],[-60.50309415506542,-3.9486914533379958],[-63.32276713921543,-3.8221019268338665],[-64.72810407520194,-3.684741680505737],[-66.64455573288102,0.3760386871585963],[-71.0160747003525,0.901274271496053],[-73.58831704620168,-2.7703025791670175],[-78.21816398026434,-2.2641433736476846],[-80.99438115089971,-6.061929363987141],[-85.74830788668204,-5.520060963403992],[-87.59400415255666,-1.1964275116101613],[-92.21612396381302,-0.6561288240742991],[-95.07033345637271,-4.3484866954754455],[-99.52316615028741,-3.7450437470058215],[-102.31681156298443,-7.3098511437293086],[-106.47391434652876,-6.608494376194796],[-107.80031250106053,-2.5640667726764135],[-109.71988821036106,-2.2812832631930218],[-111.84870286236902,-2.1675662435525274],[-114.02904784459383,-5.2429294095717065],[-118.12335777862991,-4.986310192743098],[-120.04113378454103,-7.824187579675657],[-122.62483874300602,-7.616228186063614],[-123.79915370670535,-7.935015077996302],[-125.88346072177119,-5.21502760786271],[-129.7100658202636,-6.134248764846947],[-131.29818275576596,-9.876090877671764],[-134.98737104093033,-10.887602149584191],[-136.5755755886022,-9.440447666346104],[-137.87673173668102,-7.989894674599884],[-142.1510646286996,-8.89346257125266],[-144.9683236097968,-5.820413131280587],[-149.4028814909321,-6.672537737437516],[-149.89499129445545,-7.994339391610254],[-150.75270038391494,-10.680211197141583],[-155.27937408677556,-11.520974627273135],[-158.26377159894878,-8.243493259763849],[-162.74615099653175,-8.96214248286481],[-164.5273841217466,-13.002850555044567],[-169.13021843542504,-13.615007694572514],[-171.62613047887277,-10.215393994209876],[-175.92099346918747,-10.734014957224218],[-178.00946172254558,-14.547282830266626],[177.80629500559556,-14.869645297067576],[175.98600155652952,-11.545295975414755],[171.9300818517216,-10.7462912331855],[169.3943599560665,-13.645345830474795],[165.05418357227583,-12.73084648058285],[162.08954694409738,-15.729652374960152],[157.571743031483,-14.65689912671653],[156.37086889691636,-10.672390551299387],[152.36911904482506,-9.360957722014561],[148.86773106739847,-12.247495975510207],[144.61028231769941,-10.83867618195191],[140.99787004528466,-13.663288802531614],[136.62985321175947,-12.143150710647651],[133.04161575288833,-14.828508822503098],[128.72922962253637,-13.199442659470227],[125.29786499400346,-15.691263979641608],[121.19254253907259,-13.975215755765579],[118.02084684680113,-16.249348507267683],[114.23117809212035,-14.482400617733104],[111.17711329216905,-17.32339584591452],[107.14858593309295,-16.61724776253429],[104.00145175623874,-19.358823435394214],[100.07495083152207,-18.715079431931773],[99.25486565281827,-16.733205120383744],[98.70279884762454,-14.868802684797343],[94.368931435732,-13.836853809820951],[91.61868641088118,-17.03415634290803],[87.15744823840198,-15.990116090801747],[83.94979010377854,-19.26900694125663],[79.21397212690246,-18.03667420775851],[75.60183433053456,-21.280265937450892],[70.76438508401766,-19.814669490563922],[66.86923845534189,-22.898224484781245],[62.14628288124375,-21.187585569854463],[58.140059799917516,-24.011694715187474],[53.73887701345781,-22.089282598203656],[49.80147192896589,-24.603066514705624],[48.453609892132086,-23.913612778407924],[45.72802345879658,-22.624728935439105],[41.56782513851296,-25.066706608415128],[37.281129421664886,-22.885971422359724],[32.812319409411266,-25.145185646711305],[28.49188235445327,-22.684204115325596],[23.910011411582452,-24.69671125803906],[19.758670182797356,-22.00585426446814],[15.27756395681501,-23.752623710762254],[11.465300865151091,-20.922822426862055],[8.646974455428287,-21.94669609285209],[7.197179188234455,-22.373958345439732],[6.377204029655109,-26.71303973922542],[1.553430171580416,-28.03484063705462],[-2.1530562884085485,-24.756909421354475],[-7.175238133455658,-25.769382636267903],[-8.870093365769497,-30.224678744640975],[-14.325789953114501,-31.015442711548175],[-17.584865210837965,-27.274993974879003],[-22.80583317022407,-27.731134161429946],[-25.255959312090404,-31.88396300415958],[-30.536960890385416,-31.966206554283037],[-32.86417200841555,-28.051410241915995],[-37.56677824334244,-27.949605976503904],[-40.34519809240025,-31.537999211685964],[-42.60440009202195,-31.331748636163976],[-45.0960175181045,-31.25985351902173],[-47.461171008275414,-27.760043738207102],[-52.32307433842227,-27.407024752708203],[-54.854902432945465,-30.51202973135771],[-59.496606140042005,-29.892985338693553],[-61.8827346387928,-33.43902448232616],[-66.56945830484808,-33.77089612652205],[-68.71005428511454,-30.415400329702248],[-73.64474708628364,-30.42847490174807],[-76.58060559840007,-33.8826639775661],[-81.77149574422948,-33.62106978068353],[-83.85560259366653,-29.864781548005666],[-88.97436860014163,-29.280171655412424],[-90.01675042991198,-30.360710911742927],[-92.04216392358965,-32.58486408488775],[-97.28316374371491,-31.717351794521758],[-100.97002387578763,-34.97529051965555],[-106.40738231200352,-33.70575303795421],[-110.73714537281448,-36.730184508009465],[-116.07565773033956,-35.01417583784235],[-120.8496732763327,-37.656443450315685],[-125.76880779579237,-35.53435944708938],[-130.70129092236525,-37.719798673929276],[-133.59548966289495,-36.11444480483865],[-134.94561422689418,-35.22985924555321],[-139.98609609464688,-36.899865495748365],[-144.05833935288697,-33.88647014000823],[-149.48388394533063,-35.182951208422544],[-151.1531311528209,-39.643310547712694],[-157.12328978112583,-40.608843552222844],[-160.9403859524235,-37.02901921647205],[-166.75568652434018,-37.5237123657852],[-169.24504853208808,-41.57505304930814],[-175.13166788498833,-41.58031489516635],[-177.98474535021083,-37.66435763083125],[-179.76128404537118,-37.588846243491595],[176.68865874692344,-37.499409186860944],[173.53581801576217,-41.30855957084678],[167.61587312700956,-40.869133191665526],[163.61430492268605,-44.491234954468226],[157.27774152798068,-43.54372570815056],[152.50707693963324,-46.76027724369226],[146.17127510537844,-45.21221585934099],[140.9176092122301,-47.86715402021094],[135.07445645775948,-45.755276550084716],[131.53604464447062,-47.1663973236616],[129.65015692436307,-47.766522183321335],[124.41037456411709,-45.09612715436975],[118.38709615825293,-46.412467442598675],[113.84087368285792,-43.24164819563601],[107.67661838081875,-43.964363305988726],[105.07052428717569,-48.06601289912326],[98.08037300109167,-48.295316381881364],[94.90986169173487,-44.38248318374426],[88.61576109110958,-44.062790040561886],[84.4201365426124,-47.511000583160836],[78.10517846431846,-46.57467022471412],[73.06904671652028,-49.54882288394545],[67.21199607170564,-48.011188120377795],[61.679410390963234,-50.38551078187042],[59.0924552109795,-49.39503397118231],[56.2145859262297,-48.41499723110689],[51.090146189862246,-50.15451159756744],[49.50125116496664,-54.09460398431849],[43.081393787282614,-55.36583039668758],[39.47973301456596,-52.67984228858088],[37.54121894075451,-52.9686073691119],[33.34490980850574,-52.57479276042742],[29.49980276027751,-55.133688198158374],[22.717229081284433,-54.01377148101902],[17.468798446926456,-56.29657975847274],[14.006700032453024,-55.4225091325656],[11.153993205628135,-54.38852804531911],[4.251781231586488,-56.19652224584305],[-1.3012465525855312,-53.540333941485386],[-8.7291680146373,-54.63456191069657],[-9.584191833038208,-55.956862850498176],[-11.22722997525273,-58.62952020387534],[-19.92958173787226,-59.096557065213155],[-24.26992619768622,-55.37052237191946],[-32.107870553013484,-54.98575947058211],[-37.51226099240144,-58.23555192165026],[-45.61544014350358,-56.96495838789853],[-52.681573820492034,-59.54334767165103],[-60.00652075270777,-57.368693769759474],[-67.91951423550528,-59.04446657501831],[-70.22334064229605,-63.30546259246108],[-80.24656841679338,-64.23021521485094],[-83.75992283606729,-61.905821766310815],[-85.19691484338917,-60.67735411936203],[-94.1642343610987,-60.51030677274728],[-100.50030139306155,-63.939145038328846],[-110.22566765060147,-62.7392877671267],[-118.48506240101176,-65.25273108770253],[-127.3139783583892,-62.94301605404717],[-136.10157919771405,-64.38736055548594],[-137.9160562769237,-68.38209527813018],[-148.1687195009127,-68.92995788193986],[-155.80725235262844,-72.09707420590918],[-168.0098327233773,-71.26523337833439],[-179.6743896480568,-73.31022368544396],[172.05743696166337,-70.17612110688735],[160.7671370798629,-70.30015374059282],[153.13247928231416,-73.85617864759341],[139.09944786006776,-72.70830963415911],[125.2456182890761,-75.12848264807121],[122.54169441685293,-79.49208922409562],[97.13871644067184,-80.33224174967269],[87.74799647552526,-76.34572913617531],[70.54359227776199,-74.83432166792294],[60.67175859504254,-76.19875754188197],[54.976005154986076,-76.64501335405268],[49.509760006773256,-80.92220862231946],[21.151786939540855,-80.72172286490245],[-7.780834308185192,-83.14393672156828],[-34.441802308663334,-87.36469532319619],[-87.34455122467277,-84.24413301148068],[-124.07451529163777,-82.50396355374549],[-159.0907444817528,-82.87200197672584],[162.09183616506857,-84.94207431820972],[145.24158201971537,-81.27137179020501],[159.6908042933129,-77.80316131016781],[168.8172504974305,-77.68777876614904],[178.09672257914792,-77.03453024906975],[-164.32460615388686,-78.79915742230948],[-150.7925342912893,-75.65094362106626],[-133.88991696089687,-75.23051359343751],[-120.31585905866002,-78.0257182142187],[-103.98485051466383,-75.45226049628373],[-85.85690989815225,-76.163042830191],[-78.21017162371925,-71.98699598123666],[-64.06362884682201,-70.80573675666331],[-51.21089185186892,-73.37525345776886],[-39.295267881631744,-70.36653885229539],[-25.001755365954338,-71.0720426766047],[-18.70438773465715,-66.94299147138761],[-7.138628601307926,-66.19292316051032],[-4.785398759359998,-61.82981680247969],[3.7941449033998462,-60.34269461019056],[11.872490908645235,-62.65341059232735],[19.009114758061546,-60.27519181750238],[27.497924176806205,-61.583334933903004],[32.50139969076801,-58.69272286234608],[40.31640651839021,-59.16948256665967],[44.99484376546598,-62.161511388554544],[53.05571633154158,-60.85001635271577],[59.99228294010169,-63.4539330475255],[68.12424998080402,-61.18381291868138],[67.74041932034174,-56.66736999977179],[74.0388395202389,-53.910446928597366],[81.43815238108998,-55.21855070035159],[83.81984481326035,-59.6924457669829],[93.13338768661211,-60.400005225956455],[98.00467249939058,-56.37872863204192],[106.56152524549057,-56.097969987348556],[109.52240303455929,-51.73263802593274],[116.79922600446484,-50.77050266836529],[122.4663386199827,-53.900134937976425],[129.34330410144213,-52.16478116101679],[135.77030496675965,-54.56320665897179],[139.74618719864486,-53.008820458308634],[141.69331449095665,-52.24163986312104],[148.60245859405032,-53.96605569703897],[154.12397758128557,-51.11545209860288],[161.22576672897168,-52.12149149190321],[165.86503387311802,-48.69906061825518],[172.5394909199373,-49.05681780552429],[175.42161758601702,-52.79243904276302],[-177.89868601605255,-52.51713397842229],[-176.36999136090046,-50.610463312569514],[-174.83648905843094,-48.943763955054905],[-168.35160369217152,-49.0393451307964],[-165.6627937175554,-45.2734322258347],[-159.29947435786374,-44.79686404516598],[-155.04758817582032,-48.08486658471021],[-148.57772787468684,-47.03191968899236],[-143.8832763682254,-49.77934286766213],[-137.85800962888652,-48.470618150310706],[-136.741605440075,-44.04754241934246],[-131.2504037234426,-42.22096583203444],[-126.11128773724835,-44.70954356692923],[-120.61562782671386,-42.305966242342],[-114.77869079730516,-44.3219897776707],[-109.69362310318317,-41.359581468551546],[-103.57871397726349,-42.800877820837385],[-99.24277102208288,-39.420496754076936],[-93.29179018952695,-40.31276675619656],[-90.86103333532054,-44.61996649658839],[-84.56226711484148,-44.973945632397005],[-81.59868378041229,-41.1397166562878],[-76.08418654491567,-41.11623193061337],[-74.03195141021533,-37.37997452587736],[-69.30538945117728,-37.16389648579594],[-66.10309206061781,-40.39961129392156],[-61.70280552750993,-39.800881986666845],[-61.4171149104145,-38.614966776614985],[-59.78817573003526,-36.394827059119166],[-58.30984607577598,-36.20528264541885],[-55.16400420796509,-36.64293584360806],[-54.41476566528829,-37.69124546237201],[-53.84970300036963,-40.22211498519529],[-49.5601218973156,-41.284599348781846],[-46.34780116487943,-38.2428757141176],[-41.55853757447226,-38.98109995890206],[-38.48352799492271,-35.5000792042008],[-33.347657525615396,-35.83924212521622],[-30.806932960779864,-39.89128943394795],[-24.96132796979017,-39.96484113905747],[-22.272456071228092,-35.82316671778093],[-16.51271047421299,-35.410811261589316],[-12.851127423934322,-39.177426167855764],[-6.849807213223577,-38.30496354724654],[-5.1064452283314585,-33.75764213456773],[0.32477422723328586,-32.56540793873001],[4.43567077495152,-35.741206971176496],[9.551545939792542,-34.155186609801476],[13.789579630965138,-36.89269962490027],[18.3529219486429,-34.99400669710762],[18.839987045173043,-30.86103232978591],[23.533518085486477,-29.1666457310175],[27.91894102367205,-31.644146771138406],[32.62032671222644,-29.62445406401754],[37.08745257905972,-31.777487752342214],[41.56358261344398,-29.46937931531951],[45.89351102822209,-31.285608665560563],[49.97282131199014,-29.090245038000415],[54.42644170672916,-31.225723979081465],[58.663371667348294,-28.65301931148454],[63.558468744433696,-30.533964896959827],[67.75194812766243,-27.591432296604456],[72.86444302724134,-29.15113592910695],[76.80034905847296,-25.912524768601525],[81.86961002164873,-27.145530873716577],[85.38151705992367,-23.73986771479646],[90.1834152682512,-24.697760964142326],[91.82972821115736,-28.973403097559856],[96.57920207807338,-29.571467376092365],[99.30143515528009,-26.062694311272722],[103.52781506674853,-26.49429123770875],[105.71797151261644,-23.11880968295901],[109.42003666893777,-23.470380968779807],[110.0191091277662,-22.39752742353522],[112.03668485952855,-20.643702793693453],[113.31390145095753,-20.81243066583014],[115.75931573815498,-22.002085574481583],[118.79998258959921,-20.095984004086613],[122.76988803599195,-21.814638994608284],[126.0896945858073,-19.680474994025868],[128.186151976289,-20.493738955204808],[130.03291064326643,-21.37873251232251],[133.81752542331913,-18.914756857912398],[137.8726089328045,-20.55227807200681],[141.66073693202935,-17.838743925532082],[146.0414086198563,-19.30220339543153],[146.84607371901134,-23.72180395121882],[151.70359372556445,-25.170737543759536],[155.41995693388589,-21.99974623089123],[160.31253533179913,-23.164690007884964],[163.60351763530443,-19.889828368813912],[168.32485084432005,-20.80838745157097],[171.12219885479456,-17.561549237648155],[175.52711991035227,-18.297332900396515],[177.51613498805204,-22.197541386302387],[-178.00242433382851,-22.067175689495624],[-175.76570557732126,-18.098845255143683],[-171.15883789403625,-17.692218373206735],[-168.45624973959934,-21.38124691750292],[-163.50685862215772,-20.807842018632027],[-161.63482061718392,-16.505947603561054],[-156.8451104387456,-15.73745539193679],[-153.60986495294128,-19.22050575143427],[-148.8063085814878,-18.242012526672724],[-147.53473330977212,-13.929125816704278],[-143.12501254564776,-12.93503437236234],[-139.785050801395,-16.05027003530367],[-135.6451966084015,-14.89654614400257],[-132.3041912497708,-17.797749012021782],[-128.5487287607648,-16.505445569112272],[-128.19551469837577,-12.603201514978364],[-124.88652085283472,-11.501694573369313],[-122.9057748487485,-13.1912604678976],[-121.74458895430429,-13.61493421960813],[-119.49774674226667,-12.271971757766302],[-118.7400731016433,-11.320482944588],[-115.37292169585125,-12.225768873349038],[-112.90853605006426,-9.146555719787036],[-109.1289979665708,-9.955680589617998],[-107.81475064831358,-14.083697371265826],[-103.63011704459393,-15.001447764157023],[-100.79150611535313,-11.573007348022395],[-96.27780158747441,-12.344265741825291],[-93.36023548123568,-8.68032330906325],[-88.64569445957765,-9.316288774752769],[-86.77148687822637,-13.708575981512867],[-81.89888176783417,-14.264150052057268],[-79.03684380916933,-10.410683770602718],[-74.27563926949468,-10.846247154674371],[-71.61986799886888,-7.003123550980988],[-67.11855039005962,-7.389406912237246],[-65.15017429804568,-11.472123671112495],[-62.279488468450026,-11.610616592954976],[-60.8467507782339,-11.739863893210977],[-58.48709482803756,-8.000707509888285],[-53.96609188290457,-8.249605946164333],[-51.51182762864842,-4.287152921751077],[-46.800487381563165,-4.422917404204754],[-44.50963460024756,-8.604422032304726],[-39.69515515754569,-8.69674378039496],[-37.243135362944614,-4.606028555705817],[-32.528267829318835,-4.649620438680767],[-30.225126243811296,-8.70173997465801],[-25.6916111818247,-8.621215172764755],[-23.52422244327238,-4.645743871293199],[-19.325125801816437,-4.604844470308616],[-17.255986711053566,-8.330334446485908],[-15.29921963706058,-8.23708394319924],[-13.171003636817149,-7.923775520601627],[-11.66474754212644,-4.4670316097845],[-7.615506108749893,-3.845828260484011],[-4.805183856824203,-6.586859421326589],[-0.7828391751055227,-5.889921754313915],[-0.1336889125916577,-1.8554926185476641],[3.3406661153006625,-0.04510060679510636],[6.386373526666488,-2.3418038147608624],[10.189893676135952,-0.43188476755339716],[13.611699107391518,-2.8447525350379235],[17.669408104914115,-0.8469844525190816],[21.40032508185986,-3.335734857517352],[25.58678516686,-1.2704435740827693],[29.508441243966416,-3.781047572700436],[33.66361927713152,-1.6772949381945044],[37.62415943093452,-4.150912683092272],[41.58665495463515,-2.0439831300982623],[45.43387749209455,-4.428418751970285],[49.07628278330157,-2.3547343129537177],[48.94706885744921,1.898270439192623],[52.316592444657616,3.6927532541940127],[55.70150722023228,1.4476428602002083],[58.9668320668832,3.9090460692491074],[62.72776317867667,2.7916780404471604],[65.9709521554062,5.242929409571696],[69.63381057288798,4.311473809758376],[70.28011178963894,2.2812832631930138],[70.68986972642183,0.38646139108642585],[74.82676115190374,-0.8701881901666618],[77.5983036432562,2.2233436292223394],[81.85307387147245,1.084853908628409],[84.9296665436273,4.348486695475442],[89.44185686196764,3.1743094571295885],[92.75068396053875,6.523960823111651],[97.37304065193962,5.289412273297663],[100.80136063472526,8.618890658103629],[105.35716758404885,7.303218576160169],[106.41168295379833,2.7703025791670135],[110.72399425598124,1.5358657755021414],[113.98513214459506,4.6721309865719345],[116.67723286078457,3.8221019268338585],[117.99888533923311,3.3267128731190114],[121.26764633911117,6.289184675341438],[125.50231533878872,4.763431183575369],[129.04492009156368,7.805398745803346],[133.49441060685513,6.197676527808861],[137.1970727246292,9.231452670299692],[141.69432910913807,7.537486471095007],[145.410940917621,10.472716898667054],[149.7748737561887,8.701739974658006],[153.35922559786337,11.466145661026697],[157.4358769401798,9.643021108594695],[160.7733897026288,12.194726726168003],[164.67056230846524,10.175448079467838],[168.53745793093609,12.10200548276957],[172.29426677728955,9.978189493251357],[176.28993210653294,11.794175727566111],[179.77693144202632,9.615942399155198],[-178.23815999124184,10.463240376838439],[-176.35806599111405,11.05195584369349],[-173.38014762578527,7.9727938308414075],[-169.2931299839693,9.060308038526603],[-168.1728875957565,13.44560433788435],[-163.71455965998953,14.623074892227512],[-160.44607430026895,11.231115019630433],[-155.7634836482284,12.265823643881989],[-154.25484084592026,16.797013674901503],[-149.3676428224656,17.73753035354521],[-146.16007687374923,14.110797540904425],[-141.37151007296615,14.881959131410003],[-138.42043748614526,11.22287623237951],[-133.89520751564908,11.884131145297399],[-132.14080471892913,16.072271835802038],[-129.22390101069368,16.364888710749913],[-127.75650761238906,16.42566424694523],[-125.23898938471632,12.654413063468834],[-120.7266797125519,12.651392432778689],[-118.48186571718101,16.572699557873406],[-113.6290340058613,16.486147588602186],[-111.01600127930239,20.479742425174795],[-105.94643547761567,20.212678725972662],[-103.81933932397637,15.969878062915628],[-99.00408607712038,15.551320300550213],[-96.05020989622146,19.26900694125663],[-91.35930158406565,18.628702191285885],[-88.29590003003727,22.120730739616338],[-83.89124846795359,21.24419924142965],[-82.72794198413503,17.13343724860129],[-80.74513434718173,16.733205120383765],[-78.53930229370525,16.46956562230495],[-75.99854824376126,19.35882343539422],[-71.73013580791827,18.71393076637831],[-69.38326850163935,21.32618352574739],[-66.68609854904248,20.812430665830146],[-65.40723864874259,20.97970390799356],[-63.98641894655858,23.18542363894646],[-63.73633023843451,24.369915046380928],[-60.03617531999626,24.98746480098875],[-57.23011196400803,21.8146389946083],[-53.18787140474504,22.19677345881088],[-51.81384802371097,20.49373895520481],[-50.75089930552418,18.833522049909917],[-46.18247457668084,18.914756857912426],[-44.307851815105856,22.680244947040364],[-39.5353904154908,22.737529603315625],[-37.15515344114197,26.664335930022155],[-31.953133427831695,26.53340769423688],[-29.59996504669809,22.402302794308937],[-24.58004306611412,21.99974623089123],[-21.48740093012417,25.69485702884282],[-16.394662810970292,25.007863044517464],[-12.948554583750909,28.514935780874872],[-8.002013895306675,27.502908667188287],[-6.84616569288798,23.22581044564793],[-2.4838650119479615,22.197541386302387],[0.9946771925498358,24.85833583444955],[5.3675737051231645,23.01114705036288],[9.380676605201614,25.603702576968765],[13.915183885634578,23.450437715320348],[18.351304577591982,25.86678026136113],[22.83929753527266,23.411689797815992],[27.504442850291092,25.566738583888263],[27.91172984348016,30.313708747237165],[32.928330868996916,32.24010231871653],[37.16428242437894,29.339076105087567],[42.0262939935408,30.891357297171993],[45.67876237395104,27.848757985138352],[50.187903612796035,29.08939213814528],[51.718680011231655,33.030250479520696],[56.94985342520008,33.54604933168178],[60.099069300235215,29.903560266766736],[65.31584973168053,30.032244941109695],[67.9828900331216,33.902396769499795],[73.59261768799648,33.70575303795421],[75.86840220674935,29.662738501442483],[81.02837815214555,29.17375414949066],[84.47960117594232,32.5899433367004],[89.5797723881596,31.72668530390849],[93.43166846596249,34.85693363509917],[98.22850425577052,33.62106978068352],[102.30325327948644,36.369976008694486],[104.50431619290684,35.604156879765036],[106.96772054606103,34.90299087075072],[110.69461054882272,37.16389648579594],[115.34096073223206,35.52242379555109],[118.86929883406582,37.4298544842811],[121.690153924224,36.20528264541884],[123.16276457697892,36.005614448071945],[125.58523433471171,37.691245462372],[126.34694261516329,38.738746175246234],[130.6575327073045,38.19456373764813],[132.30837745804203,34.33115860097917],[136.69764123177848,33.37879798624116],[139.9482130546856,36.44177765047697],[144.83132547405447,35.18743046995051],[148.85692557335597,38.18237993929451],[154.09368225574624,36.51782797902878],[158.84760391998597,39.272303820667766],[164.1680060221127,37.123942760722066],[169.44151026908685,39.479372566043565],[174.49688633843544,36.85680682151307],[179.9534193241767,38.728779390762334],[-179.170112546831,43.33462463706695],[-173.2513616288856,44.74985555511408],[-168.8876761772056,41.53861492567143],[-163.39292691687498,42.461841701752746],[-161.56979335131368,46.51349897531834],[-156.03631344405528,46.90887469576172],[-153.03739182353243,43.44325276436557],[-147.45009391663316,44.09362423911828],[-145.50148773440654,47.229253562009625],[-141.72110208965793,47.40667245951889],[-140.06320040294017,47.862031640242165],[-136.7018216781215,45.34099129109545],[-131.2901594178203,46.41694831075058],[-127.95866237076233,43.41920841314796],[-122.13483148443464,44.05769081450337],[-119.23221501743073,47.80409716753512],[-112.78800392829434,48.011188120377795],[-109.78838725262649,44.41307088095467],[-103.5359544106562,44.08337983698416],[-102.32375592668524,45.1976278061656],[-99.9170487939702,47.471519107155316],[-93.39584904234347,46.630019541751885],[-88.65412421340821,49.81242268121324],[-81.91962699890831,48.295316381881364],[-76.05772874399094,50.99021068384577],[-69.71947899952944,48.757431677563375],[-63.20077399553516,50.77050266836529],[-57.83787165548379,47.957631356793456],[-51.28843730002799,49.26164550158302],[-48.90245004939705,53.53097474699997],[-41.51955822321931,54.201077797482284],[-40.25381280135515,53.008820458308634],[-37.73288919120909,50.66238203129508],[-30.59296189548184,50.75085829394896],[-26.42076829683686,54.35117905265651],[-18.841171686388577,53.74020675223833],[-13.79164665163863,56.73632442836386],[-6.436337296790293,55.37739041554851],[-0.931587163510601,57.68949737459286],[5.52364654929031,55.70676846515228],[11.555977692900699,58.130531165851394],[18.275235951757786,56.63295271905083],[25.082722326707867,58.4015448703527],[31.09581420470738,56.47000529592752],[37.661108111591226,58.48066299220258],[43.54748161718774,55.820803924848654],[51.15131422930827,57.15637211465772],[53.98254701603947,61.44092061568186],[63.44462184184533,62.114389785017146],[68.25632325438265,58.31910366055611],[77.08692220857513,58.00933225078081],[82.82707956961833,61.436707955225096],[91.70963813960333,60.139795359435674],[96.24007716393278,61.9058217663108],[98.78655602562978,62.66968760697614],[106.865913193906,60.356642583739344],[115.45092688260333,61.84098848787113],[117.81292538828086,66.20328559643201],[129.384260762246,66.94915555373028],[135.69544064746276,71.07580205245384],[149.98712931534274,70.36472443894682],[161.9120756666221,73.36886176605667],[174.7489392452071,70.79472682488495],[-171.11065695414112,71.97154653078344],[-163.45686807900944,76.14556732608257],[-145.35543575349868,75.43128251813995],[-129.04688648576501,78.00335975517777],[-119.32824140495745,76.19875754188193],[-115.6016830241182,75.13310683752093]]]];
    const coords = geoJsonCoords.map(polygon => polygon.map(ring => ring.slice().reverse()));
    const arrowStep =  3 ;
    const poly = {
      type: 'Feature',
      properties: { name: 'Polygon' },
      geometry: { type: 'MultiPolygon', coordinates: coords }
    };

    
    function getEdgeArrows(ring, step = 10) {
      const arrows = [];
      for (let i = 0; i < ring.length - 1; i += step) {
        const p1 = ring[i];
        const p2 = ring[i + 1];
        const interpolate = d3.geoInterpolate(p1, p2);
        
        arrows.push([interpolate(0.4), interpolate(0.6)]);
      }
      return arrows;
    }
    const edgeArrows = arrowStep > 0
      ? geoJsonCoords.flatMap(polygon => polygon.flatMap(ring => getEdgeArrows(ring, arrowStep)))
      : [];

    const container = document.getElementById('globe-ge');
    const getSize = () => {
      const width = container.offsetWidth || container.clientWidth;
      return width > 0 ? Math.min(600, width) : 600;
    };
    
    const inputRotate = [40, 50, 0];
    const allPoints = coords.flatMap(polygon => polygon.flatMap(ring => ring));
    const centroid = d3.geoCentroid({ type: 'MultiPoint', coordinates: allPoints });
    
    const centerRotate = inputRotate
      ? [-inputRotate[0], -inputRotate[1], inputRotate[2] ?? 0]
      : [-centroid[0], -centroid[1], 0];
    const state = { rotate: centerRotate, width: getSize(), height: getSize() };

    if (!window.globeLandData) {
      const landTopo = await (await fetch('https://cdn.jsdelivr.net/npm/world-atlas@2/land-110m.json')).json();
      window.globeLandData = feature(landTopo, landTopo.objects.land);
    }
    const land = window.globeLandData;

    function preview(geometryOrFeature, rotate) {
      const marks = [
        Plot.geo(land, { stroke: '#88b', fill: 'none', strokeWidth: 0.8, strokeOpacity: 0.8 }),
        Plot.geo(geometryOrFeature, { fill: 'red', fillOpacity: 0.45, stroke: 'red', strokeOpacity: 0.7 }),
        Plot.graticule({ strokeOpacity: 0.06 }),
        Plot.sphere({ strokeWidth: 2 })
      ];

      if (arrowStep > 0) {
        edgeArrows.forEach(segment => {
          marks.push(Plot.line(segment, {
            x: d => d[0],
            y: d => d[1],
            markerEnd: 'arrow',
            stroke: 'darkred',
            strokeWidth: 1.5
          }));
        });
      }

      return Plot.plot({
        width: state.width,
        height: state.height,
        projection: { type: 'orthographic', rotate, inset: 1 },
        marks
      });
    }

    let frame = null;

    function render() {
      if (frame) return;
      frame = requestAnimationFrame(() => {
        frame = null;
        state.width = getSize();
        state.height = getSize();
        container.innerHTML = '';
        const svg = preview(poly, state.rotate);
        container.appendChild(svg);
        attachDrag(svg);
      });
    }

    window.addEventListener('resize', render);

    function attachDrag(svg) {
      const drag = d3.drag()
        .on('start', (event) => {
          drag.startX = event.x;
          drag.startY = event.y;
          drag.startRotate = state.rotate.slice();
        })
        .on('drag', (event) => {
          const dx = event.x - drag.startX;
          const dy = event.y - drag.startY;
          const k = 0.25;
          state.rotate = [
            drag.startRotate[0] + dx * k,
            drag.startRotate[1] - dy * k,
            0
          ];
          render();
        });
      d3.select(svg).call(drag);
      d3.select(svg).on('dblclick', () => {
        state.rotate = centerRotate.slice();
        render();
      });
    }

    render();
  })();
</script><div class=globe-container id=globe-gf style="max-width:600px;width:100%;aspect-ratio:1;margin:2em auto"></div><script type=module>
  import * as Plot from 'https://cdn.jsdelivr.net/npm/@observablehq/plot@0.6/+esm';
  import * as d3 from 'https://cdn.jsdelivr.net/npm/d3@7/+esm';
  import { feature } from 'https://cdn.jsdelivr.net/npm/topojson-client@3/+esm';

  (async function() {
    
    
    const geoJsonCoords = [[[[-128.90985381013775,50.15451159756744],[-138.450291223663,41.457139817335765],[-134.10648897177788,31.285608665560563],[-142.7188705783351,22.885971422359724],[-138.42043748614526,11.22287623237951],[-127.11406580207421,8.93189150044687],[-124.29849277976768,-1.4476428602001965],[-114.02904784459382,-5.24292940957167],[-105.17323884809628,0.8701881901666538],[-95.07033345637271,-4.3484866954754455],[-84.77330656823203,2.5046046873156858],[-85.63106856426799,13.836853809820953],[-75.99854824376126,19.35882343539422],[-74.64046816708004,30.21949219982811],[-84.58516703208811,37.099588896819945],[-81.91962699890831,48.295316381881364],[-98.56184761891002,55.218550700351585],[-112.78800392829437,48.011188120377795],[-128.90985381013775,50.15451159756744]],[[-118.48186571718101,16.572699557873406],[-121.3366283326517,28.653019311484535],[-110.25748485653355,36.800197061174266],[-96.66289038040519,31.619530626908528],[-96.05020989622146,19.26900694125663],[-106.5596852317401,12.150574686647923],[-118.48186571718101,16.572699557873406]]]];
    const coords = geoJsonCoords.map(polygon => polygon.map(ring => ring.slice().reverse()));
    const arrowStep =  1 ;
    const poly = {
      type: 'Feature',
      properties: { name: 'Polygon' },
      geometry: { type: 'MultiPolygon', coordinates: coords }
    };

    
    function getEdgeArrows(ring, step = 10) {
      const arrows = [];
      for (let i = 0; i < ring.length - 1; i += step) {
        const p1 = ring[i];
        const p2 = ring[i + 1];
        const interpolate = d3.geoInterpolate(p1, p2);
        
        arrows.push([interpolate(0.4), interpolate(0.6)]);
      }
      return arrows;
    }
    const edgeArrows = arrowStep > 0
      ? geoJsonCoords.flatMap(polygon => polygon.flatMap(ring => getEdgeArrows(ring, arrowStep)))
      : [];

    const container = document.getElementById('globe-gf');
    const getSize = () => {
      const width = container.offsetWidth || container.clientWidth;
      return width > 0 ? Math.min(600, width) : 600;
    };
    
    const inputRotate = null;
    const allPoints = coords.flatMap(polygon => polygon.flatMap(ring => ring));
    const centroid = d3.geoCentroid({ type: 'MultiPoint', coordinates: allPoints });
    
    const centerRotate = inputRotate
      ? [-inputRotate[0], -inputRotate[1], inputRotate[2] ?? 0]
      : [-centroid[0], -centroid[1], 0];
    const state = { rotate: centerRotate, width: getSize(), height: getSize() };

    if (!window.globeLandData) {
      const landTopo = await (await fetch('https://cdn.jsdelivr.net/npm/world-atlas@2/land-110m.json')).json();
      window.globeLandData = feature(landTopo, landTopo.objects.land);
    }
    const land = window.globeLandData;

    function preview(geometryOrFeature, rotate) {
      const marks = [
        Plot.geo(land, { stroke: '#88b', fill: 'none', strokeWidth: 0.8, strokeOpacity: 0.8 }),
        Plot.geo(geometryOrFeature, { fill: 'red', fillOpacity: 0.45, stroke: 'red', strokeOpacity: 0.7 }),
        Plot.graticule({ strokeOpacity: 0.06 }),
        Plot.sphere({ strokeWidth: 2 })
      ];

      if (arrowStep > 0) {
        edgeArrows.forEach(segment => {
          marks.push(Plot.line(segment, {
            x: d => d[0],
            y: d => d[1],
            markerEnd: 'arrow',
            stroke: 'darkred',
            strokeWidth: 1.5
          }));
        });
      }

      return Plot.plot({
        width: state.width,
        height: state.height,
        projection: { type: 'orthographic', rotate, inset: 1 },
        marks
      });
    }

    let frame = null;

    function render() {
      if (frame) return;
      frame = requestAnimationFrame(() => {
        frame = null;
        state.width = getSize();
        state.height = getSize();
        container.innerHTML = '';
        const svg = preview(poly, state.rotate);
        container.appendChild(svg);
        attachDrag(svg);
      });
    }

    window.addEventListener('resize', render);

    function attachDrag(svg) {
      const drag = d3.drag()
        .on('start', (event) => {
          drag.startX = event.x;
          drag.startY = event.y;
          drag.startRotate = state.rotate.slice();
        })
        .on('drag', (event) => {
          const dx = event.x - drag.startX;
          const dy = event.y - drag.startY;
          const k = 0.25;
          state.rotate = [
            drag.startRotate[0] + dx * k,
            drag.startRotate[1] - dy * k,
            0
          ];
          render();
        });
      d3.select(svg).call(drag);
      d3.select(svg).on('dblclick', () => {
        state.rotate = centerRotate.slice();
        render();
      });
    }

    render();
  })();
</script><p>exercise: if i were to give you the equator belt, which one of the two rings is
the outside? how can we decide?</p><h1 id=references>References</h1><ul><li><a href=https://macwright.com/2015/03/23/geojson-second-bite>More than you ever wanted to know about GeoJSON - macwright.com</a></li><li><a href=https://observablehq.com/@d3/winding-order>https://observablehq.com/@d3/winding-order</a></li></ul></content><p></p></main><footer>© 2025 AJ Friend · Made with <a href=https://github.com/janraasch/hugo-bearblog/>Hugo ʕ•ᴥ•ʔ Bear</a></footer></body></html>